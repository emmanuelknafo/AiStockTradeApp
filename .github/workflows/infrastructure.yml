name: Infrastructure Deployment

on:
  push:
    branches:
      - main
    paths:
      - "infrastructure/**"
      - ".github/workflows/infrastructure.yml"
      - '!**/*.md'
      - '!**/README.md'
      - '!**/*.mcp.json'
  pull_request:
    branches:
      - main
    paths:
      - "infrastructure/**"
      - ".github/workflows/infrastructure.yml"
      - '!**/*.md'
      - '!**/README.md'
      - '!**/*.mcp.json'
  workflow_dispatch:
    inputs:
      environment:
        description: "Environment to deploy infrastructure (selecting prod will deploy to dev and prod environments)"
        required: true
        default: "prod"
        type: choice
        options:
          - dev
          - prod
      location:
        description: "Azure region for deployment"
        required: true
        default: "Canada Central"
        type: string
      instanceNumber:
        description: "Instance number for resource differentiation"
        required: true
        default: "002"
        type: string
      destroy:
        description: "Destroy infrastructure instead of deploy"
        required: false
        default: false
        type: boolean

# Cancel in-progress runs when a new commit is pushed
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

# Environment inputs with safe fallbacks for automatic triggers
env:
  INSTANCE_NUMBER: ${{ github.event.inputs.instanceNumber || '002' }}
  INPUT_ENVIRONMENT: ${{ github.event.inputs.environment || 'prod' }}
  INPUT_LOCATION: ${{ github.event.inputs.location || 'Canada Central' }}
  INPUT_DESTROY: ${{ github.event.inputs.destroy || 'false' }}
  AZURE_RESOURCE_GROUP_DEV: "rg-aistock-dev-${{ github.event.inputs.instanceNumber || '002' }}"
  AZURE_RESOURCE_GROUP_PROD: "rg-aistock-prod-${{ github.event.inputs.instanceNumber || '002' }}"

jobs:
  deploy-dev:
    runs-on: [self-hosted, linux, x64]
    name: Deploy Development Infrastructure
    # Run when dispatched for dev/prod, or when triggered automatically by push/PR path filters
    if: (github.event.inputs.environment == 'dev' || github.event.inputs.environment == 'prod') || (github.event_name == 'push' || github.event_name == 'pull_request')
    environment: ${{ format('development-{0}', github.event.inputs.instanceNumber || '002') }}

    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ vars.AZURE_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}

      - name: Create Dev Resource Group
        if: env.INPUT_DESTROY != 'true'
        run: |
          RG_NAME="${{ env.AZURE_RESOURCE_GROUP_DEV }}"
          echo "Creating dev resource group: $RG_NAME"
          az group create --name "$RG_NAME" --location "${{ env.INPUT_LOCATION }}"

      - name: "Preflight cleanup: remove lingering AAD admin to avoid conflicts on re-deploy"
        run: |
          set -e
          if [ "${{ env.INPUT_DESTROY }}" = "true" ]; then echo "[DEV] destroy=true; skipping preflight cleanup"; exit 0; fi
          RG_NAME="${{ env.AZURE_RESOURCE_GROUP_DEV }}"
          SQL_SERVER_NAME="sql-aistock-dev-${{ env.INSTANCE_NUMBER }}"
          if az sql server show --name "$SQL_SERVER_NAME" --resource-group "$RG_NAME" >/dev/null 2>&1; then
            echo "[DEV] Server exists; checking Azure AD-only auth status..."
            AADONLY=$(az sql server show --name "$SQL_SERVER_NAME" --resource-group "$RG_NAME" --query "properties.azureADOnlyAuthentication" -o tsv 2>/dev/null || echo "")
            if [ "$AADONLY" = "true" ] || [ "$AADONLY" = "True" ]; then
              echo "[DEV] Azure AD-only authentication is enabled on server; skipping ad-admin delete to avoid InvalidServerAzureADAdminDeleteOperation"
            else
              echo "[DEV] Removing any lingering AAD admin..."
              az sql server ad-admin delete --server "$SQL_SERVER_NAME" --resource-group "$RG_NAME" || true
            fi
          else
            echo "[DEV] Server not present yet; nothing to clean."
          fi

      - name: Validate Dev Bicep Template
        if: env.INPUT_DESTROY != 'true'
        run: |
          RG_NAME="${{ env.AZURE_RESOURCE_GROUP_DEV }}"
          SQL_SERVER_NAME="sql-aistock-dev-${{ env.INSTANCE_NUMBER }}"
          echo "[DEV] Checking SQL server Azure AD-only auth status..."
          AADONLY=$(az sql server show --name "$SQL_SERVER_NAME" --resource-group "$RG_NAME" --query "properties.azureADOnlyAuthentication" -o tsv 2>/dev/null || echo "")
          echo "[DEV] azureADOnlyAuthentication='$AADONLY'"
          if [ "$AADONLY" = "false" ] || [ "$AADONLY" = "False" ]; then
            echo "[DEV] Azure AD-only auth not enabled; will manage SQL (manageSql=true)"
            MANAGE_SQL_PARAM="--parameters manageSql=true"
          else
            echo "[DEV] Azure AD-only auth enabled or check failed; skipping SQL management (manageSql=false)"
            MANAGE_SQL_PARAM="--parameters manageSql=false"
          fi

          az deployment group validate \
            --resource-group $RG_NAME \
            --template-file ./infrastructure/main.bicep \
            --parameters ./infrastructure/parameters.dev.json \
            --parameters location="${{ env.INPUT_LOCATION }}" \
            --parameters instanceNumber="${{ env.INSTANCE_NUMBER }}" \
            --parameters containerImage="aistocktradeapp:latest" \
            --parameters containerImageApi="aistocktradeapp-api:latest" \
            --parameters alphaVantageApiKey="${{ secrets.ALPHA_VANTAGE_API_KEY }}" \
            --parameters twelveDataApiKey="${{ secrets.TWELVE_DATA_API_KEY }}" \
            --parameters enablePrivateSql=true \
            --parameters enablePrivateKeyVault=true \
            --parameters vnetAddressSpace="10.40.0.0/16" \
            --parameters appIntegrationSubnetPrefix="10.40.1.0/27" \
            --parameters privateEndpointSubnetPrefix="10.40.2.0/28" \
            --parameters deployLoadTesting=true \
            $MANAGE_SQL_PARAM

      - name: Deploy Dev Infrastructure
        if: env.INPUT_DESTROY != 'true'
        run: |
          RG_NAME="${{ env.AZURE_RESOURCE_GROUP_DEV }}"
          SQL_SERVER_NAME="sql-aistock-dev-${{ env.INSTANCE_NUMBER }}"
          echo "[DEV] Checking SQL server Azure AD-only auth status..."
          AADONLY=$(az sql server show --name "$SQL_SERVER_NAME" --resource-group "$RG_NAME" --query "properties.azureADOnlyAuthentication" -o tsv 2>/dev/null || echo "")
          echo "[DEV] azureADOnlyAuthentication='$AADONLY'"
          if [ "$AADONLY" = "false" ] || [ "$AADONLY" = "False" ]; then
            echo "[DEV] Azure AD-only auth not enabled; will manage SQL (manageSql=true)"
            MANAGE_SQL_PARAM="--parameters manageSql=true"
          else
            echo "[DEV] Azure AD-only auth enabled or check failed; skipping SQL management (manageSql=false)"
            MANAGE_SQL_PARAM="--parameters manageSql=false"
          fi

          echo "Deploying dev infrastructure with container registry..."
          az deployment group create \
            --resource-group $RG_NAME \
            --template-file ./infrastructure/main.bicep \
            --parameters ./infrastructure/parameters.dev.json \
            --parameters location="${{ env.INPUT_LOCATION }}" \
            --parameters instanceNumber="${{ env.INSTANCE_NUMBER }}" \
            --parameters containerImage="aistocktradeapp:latest" \
            --parameters containerImageApi="aistocktradeapp-api:latest" \
            --parameters alphaVantageApiKey="${{ secrets.ALPHA_VANTAGE_API_KEY }}" \
            --parameters twelveDataApiKey="${{ secrets.TWELVE_DATA_API_KEY }}" \
            --parameters enablePrivateSql=true \
            --parameters enablePrivateKeyVault=true \
            --parameters vnetAddressSpace="10.40.0.0/16" \
            --parameters appIntegrationSubnetPrefix="10.40.1.0/27" \
            --parameters privateEndpointSubnetPrefix="10.40.2.0/28" \
            --parameters deployLoadTesting=true \
            $MANAGE_SQL_PARAM

      - name: Set Shared UAMI as SQL Entra Admin (Dev)
        if: env.INPUT_DESTROY != 'true'
        run: |
          set -e
          INSTANCE_NUM="${{ env.INSTANCE_NUMBER }}"
          RG_NAME="rg-aistock-dev-${INSTANCE_NUM}"
          SQL_SERVER_NAME="sql-aistock-dev-${INSTANCE_NUM}"
          # Resolve shared UAMI name from parameters
          APP_NAME=$(python -c "import json;print(json.load(open('infrastructure/parameters.dev.json'))['parameters']['appName']['value'])")
          ENV_NAME=$(python -c "import json;print(json.load(open('infrastructure/parameters.dev.json'))['parameters']['environment']['value'])")
          IDENTITY_NAME="ui-${APP_NAME}-${ENV_NAME}-${INSTANCE_NUM}"
          echo "[DEV] Resolving shared user-assigned identity: $IDENTITY_NAME"
          PRINCIPAL_ID=$(az identity show --resource-group "$RG_NAME" --name "$IDENTITY_NAME" --query principalId -o tsv 2>/dev/null || echo "")
          if [ -z "$PRINCIPAL_ID" ] || [ "$PRINCIPAL_ID" = "null" ]; then echo "[DEV][ERROR] Could not resolve principalId for UAMI $IDENTITY_NAME in $RG_NAME"; exit 1; fi
          echo "[DEV] UAMI principalId: $PRINCIPAL_ID"

          echo "[DEV] Checking current SQL Entra admin..."
          CURRENT_ADMIN_LOGIN=$(az sql server ad-admin list --server "$SQL_SERVER_NAME" --resource-group "$RG_NAME" --query "[0].login" -o tsv 2>/dev/null || echo "")
          CURRENT_ADMIN_OID=$(az sql server ad-admin list --server "$SQL_SERVER_NAME" --resource-group "$RG_NAME" --query "[0].sid" -o tsv 2>/dev/null || echo "")
          if [ "$CURRENT_ADMIN_OID" = "$PRINCIPAL_ID" ]; then
            echo "[DEV] Desired admin already set to UAMI ($CURRENT_ADMIN_LOGIN) - skipping reconfiguration."
            if [ "$CURRENT_ADMIN_LOGIN" != "$IDENTITY_NAME" ]; then
              echo "[DEV] Display name mismatch ($CURRENT_ADMIN_LOGIN != $IDENTITY_NAME); normalizing..."
              az sql server ad-admin delete --server "$SQL_SERVER_NAME" --resource-group "$RG_NAME" || true
              sleep 5
              az sql server ad-admin create --server "$SQL_SERVER_NAME" --resource-group "$RG_NAME" --display-name "$IDENTITY_NAME" --object-id "$PRINCIPAL_ID"
            fi
          else
            if [ -n "$CURRENT_ADMIN_LOGIN" ]; then
              echo "[DEV] Replacing existing admin '$CURRENT_ADMIN_LOGIN' with shared UAMI"
              az sql server ad-admin delete --server "$SQL_SERVER_NAME" --resource-group "$RG_NAME" || true
              sleep 5
            else
              echo "[DEV] No existing Entra admin set; creating new admin with shared UAMI"
            fi
            az sql server ad-admin create --server "$SQL_SERVER_NAME" --resource-group "$RG_NAME" --display-name "$IDENTITY_NAME" --object-id "$PRINCIPAL_ID"
          fi
          echo "[DEV] Waiting for admin propagation..."
          get_admin_sid() {
            local list_sid
            list_sid=$(az sql server ad-admin list --server "$SQL_SERVER_NAME" --resource-group "$RG_NAME" --query "[?login=='$IDENTITY_NAME'].sid | [0]" -o tsv 2>/dev/null || echo "")
            if [ -n "$list_sid" ] && [ "$list_sid" != "null" ]; then echo "$list_sid"; return; fi
            echo ""
          }
          echo "[DEV] Waiting for admin propagation..."
          sleep 8
          PROPAGATED=false
          for i in $(seq 1 24); do
            ADMIN_OID=$(get_admin_sid)
            if [ "$ADMIN_OID" = "$PRINCIPAL_ID" ]; then echo "[DEV] Admin propagation confirmed (attempt $i)"; PROPAGATED=true; break; fi
            echo "[DEV] Admin not propagated yet (attempt $i); current='$ADMIN_OID'; sleeping 5s..."; sleep 5
          done
          if [ "$PROPAGATED" != "true" ]; then
            echo "[DEV][WARN] Propagation not confirmed after initial window. Gathering diagnostics..."
            echo "[DEV] LIST JSON:"; az sql server ad-admin list --server "$SQL_SERVER_NAME" --resource-group "$RG_NAME" -o json || echo "(list failed)"
            ANY_MATCH=$(az sql server ad-admin list --server "$SQL_SERVER_NAME" --resource-group "$RG_NAME" --query "[?sid=='$PRINCIPAL_ID'] | length(@)" -o tsv 2>/dev/null || echo "0")
            if [ "$ANY_MATCH" = "1" ]; then
              echo "[DEV][INFO] Principal ID appears in admin list despite show mismatch; proceeding (eventual consistency)."
              PROPAGATED=true
            fi
          fi
          FINAL_OID=$(get_admin_sid)
          if [ "$PROPAGATED" != "true" ] || [ "$FINAL_OID" != "$PRINCIPAL_ID" ]; then
            echo "[DEV][ERROR] Admin assignment did not propagate correctly (expected=$PRINCIPAL_ID, final=$FINAL_OID)"; exit 1; fi
          echo "[DEV] Shared UAMI is confirmed as SQL Entra admin (sid=$FINAL_OID)."

  # API step not needed; shared UAMI covers both UI and API

      - name: Enable Azure AD-only Authentication (Dev)
        if: env.INPUT_DESTROY != 'true'
        run: |
          INSTANCE_NUM="${{ env.INSTANCE_NUMBER }}"
          RG_NAME="rg-aistock-dev-${INSTANCE_NUM}"
          SQL_SERVER_NAME="sql-aistock-dev-${INSTANCE_NUM}"
          echo "[DEV] Enabling Azure AD-only authentication on $SQL_SERVER_NAME..."
          az sql server ad-only-auth enable --resource-group "$RG_NAME" --name "$SQL_SERVER_NAME"

      - name: Verify Dev Infrastructure SQL Setup
        if: env.INPUT_DESTROY != 'true'
        run: |
          INSTANCE_NUM="${{ env.INSTANCE_NUMBER }}"
          SQL_SERVER_NAME="sql-aistock-dev-${INSTANCE_NUM}"
          DATABASE_NAME="sqldb-aistock-dev-${INSTANCE_NUM}"

          echo "ðŸ” Verifying SQL Server setup for dev environment..."
          echo "SQL Server: ${SQL_SERVER_NAME}.database.windows.net"
          echo "Database: ${DATABASE_NAME}"

          # Test basic connectivity to SQL Server
          echo "Testing SQL Server connectivity..."
          if az sql server show --name "${SQL_SERVER_NAME}" --resource-group ${{ env.AZURE_RESOURCE_GROUP_DEV }} >/dev/null 2>&1; then
            echo "âœ… SQL Server is accessible"

            # Check if database exists
            if az sql db show --name "${DATABASE_NAME}" --server "${SQL_SERVER_NAME}" --resource-group ${{ env.AZURE_RESOURCE_GROUP_DEV }} >/dev/null 2>&1; then
              echo "âœ… Database is accessible"
              echo "ðŸŽ¯ Infrastructure deployment successful - ready for application deployment"
            else
              echo "âš ï¸ Database not found - may need to be created during first app deployment"
            fi
          else
            echo "âŒ SQL Server not accessible - check deployment"
            exit 1
          fi

      - name: Destroy Dev Infrastructure
        if: env.INPUT_DESTROY == 'true'
        continue-on-error: true # Don't fail the workflow if dev destruction has issues
        run: |
          RG_NAME="${{ env.AZURE_RESOURCE_GROUP_DEV }}"
          INSTANCE_NUM="${{ env.INSTANCE_NUMBER }}"
          KV_NAME="kv-aistock-dev-${INSTANCE_NUM}"

          echo "=== Destroying dev infrastructure ==="
          echo "Resource Group: $RG_NAME"
          echo "Key Vault: $KV_NAME"

          # First, check if resource group exists
          echo "Checking if resource group exists: $RG_NAME"
          if ! az group show --name "$RG_NAME" >/dev/null 2>&1; then
            echo "â„¹ï¸ Resource group $RG_NAME not found - already deleted or never existed"
            echo "âœ… Dev infrastructure destruction completed (nothing to destroy)"
            exit 0
          fi

          echo "âœ… Resource group found. Proceeding with destruction..."

          # Check if Key Vault exists
          echo "Checking for Key Vault: $KV_NAME"
          KV_EXISTS=false
          if az keyvault show --name "$KV_NAME" --resource-group "$RG_NAME" >/dev/null 2>&1; then
            echo "âœ… Key Vault found. Will be handled after resource group deletion."
            KV_EXISTS=true
          else
            echo "â„¹ï¸ Key Vault not found or already deleted."
          fi

          # Delete the resource group (this will soft-delete the Key Vault)
          echo "ðŸ—‘ï¸ Deleting resource group: $RG_NAME"
          if az group delete --name "$RG_NAME" --yes --no-wait; then
            echo "âœ… Resource group deletion initiated successfully"
          else
            echo "âš ï¸ Failed to delete resource group, but continuing..."
            exit 0
          fi

          # Only attempt Key Vault purge if it existed
          if [ "$KV_EXISTS" = true ]; then
            echo "â³ Waiting 60 seconds for deletion to propagate..."
            sleep 60

            echo "ðŸ” Checking if Key Vault is in soft-delete state..."

            # First check if the Key Vault is actually in the deleted/soft-delete state
            DELETED_KV=$(az keyvault list-deleted --query "[?name=='$KV_NAME'].name" --output tsv 2>/dev/null || echo "")

            if [ -n "$DELETED_KV" ]; then
              echo "ðŸ§¹ Key Vault found in soft-delete state. Attempting to purge..."

              # Try multiple times with increasing delays
              for attempt in 1 2 3; do
                echo "Purge attempt $attempt/3..."
                if az keyvault purge --name "$KV_NAME" --location "${{ env.INPUT_LOCATION }}" >/dev/null 2>&1; then
                  echo "âœ… Key Vault $KV_NAME purged successfully on attempt $attempt"
                  break
                else
                  if [ $attempt -lt 3 ]; then
                    echo "â³ Attempt $attempt failed. Waiting 30 seconds before retry..."
                    sleep 30
                  else
                    echo "âš ï¸ Could not purge Key Vault after 3 attempts."
                    echo "This may happen if the Key Vault is still being processed."
                    echo "You can manually purge it later with:"
                    echo "az keyvault purge --name $KV_NAME --location '${{ env.INPUT_LOCATION }}'"
                  fi
                fi
              done
            else
              echo "â„¹ï¸ Key Vault is not in soft-delete state - no purge needed"
              echo "This is normal if the Key Vault was already purged or if soft-delete is disabled"
            fi
          fi

          echo "âœ… Dev infrastructure destruction process completed"

  deploy-prod:
    runs-on: [self-hosted, linux, x64]
    name: Deploy Production Infrastructure
    needs: deploy-dev
    if: (github.event.inputs.environment == 'prod' || github.event_name == 'push' || github.event_name == 'pull_request') && always() && (needs.deploy-dev.result == 'success' || (github.event.inputs.destroy == 'true' && needs.deploy-dev.result != 'cancelled'))
    environment: ${{ format('production-{0}', github.event.inputs.instanceNumber || '002') }}

    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ vars.AZURE_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}

      - name: Create Prod Resource Group
        if: env.INPUT_DESTROY != 'true'
        run: |
          RG_NAME="${{ env.AZURE_RESOURCE_GROUP_PROD }}"
          echo "Creating prod resource group: $RG_NAME"
          az group create --name "$RG_NAME" --location "${{ env.INPUT_LOCATION }}"

      - name: "Preflight cleanup: remove lingering AAD admin to avoid conflicts on re-deploy (prod)"
        run: |
          set -e
          # Ensure this step only runs for prod and when not destroying
          if [ "${{ env.INPUT_DESTROY }}" = "true" ] || [ "${{ env.INPUT_ENVIRONMENT }}" != "prod" ]; then echo "[PROD] Skipping prod preflight cleanup (destroy or not prod)"; exit 0; fi
          RG_NAME="${{ env.AZURE_RESOURCE_GROUP_PROD }}"
          SQL_SERVER_NAME="sql-aistock-prod-${{ env.INSTANCE_NUMBER }}"
          if az sql server show --name "$SQL_SERVER_NAME" --resource-group "$RG_NAME" >/dev/null 2>&1; then
            echo "[PROD] Server exists; checking Azure AD-only auth status..."
            AADONLY=$(az sql server show --name "$SQL_SERVER_NAME" --resource-group "$RG_NAME" --query "properties.azureADOnlyAuthentication" -o tsv 2>/dev/null || echo "")
            if [ "$AADONLY" = "true" ] || [ "$AADONLY" = "True" ]; then
              echo "[PROD] Azure AD-only authentication is enabled on server; skipping ad-admin delete to avoid InvalidServerAzureADDeleteOperation"
            else
              echo "[PROD] Removing any lingering AAD admin..."
              az sql server ad-admin delete --server "$SQL_SERVER_NAME" --resource-group "$RG_NAME" || true
            fi
          else
            echo "[PROD] Server not present yet; nothing to clean."
          fi

      - name: Validate Prod Bicep Template
        if: env.INPUT_DESTROY != 'true'
        run: |
          RG_NAME="${{ env.AZURE_RESOURCE_GROUP_PROD }}"
          SQL_SERVER_NAME="sql-aistock-prod-${{ env.INSTANCE_NUMBER }}"
          echo "[PROD] Checking SQL server Azure AD-only auth status..."
          AADONLY=$(az sql server show --name "$SQL_SERVER_NAME" --resource-group "$RG_NAME" --query "properties.azureADOnlyAuthentication" -o tsv 2>/dev/null || echo "")
          echo "[PROD] azureADOnlyAuthentication='$AADONLY'"
          if [ "$AADONLY" = "false" ] || [ "$AADONLY" = "False" ]; then
            echo "[PROD] Azure AD-only auth not enabled; will manage SQL (manageSql=true)"
            MANAGE_SQL_PARAM="--parameters manageSql=true"
          else
            echo "[PROD] Azure AD-only auth enabled or check failed; skipping SQL management (manageSql=false)"
            MANAGE_SQL_PARAM="--parameters manageSql=false"
          fi

          az deployment group validate \
            --resource-group $RG_NAME \
            --template-file ./infrastructure/main.bicep \
            --parameters ./infrastructure/parameters.prod.json \
            --parameters location="${{ env.INPUT_LOCATION }}" \
            --parameters instanceNumber="${{ env.INSTANCE_NUMBER }}" \
            --parameters containerImage="aistocktradeapp:latest" \
            --parameters containerImageApi="aistocktradeapp-api:latest" \
            --parameters alphaVantageApiKey="${{ secrets.ALPHA_VANTAGE_API_KEY }}" \
            --parameters twelveDataApiKey="${{ secrets.TWELVE_DATA_API_KEY }}" \
            --parameters deployContainerRegistry=false \
            --parameters enablePrivateSql=true \
            --parameters enablePrivateKeyVault=true \
            --parameters vnetAddressSpace="10.41.0.0/16" \
            --parameters appIntegrationSubnetPrefix="10.41.1.0/27" \
            --parameters privateEndpointSubnetPrefix="10.41.2.0/28" \
            $MANAGE_SQL_PARAM

      - name: Deploy Prod Infrastructure
        if: env.INPUT_DESTROY != 'true'
        run: |
          RG_NAME="${{ env.AZURE_RESOURCE_GROUP_PROD }}"
          SQL_SERVER_NAME="sql-aistock-prod-${{ env.INSTANCE_NUMBER }}"
          echo "[PROD] Checking SQL server Azure AD-only auth status..."
          AADONLY=$(az sql server show --name "$SQL_SERVER_NAME" --resource-group "$RG_NAME" --query "properties.azureADOnlyAuthentication" -o tsv 2>/dev/null || echo "")
          echo "[PROD] azureADOnlyAuthentication='$AADONLY'"
          if [ "$AADONLY" = "false" ] || [ "$AADONLY" = "False" ]; then
            echo "[PROD] Azure AD-only auth not enabled; will manage SQL (manageSql=true)"
            MANAGE_SQL_PARAM="--parameters manageSql=true"
          else
            echo "[PROD] Azure AD-only auth enabled or check failed; skipping SQL management (manageSql=false)"
            MANAGE_SQL_PARAM="--parameters manageSql=false"
          fi

          echo "Deploying prod infrastructure WITHOUT container registry..."
          az deployment group create \
            --resource-group $RG_NAME \
            --template-file ./infrastructure/main.bicep \
            --parameters ./infrastructure/parameters.prod.json \
            --parameters location="${{ env.INPUT_LOCATION }}" \
            --parameters instanceNumber="${{ env.INSTANCE_NUMBER }}" \
            --parameters containerImage="aistocktradeapp:latest" \
            --parameters containerImageApi="aistocktradeapp-api:latest" \
            --parameters alphaVantageApiKey="${{ secrets.ALPHA_VANTAGE_API_KEY }}" \
            --parameters twelveDataApiKey="${{ secrets.TWELVE_DATA_API_KEY }}" \
            --parameters deployContainerRegistry=false \
            --parameters enablePrivateSql=true \
            --parameters enablePrivateKeyVault=true \
            --parameters vnetAddressSpace="10.41.0.0/16" \
            --parameters appIntegrationSubnetPrefix="10.41.1.0/27" \
            --parameters privateEndpointSubnetPrefix="10.41.2.0/28" \
            $MANAGE_SQL_PARAM

      - name: Set Shared UAMI as SQL Entra Admin (Prod)
        if: env.INPUT_DESTROY != 'true'
        run: |
          set -e
          INSTANCE_NUM="${{ env.INSTANCE_NUMBER }}"
          RG_NAME="rg-aistock-prod-${INSTANCE_NUM}"
          SQL_SERVER_NAME="sql-aistock-prod-${INSTANCE_NUM}"
          # Resolve shared UAMI name from parameters
          APP_NAME=$(python -c "import json;print(json.load(open('infrastructure/parameters.prod.json'))['parameters']['appName']['value'])")
          ENV_NAME=$(python -c "import json;print(json.load(open('infrastructure/parameters.prod.json'))['parameters']['environment']['value'])")
          IDENTITY_NAME="ui-${APP_NAME}-${ENV_NAME}-${INSTANCE_NUM}"
          echo "[PROD] Resolving shared user-assigned identity: $IDENTITY_NAME"
          PRINCIPAL_ID=$(az identity show --resource-group "$RG_NAME" --name "$IDENTITY_NAME" --query principalId -o tsv 2>/dev/null || echo "")
          if [ -z "$PRINCIPAL_ID" ] || [ "$PRINCIPAL_ID" = "null" ]; then echo "[PROD][ERROR] Could not resolve principalId for UAMI $IDENTITY_NAME in $RG_NAME"; exit 1; fi
          echo "[PROD] UAMI principalId: $PRINCIPAL_ID"

          echo "[PROD] Checking current SQL Entra admin..."
          CURRENT_ADMIN_LOGIN=$(az sql server ad-admin list --server "$SQL_SERVER_NAME" --resource-group "$RG_NAME" --query "[0].login" -o tsv 2>/dev/null || echo "")
          CURRENT_ADMIN_OID=$(az sql server ad-admin list --server "$SQL_SERVER_NAME" --resource-group "$RG_NAME" --query "[0].sid" -o tsv 2>/dev/null || echo "")
          if [ "$CURRENT_ADMIN_OID" = "$PRINCIPAL_ID" ]; then
            echo "[PROD] Desired admin already set to UAMI ($CURRENT_ADMIN_LOGIN)."
            if [ "$CURRENT_ADMIN_LOGIN" != "$IDENTITY_NAME" ]; then
              echo "[PROD] Display name mismatch ($CURRENT_ADMIN_LOGIN != $IDENTITY_NAME); normalizing..."
              az sql server ad-admin delete --server "$SQL_SERVER_NAME" --resource-group "$RG_NAME" || true
              sleep 5
              az sql server ad-admin create --server "$SQL_SERVER_NAME" --resource-group "$RG_NAME" --display-name "$IDENTITY_NAME" --object-id "$PRINCIPAL_ID"
            fi
          else
            if [ -n "$CURRENT_ADMIN_LOGIN" ]; then
              echo "[PROD] Existing admin '$CURRENT_ADMIN_LOGIN' (sid=$CURRENT_ADMIN_OID) differs from UAMI (sid=$PRINCIPAL_ID); replacing..."
              az sql server ad-admin delete --server "$SQL_SERVER_NAME" --resource-group "$RG_NAME" || true
              sleep 5
            else
              echo "[PROD] No existing Entra admin; creating new UAMI admin."
            fi
            az sql server ad-admin create --server "$SQL_SERVER_NAME" --resource-group "$RG_NAME" --display-name "$IDENTITY_NAME" --object-id "$PRINCIPAL_ID"
          fi

          echo "[PROD] Waiting for admin propagation..."
          get_admin_sid_prod() {
            local sid_any
            sid_any=$(az sql server ad-admin list --server "$SQL_SERVER_NAME" --resource-group "$RG_NAME" --query "[0].sid" -o tsv 2>/dev/null || echo "")
            if [ -n "$sid_any" ] && [ "$sid_any" != "null" ]; then echo "$sid_any"; return; fi
            echo ""
          }
          sleep 8
          PROPAGATED=false
          for i in $(seq 1 24); do
            ADMIN_OID=$(get_admin_sid_prod)
            if [ "$ADMIN_OID" = "$PRINCIPAL_ID" ]; then echo "[PROD] Admin propagation confirmed (attempt $i)"; PROPAGATED=true; break; fi
            echo "[PROD] Admin not propagated yet (attempt $i); current='$ADMIN_OID'; sleeping 5s..."; sleep 5
          done
          if [ "$PROPAGATED" != "true" ]; then
            echo "[PROD][WARN] Propagation not confirmed after initial window. Gathering diagnostics..."
            echo "[PROD] LIST JSON:"; az sql server ad-admin list --server "$SQL_SERVER_NAME" --resource-group "$RG_NAME" -o json || echo "(list failed)"
            ANY_MATCH=$(az sql server ad-admin list --server "$SQL_SERVER_NAME" --resource-group "$RG_NAME" --query "[?sid=='$PRINCIPAL_ID'] | length(@)" -o tsv 2>/dev/null || echo "0")
            if [ "$ANY_MATCH" = "1" ]; then
              echo "[PROD][INFO] Principal ID appears in admin list despite show mismatch; proceeding (eventual consistency)."
              PROPAGATED=true
            fi
          fi
          FINAL_OID=$(get_admin_sid_prod)
          if [ "$PROPAGATED" != "true" ] || [ "$FINAL_OID" != "$PRINCIPAL_ID" ]; then
            echo "[PROD][ERROR] Admin assignment did not propagate correctly (expected=$PRINCIPAL_ID, final=$FINAL_OID)"; exit 1; fi
          echo "[PROD] Shared UAMI is confirmed as SQL Entra admin (sid=$FINAL_OID)."

  # API step not needed; shared UAMI covers both UI and API

      - name: Enable Azure AD-only Authentication (Prod)
        if: env.INPUT_DESTROY != 'true'
        run: |
          INSTANCE_NUM="${{ env.INSTANCE_NUMBER }}"
          RG_NAME="rg-aistock-prod-${INSTANCE_NUM}"
          SQL_SERVER_NAME="sql-aistock-prod-${INSTANCE_NUM}"
          echo "[PROD] Enabling Azure AD-only authentication on $SQL_SERVER_NAME..."
          az sql server ad-only-auth enable --resource-group "$RG_NAME" --name "$SQL_SERVER_NAME"

      - name: Verify Prod Infrastructure SQL Setup
        if: env.INPUT_DESTROY != 'true'
        run: |
          INSTANCE_NUM="${{ env.INSTANCE_NUMBER }}"
          SQL_SERVER_NAME="sql-aistock-prod-${INSTANCE_NUM}"
          DATABASE_NAME="sqldb-aistock-prod-${INSTANCE_NUM}"

          echo "ðŸ” Verifying SQL Server setup for production environment..."
          echo "SQL Server: ${SQL_SERVER_NAME}.database.windows.net"
          echo "Database: ${DATABASE_NAME}"

          # Test basic connectivity to SQL Server
          echo "Testing SQL Server connectivity..."
          if az sql server show --name "${SQL_SERVER_NAME}" --resource-group ${{ env.AZURE_RESOURCE_GROUP_PROD }} >/dev/null 2>&1; then
            echo "âœ… SQL Server is accessible"

            # Check if database exists
            if az sql db show --name "${DATABASE_NAME}" --server "${SQL_SERVER_NAME}" --resource-group ${{ env.AZURE_RESOURCE_GROUP_PROD }} >/dev/null 2>&1; then
              echo "âœ… Database is accessible"

              # For production, also verify Azure AD configuration
              echo "ðŸ” Checking Azure AD configuration..."
              AD_ADMIN=$(az sql server ad-admin list --server "${SQL_SERVER_NAME}" --resource-group ${{ env.AZURE_RESOURCE_GROUP_PROD }} --query '[0].login' --output tsv 2>/dev/null || echo "")
              if [ -n "$AD_ADMIN" ] && [ "$AD_ADMIN" != "null" ]; then
                echo "âœ… Azure AD admin configured: $AD_ADMIN"
                echo "ðŸŽ¯ Production infrastructure deployment successful - ready for application deployment"
                echo ""
                echo "ðŸ“‹ Next steps for application deployment:"
                echo "   1. CI/CD pipeline will automatically create managed identity SQL user"
                echo "   2. Application will use Azure AD authentication to connect"
                echo "   3. Health checks should pass automatically"
              else
                echo "âš ï¸ Azure AD admin not configured - using SQL authentication"
                echo "ðŸŽ¯ Infrastructure deployment successful - ready for application deployment"
              fi
            else
              echo "âš ï¸ Database not found - may need to be created during first app deployment"
            fi
          else
            echo "âŒ SQL Server not accessible - check deployment"
            exit 1
          fi

      - name: Destroy Prod Infrastructure
        if: env.INPUT_DESTROY == 'true'
        run: |
          RG_NAME="${{ env.AZURE_RESOURCE_GROUP_PROD }}"
          INSTANCE_NUM="${{ env.INSTANCE_NUMBER }}"
          KV_NAME="kv-aistock-prod-${INSTANCE_NUM}"

          echo "=== Destroying prod infrastructure ==="
          echo "Resource Group: $RG_NAME"
          echo "Key Vault: $KV_NAME"

          # First, check if resource group exists
          echo "Checking if resource group exists: $RG_NAME"
          if ! az group show --name "$RG_NAME" >/dev/null 2>&1; then
            echo "â„¹ï¸ Resource group $RG_NAME not found - already deleted or never existed"
            echo "âœ… Prod infrastructure destruction completed (nothing to destroy)"
            exit 0
          fi

          echo "âœ… Resource group found. Proceeding with destruction..."

          # Check if Key Vault exists
          echo "Checking for Key Vault: $KV_NAME"
          KV_EXISTS=false
          if az keyvault show --name "$KV_NAME" --resource-group "$RG_NAME" >/dev/null 2>&1; then
            echo "âœ… Key Vault found. Will be handled after resource group deletion."
            KV_EXISTS=true
          else
            echo "â„¹ï¸ Key Vault not found or already deleted."
          fi

          # Delete the resource group (this will soft-delete the Key Vault)
          echo "ðŸ—‘ï¸ Deleting resource group: $RG_NAME"
          if az group delete --name "$RG_NAME" --yes --no-wait; then
            echo "âœ… Resource group deletion initiated successfully"
          else
            echo "âš ï¸ Failed to delete resource group, but continuing..."
            exit 0
          fi

          # Only attempt Key Vault purge if it existed
          if [ "$KV_EXISTS" = true ]; then
            echo "â³ Waiting 60 seconds for deletion to propagate..."
            sleep 60

            echo "ðŸ” Checking if Key Vault is in soft-delete state..."

            # First check if the Key Vault is actually in the deleted/soft-delete state
            DELETED_KV=$(az keyvault list-deleted --query "[?name=='$KV_NAME'].name" --output tsv 2>/dev/null || echo "")

            if [ -n "$DELETED_KV" ]; then
              echo "ðŸ§¹ Key Vault found in soft-delete state. Attempting to purge..."

              # Try multiple times with increasing delays
              for attempt in 1 2 3; do
                echo "Purge attempt $attempt/3..."
                if az keyvault purge --name "$KV_NAME" --location "${{ env.INPUT_LOCATION }}" >/dev/null 2>&1; then
                  echo "âœ… Key Vault $KV_NAME purged successfully on attempt $attempt"
                  break
                else
                  if [ $attempt -lt 3 ]; then
                    echo "â³ Attempt $attempt failed. Waiting 30 seconds before retry..."
                    sleep 30
                  else
                    echo "âš ï¸ Could not purge Key Vault after 3 attempts."
                    echo "This may happen if the Key Vault is still being processed."
                    echo "az keyvault purge --name $KV_NAME --location '${{ env.INPUT_LOCATION }}'"
                  fi
                fi
              done
            else
              echo "â„¹ï¸ Key Vault is not in soft-delete state - no purge needed"
              echo "This is normal if the Key Vault was already purged or if soft-delete is disabled"
            fi
          fi

          echo "âœ… Prod infrastructure destruction process completed"

  deployment-summary:
    runs-on: [self-hosted, linux, x64]
    name: Deployment Summary
    needs: [deploy-dev, deploy-prod]
    if: always() && github.event.inputs.destroy != 'true'

    steps:
      - name: Generate Summary
        run: |
          echo "## Infrastructure Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment Requested**: ${{ env.INPUT_ENVIRONMENT }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Instance Number**: ${{ env.INSTANCE_NUMBER }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Location**: ${{ env.INPUT_LOCATION }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "${{ needs.deploy-dev.result }}" == "success" ]; then
            echo "âœ… **Dev Infrastructure**: Deployed successfully" >> $GITHUB_STEP_SUMMARY
            echo "- **Dev Resource Group**: ${{ env.AZURE_RESOURCE_GROUP_DEV }}" >> $GITHUB_STEP_SUMMARY
            echo "- **Dev Web App**: https://app-aistock-dev-${{ env.INSTANCE_NUMBER }}.azurewebsites.net" >> $GITHUB_STEP_SUMMARY
            echo "- **Container Registry**: Deployed in dev environment (shared with prod)" >> $GITHUB_STEP_SUMMARY
          else
            echo "âŒ **Dev Infrastructure**: ${{ needs.deploy-dev.result }}" >> $GITHUB_STEP_SUMMARY
          fi

          if [ "${{ env.INPUT_ENVIRONMENT }}" == "prod" ]; then
            if [ "${{ needs.deploy-prod.result }}" == "success" ]; then
              echo "âœ… **Prod Infrastructure**: Deployed successfully" >> $GITHUB_STEP_SUMMARY
              echo "- **Prod Resource Group**: ${{ env.AZURE_RESOURCE_GROUP_PROD }}" >> $GITHUB_STEP_SUMMARY
              echo "- **Prod Web App**: https://app-aistock-prod-${{ env.INSTANCE_NUMBER }}.azurewebsites.net" >> $GITHUB_STEP_SUMMARY
              echo "- **Container Registry**: Uses shared registry from dev environment" >> $GITHUB_STEP_SUMMARY
            else
              echo "âŒ **Prod Infrastructure**: ${{ needs.deploy-prod.result }}" >> $GITHUB_STEP_SUMMARY
            fi
          fi
