name: CI/CD Pipeline

on:
  push:
    branches: [main]
    paths-ignore:
      - "**.md"
      - "**/README.md"
      - "docs/**"
      - "scripts/**"
      - "AiStockTradeApp/scripts/**"
      - "*.txt"
      - ".gitignore"
      - ".vscode/**"
      - ".vs/**"
      - ".azuredevops/**"
      #- '.github/**'
      - "AGENTS.md"
      - "LICENSE"
      - "data/**"
      - "AiStockTradeApp.Cli/**"
      - ".github/workflows/cli-ci.yml"
      - ".github/workflows/load-tests.yml"
      - ".github/workflows/alt-load-tests.yml"
      - ".github/workflows/infrastructure.yml"
      - ".github/workflows/generate-changelog.yml"
      - ".github/workflows/publish-mcpserver.yml"
      - "load-tests/**"
      - "infrastructure/**"
      - "**/*.mcp.json"
      - 'AiStockTradeApp.SeleniumTests/**'
      - '.github/workflows/selenium-tests.yml'
      - '.github/workflows/runner-maintenance.yml'  # Exclude runner maintenance workflow changes
  pull_request:
    branches: [main]
    paths-ignore:
      - "**.md"
      - "**/README.md"
      - "docs/**"
      - "scripts/**"
      - "AiStockTradeApp/scripts/**"
      - "*.txt"
      - ".gitignore"
      - ".vscode/**"
      - ".vs/**"
      - ".azuredevops/**"
      #- '.github/**'
      - "AGENTS.md"
      - "LICENSE"
      - "data/**"
      - "AiStockTradeApp.Cli/**"
      - ".github/workflows/cli-ci.yml"
      - ".github/workflows/load-tests.yml"
      - ".github/workflows/alt-load-tests.yml"
      - ".github/workflows/infrastructure.yml"
      - ".github/workflows/generate-changelog.yml"
      - ".github/workflows/publish-mcpserver.yml"
      - "load-tests/**"
      - "infrastructure/**"
      - "**/*.mcp.json"
      - 'AiStockTradeApp.SeleniumTests/**'
      - '.github/workflows/selenium-tests.yml'
      - '.github/workflows/runner-maintenance.yml'  # Exclude runner maintenance workflow changes
      
  # CI triggers temporarily disabled; manual runs only
  workflow_dispatch:
    inputs:
      environment:
        description: "Environment to deploy to"
        required: true
        default: "dev"
        type: choice
        options:
          - dev
          - prod
      instanceNumber:
        description: "Instance number for resource differentiation"
        required: true
        default: "002"
        type: string
      appServicePlanSku:
        description: "App Service Plan SKU"
        required: true
        default: "P0v3"
        type: choice
        options:
          - B1
          - S1
          - P0v3
          - P1v3
          - P2v3
          - P3v3
  workflow_run:
    workflows: ["Infrastructure Deployment"]
    types: [completed]

# Cancel in-progress runs when a new commit is pushed
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true
env:
  AZURE_WEBAPP_PACKAGE_PATH: "."
  DOTNET_VERSION: "9.0.x"
  # Map GitHub repository variables into env.* for consistent context usage
  AZURE_CLIENT_ID: ${{ vars.AZURE_CLIENT_ID }}
  AZURE_TENANT_ID: ${{ vars.AZURE_TENANT_ID }}
  AZURE_SUBSCRIPTION_ID: ${{ vars.AZURE_SUBSCRIPTION_ID }}

jobs:
  test:
    if: ${{ github.event_name != 'workflow_run' || github.event.workflow_run.conclusion == 'success' }}
    runs-on: [self-hosted, linux, x64]
    name: Test Application

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Full history so GitVersion can calculate properly
          fetch-tags: true # Ensure tags are available for GitVersion

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Install GitVersion
        uses: gittools/actions/gitversion/setup@v0
        with:
          versionSpec: "5.x"

      - name: Determine Version
        id: gitversion
        uses: gittools/actions/gitversion/execute@v0

      - name: Display computed version
        run: |
          echo "FullSemVer=${{ steps.gitversion.outputs.fullSemVer }}"
          echo "AssemblySemVer=${{ steps.gitversion.outputs.assemblySemVer }}"
          echo "InformationalVersion=${{ steps.gitversion.outputs.informationalVersion }}"
          echo "Version for downstream usage set"

      - name: Validate no legacy KeyVault connection string (Approach A enforcement)
        run: |
          echo "Scanning repository for legacy SqlConnectionString secret references..."
          if grep -R "SqlConnectionString" -n infrastructure/main.bicep | grep -v "Previous secret resource removed"; then
            echo "âŒ Found unexpected SqlConnectionString secret reference. Failing."; exit 1; else echo "âœ… No legacy SqlConnectionString secret resource present."; fi
          echo "Ensuring no app setting injects ConnectionStrings__DefaultConnection via @Microsoft.KeyVault..."
          if grep -R "ConnectionStrings__DefaultConnection" infrastructure/main.bicep | grep "@Microsoft.KeyVault"; then
            echo "âŒ Found KeyVault reference for ConnectionStrings__DefaultConnection."; exit 1; else echo "âœ… No KeyVault reference for ConnectionStrings__DefaultConnection."; fi
          echo "Finished MI enforcement pre-check."

      - name: Restore dependencies
        run: dotnet restore AiStockTradeApp.sln

      - name: Build application
        run: |
          dotnet build AiStockTradeApp.sln --no-restore --configuration Release \
            /p:Version=${{ steps.gitversion.outputs.fullSemVer }} \
            /p:FileVersion=${{ steps.gitversion.outputs.assemblySemFileVer }} \
            /p:InformationalVersion=${{ steps.gitversion.outputs.fullSemVer }} \
            /p:AssemblyVersion=${{ steps.gitversion.outputs.assemblySemVer }}

      - name: Docker pre-clean (SQL)
        if: always()
        run: |
          docker rm -f sql 2>/dev/null || true
          # Safety check that no stray sql container remains
          if docker ps -a --format '{{.Names}}' | grep -Eq '^sql$'; then
            echo "A container named 'sql' still exists; failing early to avoid conflict."; exit 1; fi

      - name: Setup SQL Server for testing
        uses: potatoqualitee/mssqlsuite@v1.7
        with:
          install: sqlengine, sqlclient
          version: 2022
          sa-password: "YourStrong@Passw0rd"
          show-log: true

      - name: Wait for SQL Server to start
        run: |
          set -e
          echo "Waiting for SQL Server container to open port 1433..."
          echo "docker ps (top 5):"; docker ps --format "table {{.ID}}\t{{.Image}}\t{{.Status}}\t{{.Names}}" | head -5 || true
          READY=0
          for i in $(seq 1 60); do
            if timeout 1 bash -c ">/dev/tcp/127.0.0.1/1433" 2>/dev/null; then
              echo "Port 1433 open (attempt $i)."; READY=1; break
            fi
            echo "Waiting for SQL Server port... ($i/60)"; sleep 2
          done
          if [ "$READY" -ne 1 ]; then
            echo "Port did not open in time. Dumping SQL container logs..."
            CID=$(docker ps -a --filter "name=^/sql$" --format "{{.ID}}" | head -1)
            if [ -z "$CID" ]; then CID=$(docker ps -a --filter "ancestor=mcr.microsoft.com/mssql/server:2022-latest" --format "{{.ID}}" | head -1); fi
            [ -n "$CID" ] && echo "Container ID: $CID" && docker logs "$CID" --tail 200 || echo "No SQL container found"
            exit 1
          fi
          echo "Waiting extra 15s for SQL to finish initialization..."; sleep 15
          echo "SQL is ready."

      - name: Warm up EF Core (ensure context can connect without migrations)
        run: |
          cd AiStockTradeApp
          export ConnectionStrings__DefaultConnection="Server=127.0.0.1;Database=StockTrackerTest;User Id=sa;Password=YourStrong@Passw0rd;TrustServerCertificate=true;Encrypt=false;IP Address Preference=IPv4First"
          dotnet exec /usr/share/dotnet/sdk/$(dotnet --version)/Roslyn/builtins/../csc.dll >/dev/null 2>&1 || true
        env:
          ConnectionStrings__DefaultConnection: "Server=127.0.0.1;Database=StockTrackerTest;User Id=sa;Password=YourStrong@Passw0rd;TrustServerCertificate=true;Encrypt=false;IP Address Preference=IPv4First"
          USE_INMEMORY_DB: "true"
          ASPNETCORE_ENVIRONMENT: "Development"

      - name: Verify SQL login (sanity)
        run: |
          if command -v sqlcmd >/dev/null 2>&1; then
            echo "Probing login with sqlcmd..."
            for i in $(seq 1 10); do
              if sqlcmd -S 127.0.0.1 -U sa -P "YourStrong@Passw0rd" -Q "SELECT 1" -l 3 >/dev/null 2>&1; then
                echo "sqlcmd login OK (attempt $i)"; exit 0; fi
              echo "sqlcmd not ready yet (attempt $i)"; sleep 3
            done
            echo "sqlcmd login failed after retries"; exit 1
          else
            echo "sqlcmd not available; skipping login sanity check"
          fi

      - name: Run tests
        run: |
          set -e
          RESULTS_DIR=unit-test-results
          COVERAGE_DIR="$RESULTS_DIR/coverage"
          mkdir -p "$RESULTS_DIR" "$COVERAGE_DIR"
          echo "Running unit tests with coverage (XPlat collector)..."
          dotnet test AiStockTradeApp.sln --no-build --configuration Release --verbosity normal \
            --filter "FullyQualifiedName!~UITests" \
            --logger "trx;LogFileName=unit-test-results.trx" \
            --results-directory "$RESULTS_DIR" \
            --collect "XPlat Code Coverage"
          echo "Looking for cobertura files under $RESULTS_DIR..."
          FOUND=$(find "$RESULTS_DIR" -type f -name 'coverage.cobertura.xml' | head -1 || true)
          if [ -n "$FOUND" ]; then
            echo "Found coverage: $FOUND"
            cp "$FOUND" "$COVERAGE_DIR/" || true
          else
            echo "No cobertura file found under $RESULTS_DIR; scanning workspace..."
            FOUND=$(find . -type f -name 'coverage.cobertura.xml' | head -1 || true)
            if [ -n "$FOUND" ]; then echo "Copying $FOUND to $COVERAGE_DIR"; cp "$FOUND" "$COVERAGE_DIR/"; fi
          fi
          echo "Listing coverage dir contents:"; ls -la "$COVERAGE_DIR" || true
          echo "Listing TRX files produced:"; find . -type f -name '*.trx' -print || true
        env:
          ConnectionStrings__DefaultConnection: "Server=127.0.0.1;Database=StockTrackerTest;User Id=sa;Password=YourStrong@Passw0rd;TrustServerCertificate=true;Encrypt=false;IP Address Preference=IPv4First"
          USE_INMEMORY_DB: "true"
          ASPNETCORE_ENVIRONMENT: "Development"
          APP_VERSION: ${{ steps.gitversion.outputs.fullSemVer }}
          # Enable mock data fallback in CI/CD environment to handle API credit exhaustion
          StockData__EnableMockFallback: "true"
          StockData__MaxApiRetries: "2"
          StockData__ApiTimeoutSeconds: "10"

      - name: Collect test result files (TRX)
        if: always()
        run: |
          set -e
          echo "Aggregating TRX files into unit-test-results/collected..."
          mkdir -p unit-test-results/collected
          COUNT=0
          while IFS= read -r f; do
            base=$(basename "$f")
            ts=$(date +%s%3N)
            cp "$f" "unit-test-results/collected/${ts}-${base}" || true
            COUNT=$((COUNT+1))
          done < <(find . -type f -name '*.trx')
          echo "Copied $COUNT TRX files into unit-test-results/collected"
          echo "Final collected listing:"; ls -la unit-test-results/collected || true

      - name: Diagnostics - list unit test results directory
        if: always()
        run: |
          echo "Tree for unit-test-results:"; ls -R unit-test-results || true

      - name: Generate coverage summary (ReportGenerator)
        if: always()
        run: |
          echo "Coverage summary generation starting..."
          ls -R unit-test-results/coverage || true
          if ls unit-test-results/coverage/*.cobertura.xml 1> /dev/null 2>&1; then
            dotnet tool install --global dotnet-reportgenerator-globaltool --version 5.* || true
            export PATH="${PATH}:${HOME}/.dotnet/tools"
            reportgenerator \
              -reports:unit-test-results/coverage/*.cobertura.xml \
              -targetdir:unit-test-results/coverage-report \
              -reporttypes:HtmlSummary;TextSummary || true
            echo "Coverage summary:"; cat unit-test-results/coverage-report/Summary.txt || true
          else
            echo "No cobertura coverage files found; skipping report generation.";
          fi

      - name: Upload coverage artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: unit-test-coverage
          path: |
            unit-test-results/**/coverage.cobertura.xml
            unit-test-results/coverage/**
            unit-test-results/coverage-report/**
          retention-days: 5

      - name: Upload unit test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: unit-test-results
          path: |
            unit-test-results/**/*.trx
            unit-test-results/**/coverage.cobertura.xml
          retention-days: 5

      - name: Docker post-clean (SQL)
        if: always()
        run: |
          docker rm -f sql 2>/dev/null || true

      - name: Job Summary (Unit Tests)
        if: always()
        run: |
          {
            echo "## âœ… Unit Test Job Summary";
            echo "**Overall Job Status:** ${{ job.status }}";
            echo "**Commit:** $GITHUB_SHA";
            echo "**Ref:** $GITHUB_REF";
            TOTAL_TRX=$(find unit-test-results -type f -name '*.trx' 2>/dev/null | wc -l | tr -d ' ' || echo 0);
            echo "**TRX Files:** ${TOTAL_TRX}";
            if [ -f unit-test-results/coverage-report/Summary.txt ]; then
              LINE_COV=$(grep -E 'Line coverage' unit-test-results/coverage-report/Summary.txt | head -1 | sed 's/^ *//');
              BRANCH_COV=$(grep -E 'Branch coverage' unit-test-results/coverage-report/Summary.txt | head -1 | sed 's/^ *//');
              echo "**Coverage:** ${LINE_COV:-Line N/A}; ${BRANCH_COV:-Branch N/A}";
            else
              echo "**Coverage:** (summary file not generated)";
            fi
            echo "\n### Key Indicators";
            if grep -R "SqlConnectionString" infrastructure/main.bicep | grep -v "Previous secret resource removed" >/dev/null 2>&1; then
              echo "- âŒ Legacy KeyVault SQL secret reference detected"; else echo "- âœ… No legacy SQL secret reference"; fi
            echo "- Test artifacts uploaded as: unit-test-results, unit-test-coverage";
          } >> "$GITHUB_STEP_SUMMARY"

  ui-test:
    runs-on: [self-hosted, linux, x64]
    needs: test
    name: UI Tests with Playwright
    if: ${{ github.event_name != 'workflow_run' || github.event.workflow_run.conclusion == 'success' }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Full history for deterministic versioning & reproducible builds
          fetch-tags: true # Include tags for GitVersion

      - name: Install GitVersion
        uses: gittools/actions/gitversion/setup@v0
        with:
          versionSpec: "5.x"

      - name: Determine Version
        id: gitversion
        uses: gittools/actions/gitversion/execute@v0

      - name: Show GitVersion in build job
        run: |
          echo "FullSemVer=${{ steps.gitversion.outputs.fullSemVer }}"
          echo "InformationalVersion=${{ steps.gitversion.outputs.informationalVersion }}"

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Restore dependencies
        run: dotnet restore AiStockTradeApp.sln

      - name: Build application
        run: dotnet build AiStockTradeApp.sln --no-restore --configuration Release

      - name: Docker pre-clean (SQL)
        if: always()
        run: |
          docker rm -f sql 2>/dev/null || true
          # Safety check that no stray sql container remains
          if docker ps -a --format '{{.Names}}' | grep -Eq '^sql$'; then
            echo "A container named 'sql' still exists; failing early to avoid conflict."; exit 1; fi

      - name: Setup SQL Server for UI testing
        uses: potatoqualitee/mssqlsuite@v1.7
        with:
          install: sqlengine, sqlclient
          version: 2022
          sa-password: "YourStrong@Passw0rd"
          show-log: true

      - name: Wait for SQL Server to start
        run: sleep 30

      - name: Warm up EF Core (UI test DB no migrations)
        run: |
          cd AiStockTradeApp
          export ConnectionStrings__DefaultConnection="Server=localhost;Database=StockTrackerTestUI;User Id=sa;Password=YourStrong@Passw0rd;TrustServerCertificate=true;Encrypt=false"
          dotnet --info > /dev/null
        env:
          ConnectionStrings__DefaultConnection: "Server=localhost;Database=StockTrackerTestUI;User Id=sa;Password=YourStrong@Passw0rd;TrustServerCertificate=true;Encrypt=false"

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install Playwright browsers (via .NET script)
        run: |
          set -e
          echo "Building UITests to generate Playwright install scripts..."
          dotnet build AiStockTradeApp.UITests/AiStockTradeApp.UITests.csproj --configuration Release --no-restore

          echo "Installing Playwright browsers with OS deps using .NET script..."
          PLAYWRIGHT_DIR="AiStockTradeApp.UITests/bin/Release/net9.0"
          SH_SCRIPT="$PLAYWRIGHT_DIR/playwright.sh"
          PS_SCRIPT="$PLAYWRIGHT_DIR/playwright.ps1"
          echo "Node version: $(node --version 2>/dev/null || echo 'not found')"
          echo "npm version:  $(npm --version 2>/dev/null || echo 'not found')"
          echo "Determining Microsoft.Playwright package version from csproj..."
          PW_VER=$(grep -oP '(?<=<PackageReference Include="Microsoft.Playwright" Version=")[^"]+' AiStockTradeApp.UITests/AiStockTradeApp.UITests.csproj || true)
          echo "Microsoft.Playwright package version: ${PW_VER:-unknown}"
          echo "Playwright CLI version BEFORE install (generic):"; npx -y playwright --version 2>/dev/null || echo "npx playwright not available"
          if [ -n "$PW_VER" ]; then echo "Playwright CLI version BEFORE install (pinned ${PW_VER}):"; npx -y "playwright@${PW_VER}" --version 2>/dev/null || echo "npx playwright@${PW_VER} not available"; fi
          if [ -f "$SH_SCRIPT" ]; then
            echo "Using bash playwright.sh script"
            bash "$SH_SCRIPT" install --with-deps
          elif [ -f "$PS_SCRIPT" ]; then
            echo "Using PowerShell playwright.ps1 script"
            if command -v pwsh >/dev/null 2>&1; then
              pwsh -NoLogo -NoProfile -File "$PS_SCRIPT" install --with-deps
            else
              echo "pwsh not found; falling back to pinned npx playwright install"
              if [ -n "$PW_VER" ]; then npx -y "playwright@${PW_VER}" install --with-deps; else npx -y playwright install --with-deps; fi
            fi
          else
            echo "No playwright install script found in $PLAYWRIGHT_DIR; falling back to pinned npx playwright install" >&2
            if [ -n "$PW_VER" ]; then npx -y "playwright@${PW_VER}" install --with-deps; else npx -y playwright install --with-deps; fi
          fi
          echo "Playwright CLI version AFTER install (generic):"; npx -y playwright --version 2>/dev/null || echo "npx playwright not available"
          if [ -n "$PW_VER" ]; then echo "Playwright CLI version AFTER install (pinned ${PW_VER}):"; npx -y "playwright@${PW_VER}" --version 2>/dev/null || echo "npx playwright@${PW_VER} not available"; fi
          echo "Installed browsers (head):"
          ls -R ~/.cache/ms-playwright | head -100 || true

      - name: Start application in background
        run: |
          cd AiStockTradeApp
          dotnet run --no-build --configuration Release --no-launch-profile &
          APP_PID=$!
          echo "APP_PID=${APP_PID}" >> $GITHUB_ENV
          echo "Started application with PID: ${APP_PID}"
        env:
          ASPNETCORE_ENVIRONMENT: "Development"
          ASPNETCORE_URLS: "http://localhost:5000"
          ConnectionStrings__DefaultConnection: "Server=localhost;Database=StockTrackerTestUI;User Id=sa;Password=YourStrong@Passw0rd;TrustServerCertificate=true;Encrypt=false"
          USE_INMEMORY_DB: "true" # Use EF in-memory provider for faster UI tests (auto-start logic also supports this)
          # Ensure UI uses the same API URL that TestSetupHelper will auto-start
          PLAYWRIGHT_API_BASE_URL: "http://localhost:5256"
          StockApi__BaseUrl: "http://localhost:5256"
          StockApi__HttpBaseUrl: "http://localhost:5256"
          # Enable mock data fallback for UI tests to handle API credit exhaustion
          StockData__EnableMockFallback: "true"
          StockData__MaxApiRetries: "2"
          StockData__ApiTimeoutSeconds: "10"

      - name: Wait for application to be ready
        run: |
          echo "Waiting for application to start..."
          timeout=60
          while [ $timeout -gt 0 ]; do
            if curl -f http://localhost:5000 >/dev/null 2>&1; then
              echo "Application is ready!"
              break
            fi
            echo "Waiting for application... ($timeout seconds remaining)"
            sleep 2
            timeout=$((timeout-2))
          done

          if [ $timeout -le 0 ]; then
            echo "Application failed to start within timeout"
            exit 1
          fi

      - name: List UI Tests to be executed
        run: dotnet test AiStockTradeApp.UITests --list-tests --verbosity normal --filter "FullyQualifiedName~UITests"

      - name: Run Playwright UI Tests
        run: |
          echo "Starting UI test execution..."
          dotnet test AiStockTradeApp.UITests --no-build --configuration Release --verbosity normal --filter "FullyQualifiedName~UITests" --logger "trx;LogFileName=ui-test-results.trx" --settings ./test.runsettings
          echo "UI test execution completed with exit code: $?"
        timeout-minutes: 25
        env:
          PLAYWRIGHT_BASE_URL: "http://localhost:5000"
          PLAYWRIGHT_API_BASE_URL: "http://localhost:5256"
          ASPNETCORE_ENVIRONMENT: "Development"
          ConnectionStrings__DefaultConnection: "Server=localhost;Database=StockTrackerTestUI;User Id=sa;Password=YourStrong@Passw0rd;TrustServerCertificate=true;Encrypt=false"
          USE_INMEMORY_DB: "true" # In-memory DB accelerates UI tests and avoids local SQL dependency

      - name: Collect UI Inconclusive Screenshots & Traces
        if: always()
        run: |
          set -e
          ARTIFACT_ROOT="ui-test-artifacts"
          echo "Collecting UI test artifacts into ${ARTIFACT_ROOT}..."
          mkdir -p "${ARTIFACT_ROOT}/screenshots" "${ARTIFACT_ROOT}/traces" "${ARTIFACT_ROOT}/raw-workdirs"

          echo "Searching for inconclusive screenshots..."
          FOUND_SHOTS=$(find . -type f -name 'inconclusive-*.png' | wc -l || echo 0)
          if [ "$FOUND_SHOTS" -gt 0 ]; then
            find . -type f -name 'inconclusive-*.png' -exec cp {} "${ARTIFACT_ROOT}/screenshots/" \;
          else
            echo "No inconclusive screenshots found."
          fi

          echo "Searching for generic Playwright screenshots..."
          find . -type f -name 'screenshot-*.png' -exec cp {} "${ARTIFACT_ROOT}/screenshots/" \; 2>/dev/null || true

          echo "Searching for Playwright trace zips..."
          # Common naming: trace.zip or *_trace.zip; copy & rename uniquely
            i=0
            while IFS= read -r trace; do
              base=$(basename "$trace")
              cp "$trace" "${ARTIFACT_ROOT}/traces/${i}-${base}" || true
              i=$((i+1))
            done < <(find . -type f -name 'trace.zip' -o -name '*_trace.zip' 2>/dev/null || true)

          echo "Capturing minimal directory listings for diagnostics..."
          (find AiStockTradeApp.UITests/bin -maxdepth 4 -type d -name 'net9.0' -print 2>/dev/null | head -10 | while read d; do
             echo "Listing for $d"; ls -la "$d" | head -50; echo "----"; done) > "${ARTIFACT_ROOT}/raw-workdirs/directory-listings.txt" 2>/dev/null || true

          echo "Artifact root contents:"; ls -R "${ARTIFACT_ROOT}" || true
          echo "Summary:"
          echo "  Inconclusive screenshots: $(ls ${ARTIFACT_ROOT}/screenshots 2>/dev/null | wc -l || echo 0)"
          echo "  Trace files: $(ls ${ARTIFACT_ROOT}/traces 2>/dev/null | wc -l || echo 0)"
          echo "Collection complete."

      - name: Upload UI Test Artifacts (Screenshots & Traces)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: ui-test-artifacts
          path: ui-test-artifacts
          retention-days: 7

      - name: Upload UI Test Results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: ui-test-results
          path: "**/ui-test-results.trx"
          retention-days: 5

      - name: Check application logs on failure
        if: failure()
        run: |
          echo "=== APPLICATION LOGS (last 100 lines) ==="
          # Check if the application is still running
          if pgrep -f "dotnet.*AiStockTradeApp" > /dev/null; then
            echo "Application is still running"
            ps aux | grep dotnet
          else
            echo "Application is not running"
          fi

          echo "=== RECENT SYSTEM LOGS ==="
          journalctl --since "10 minutes ago" | tail -50 || echo "No journalctl available"

      - name: Stop application
        if: always()
        run: |
          if [ ! -z "$APP_PID" ]; then
            echo "Stopping application with PID: $APP_PID"
            kill $APP_PID || true
            sleep 5
          fi
          # Cleanup any remaining dotnet processes
          pkill -f "dotnet.*AiStockTradeApp" || true

      - name: Docker post-clean (SQL)
        if: always()
        run: |
          docker rm -f sql 2>/dev/null || true

      - name: Job Summary (UI Tests)
        if: always()
        run: |
          {
            echo "## ðŸŽ­ UI Test Job Summary";
            echo "**Overall Job Status:** ${{ job.status }}";
            echo "**Commit:** $GITHUB_SHA";
            echo "**Ref:** $GITHUB_REF";
            UI_TRX_COUNT=$(find . -type f -name 'ui-test-results.trx' 2>/dev/null | wc -l | tr -d ' ' || echo 0);
            SHOT_COUNT=$(find ui-test-artifacts/screenshots -type f -name '*.png' 2>/dev/null | wc -l | tr -d ' ' || echo 0);
            TRACE_COUNT=$(find ui-test-artifacts/traces -type f -name '*.zip' 2>/dev/null | wc -l | tr -d ' ' || echo 0);
            echo "**TRX Files:** ${UI_TRX_COUNT}";
            echo "**Screenshots:** ${SHOT_COUNT}";
            echo "**Traces:** ${TRACE_COUNT}";
            echo "\n### Notes";
            if [ "$SHOT_COUNT" -gt 0 ]; then echo "- Inconclusive or diagnostic screenshots captured."; else echo "- No screenshots captured."; fi
            if [ "$TRACE_COUNT" -gt 0 ]; then echo "- Playwright traces available."; else echo "- No Playwright traces."; fi
            echo "- Artifacts uploaded as: ui-test-artifacts, ui-test-results";
          } >> "$GITHUB_STEP_SUMMARY"

  build:
    runs-on: [self-hosted, linux, x64]
    needs: [test, ui-test]
    name: Build and Push Container
    if: ${{ github.event_name != 'workflow_run' || github.event.workflow_run.conclusion == 'success' }}
    outputs:
      image: ${{ steps.final-output.outputs.image }}
      api_image: ${{ steps.final-output-api.outputs.image }}
      mcp_image: ${{ steps.final-output-mcp.outputs.image }}
      test_output: ${{ steps.final-output.outputs.test_output }}

    permissions:
      id-token: write
      contents: write # needed to push git tag

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Install GitVersion
        uses: gittools/actions/gitversion/setup@v0
        with:
          versionSpec: "5.x"

      - name: Determine Version
        id: gitversion
        uses: gittools/actions/gitversion/execute@v0

      - name: Display computed version (build job)
        run: |
          echo "FullSemVer=${{ steps.gitversion.outputs.fullSemVer }}"
          echo "AssemblySemVer=${{ steps.gitversion.outputs.assemblySemVer }}"
          echo "InformationalVersion=${{ steps.gitversion.outputs.informationalVersion }}"

      - name: Validate semantic version (no placeholder)
        run: |
          if [ -z "${{ steps.gitversion.outputs.fullSemVer }}" ] || [ "${{ steps.gitversion.outputs.fullSemVer }}" = "0.0.0-local" ]; then
            echo "Invalid or placeholder semantic version detected; failing build to prevent ambiguous artifacts.";
            exit 1;
          fi

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Azure Login for Registry Access
        uses: azure/login@v2
        with:
          client-id: ${{ env.AZURE_CLIENT_ID }}
          tenant-id: ${{ env.AZURE_TENANT_ID }}
          subscription-id: ${{ env.AZURE_SUBSCRIPTION_ID }}

      - name: Get Container Registry Information
        id: registry
        run: |
          # Always use dev environment container registry (shared across all environments)
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            INSTANCE_NUM="${{ github.event.inputs.instanceNumber }}"
            echo "Workflow dispatch detected - Instance: ${INSTANCE_NUM}"
          else
            INSTANCE_NUM="002"
            echo "Branch push detected - Using default instance: ${INSTANCE_NUM}"
          fi

          # Always target dev resource group for container registry
          ENV="dev"
          RG_NAME="rg-aistock-${ENV}-${INSTANCE_NUM}"

          echo "=== BUILD ENVIRONMENT INFO ==="
          echo "Container Registry Environment: ${ENV} (shared registry)"
          echo "Instance Number: ${INSTANCE_NUM}"
          echo "Registry Resource Group: ${RG_NAME}"
          echo "GitHub Ref: ${{ github.ref }}"
          echo "Event Name: ${{ github.event_name }}"

          # Get container registry name from dev resource group
          REGISTRY_NAME=$(az acr list --resource-group "${RG_NAME}" --query '[0].name' --output tsv)

          if [ -z "${REGISTRY_NAME}" ] || [ "${REGISTRY_NAME}" == "null" ]; then
            echo "ERROR: No container registry found in resource group ${RG_NAME}"
            echo "Available resource groups:"
            az group list --query '[].name' --output table
            echo "This might mean the dev infrastructure hasn't been deployed yet for instance ${INSTANCE_NUM}"
            echo "Please deploy dev environment first to create the shared container registry."
            exit 1
          fi

          echo "Found shared registry: ${REGISTRY_NAME}"
          echo "registry_name=${REGISTRY_NAME}" >> $GITHUB_OUTPUT
          echo "resource_group=${RG_NAME}" >> $GITHUB_OUTPUT
          echo "environment=${ENV}" >> $GITHUB_OUTPUT
          echo "instance_number=${INSTANCE_NUM}" >> $GITHUB_OUTPUT

      - name: Get Container Registry Credentials
        id: registry-creds
        run: |
          REGISTRY_NAME="${{ steps.registry.outputs.registry_name }}"
          RG_NAME="${{ steps.registry.outputs.resource_group }}"

          # Get admin credentials
          REGISTRY_USERNAME=$(az acr credential show --name "${REGISTRY_NAME}" --query 'username' --output tsv)
          REGISTRY_PASSWORD=$(az acr credential show --name "${REGISTRY_NAME}" --query 'passwords[0].value' --output tsv)

          echo "Registry Username: ${REGISTRY_USERNAME}"
          echo "Password length: ${#REGISTRY_PASSWORD}"

          echo "registry_username=${REGISTRY_USERNAME}" >> $GITHUB_OUTPUT
          echo "registry_password=${REGISTRY_PASSWORD}" >> $GITHUB_OUTPUT

      - name: Debug Registry Information
        run: |
          echo "=== REGISTRY DEBUG INFO ==="
          echo "Target Environment: ${{ steps.registry.outputs.environment }}"
          echo "Instance Number: ${{ steps.registry.outputs.instance_number }}"
          echo "Registry name: ${{ steps.registry.outputs.registry_name }}"
          echo "Resource group: ${{ steps.registry.outputs.resource_group }}"
          echo "Registry URL: ${{ steps.registry.outputs.registry_name }}.azurecr.io"
          echo "Username: ${{ steps.registry-creds.outputs.registry_username }}"
          echo "Password available: ${{ steps.registry-creds.outputs.registry_password != '' }}"
          echo "=== TRIGGER INFO ==="
          echo "GitHub Ref: ${{ github.ref }}"
          echo "Event Name: ${{ github.event_name }}"
          echo "Workflow Dispatch Environment: ${{ github.event.inputs.environment || 'N/A' }}"
          echo "Workflow Dispatch Instance: ${{ github.event.inputs.instanceNumber || 'N/A' }}"

      - name: Log in to Azure Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ steps.registry.outputs.registry_name }}.azurecr.io
          username: ${{ steps.registry-creds.outputs.registry_username }}
          password: ${{ steps.registry-creds.outputs.registry_password }}

      - name: Verify Docker login
        run: |
          echo "Docker login successful"
          echo "Registry: ${{ steps.registry.outputs.registry_name }}.azurecr.io"

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ steps.registry.outputs.registry_name }}.azurecr.io/aistocktradeapp
          tags: |
            type=raw,value=${{ steps.gitversion.outputs.fullSemVer }}
            type=raw,value=v${{ steps.gitversion.outputs.fullSemVer }}
            type=sha,prefix=sha-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Extract metadata (API)
        id: meta-api
        uses: docker/metadata-action@v5
        with:
          images: ${{ steps.registry.outputs.registry_name }}.azurecr.io/aistocktradeapp-api
          tags: |
            type=raw,value=${{ steps.gitversion.outputs.fullSemVer }}
            type=raw,value=v${{ steps.gitversion.outputs.fullSemVer }}
            type=sha,prefix=sha-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Extract metadata (MCP Server)
        id: meta-mcp
        uses: docker/metadata-action@v5
        with:
          images: ${{ steps.registry.outputs.registry_name }}.azurecr.io/aistocktradeapp-mcp
          tags: |
            type=raw,value=${{ steps.gitversion.outputs.fullSemVer }}
            type=raw,value=v${{ steps.gitversion.outputs.fullSemVer }}
            type=sha,prefix=sha-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Debug metadata outputs
        run: |
          echo "=== METADATA STEP DEBUG ==="
          echo "Meta step ID: meta"
          echo "Meta outputs (JSON): ${{ toJson(steps.meta.outputs) }}"
          echo "Meta tags raw:"
          echo '${{ steps.meta.outputs.tags }}'
          echo "Meta version: '${{ steps.meta.outputs.version }}'"
          echo "=== END METADATA DEBUG ==="

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./AiStockTradeApp/Dockerfile
          push: true
          build-args: |
            APP_VERSION=${{ steps.gitversion.outputs.fullSemVer }}
          tags: ${{ steps.meta.outputs.tags }}
          labels: |
            org.opencontainers.image.version=${{ steps.gitversion.outputs.fullSemVer }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.ref.name=v${{ steps.gitversion.outputs.fullSemVer }}
            org.opencontainers.image.source=${{ github.repository }}
            org.opencontainers.image.version.prefixed=v${{ steps.gitversion.outputs.fullSemVer }}

      - name: Build and push Docker image (API)
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./AiStockTradeApp.Api/Dockerfile
          push: true
          build-args: |
            APP_VERSION=${{ steps.gitversion.outputs.fullSemVer }}
          tags: ${{ steps.meta-api.outputs.tags }}
          labels: |
            org.opencontainers.image.version=${{ steps.gitversion.outputs.fullSemVer }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.ref.name=v${{ steps.gitversion.outputs.fullSemVer }}
            org.opencontainers.image.source=${{ github.repository }}
            org.opencontainers.image.version.prefixed=v${{ steps.gitversion.outputs.fullSemVer }}

      - name: Build and push Docker image (MCP Server)
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./AiStockTradeApp.McpServer/Dockerfile
          push: true
          build-args: |
            APP_VERSION=${{ steps.gitversion.outputs.fullSemVer }}
          tags: ${{ steps.meta-mcp.outputs.tags }}
          labels: |
            org.opencontainers.image.version=${{ steps.gitversion.outputs.fullSemVer }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.ref.name=v${{ steps.gitversion.outputs.fullSemVer }}
            org.opencontainers.image.source=${{ github.repository }}
            org.opencontainers.image.version.prefixed=v${{ steps.gitversion.outputs.fullSemVer }}

      - name: Rebuild UI image locally for Trivy scanning
        run: |
          set -euo pipefail
          mkdir -p build-outputs
          # Meta tags may be comma- or newline-separated; pick the first non-empty token and trim whitespace
          UI_TAG_RAW='${{ steps.meta.outputs.tags }}'
          UI_TAG=$(printf "%s" "$UI_TAG_RAW" | tr ',' '\n' | sed '/^[[:space:]]*$/d' | head -n1 | xargs)
          echo "Resolved local UI tag: ${UI_TAG}"
          # Build a local copy of the UI image (so Trivy can scan without pulling from remote)
          docker build --pull -f ./AiStockTradeApp/Dockerfile -t "${UI_TAG}" --build-arg APP_VERSION=${{ steps.gitversion.outputs.fullSemVer }} .
          # Run Trivy via its container image and write SARIF into build-outputs/
          docker run --rm -v /var/run/docker.sock:/var/run/docker.sock -v "${{ github.workspace }}/build-outputs":/outputs aquasec/trivy:latest image --format sarif --output /outputs/trivy-ui.sarif "${UI_TAG}" || true

      - name: Rebuild API image locally for Trivy scanning
        run: |
          set -euo pipefail
          API_TAG_RAW='${{ steps.meta-api.outputs.tags }}'
          API_TAG=$(printf "%s" "$API_TAG_RAW" | tr ',' '\n' | sed '/^[[:space:]]*$/d' | head -n1 | xargs)
          echo "Resolved local API tag: ${API_TAG}"
          docker build --pull -f ./AiStockTradeApp.Api/Dockerfile -t "${API_TAG}" --build-arg APP_VERSION=${{ steps.gitversion.outputs.fullSemVer }} .
          docker run --rm -v /var/run/docker.sock:/var/run/docker.sock -v "${{ github.workspace }}/build-outputs":/outputs aquasec/trivy:latest image --format sarif --output /outputs/trivy-api.sarif "${API_TAG}" || true

      - name: Rebuild MCP image locally for Trivy scanning
        run: |
          set -euo pipefail
          MCP_TAG_RAW='${{ steps.meta-mcp.outputs.tags }}'
          MCP_TAG=$(printf "%s" "$MCP_TAG_RAW" | tr ',' '\n' | sed '/^[[:space:]]*$/d' | head -n1 | xargs)
          echo "Resolved local MCP tag: ${MCP_TAG}"
          docker build --pull -f ./AiStockTradeApp.McpServer/Dockerfile -t "${MCP_TAG}" --build-arg APP_VERSION=${{ steps.gitversion.outputs.fullSemVer }} .
          docker run --rm -v /var/run/docker.sock:/var/run/docker.sock -v "${{ github.workspace }}/build-outputs":/outputs aquasec/trivy:latest image --format sarif --output /outputs/trivy-mcp.sarif "${MCP_TAG}" || true

      - name: Upload Trivy SARIF artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: trivy-sarif
          path: |
            build-outputs/*.sarif
          retention-days: 7

      - name: Create and push semantic git tag
        if: ${{ github.ref == 'refs/heads/main' }}
        run: |
          set -e
          VERSION='${{ steps.gitversion.outputs.fullSemVer }}'
          if [ -z "$VERSION" ] || [ "$VERSION" = "0.0.0-local" ]; then
            echo "No valid semantic version computed; skipping tag push."; exit 0; fi
          if [[ "$VERSION" != v* ]]; then VERSION="v$VERSION"; fi

          # Skip creating tag if the commit range modified workflow files, to avoid
          # GitHub App 'workflows' permission enforcement when tagging such commits.
          CHANGED_WORKFLOWS=0
          if [ -n "${{ github.event.before }}" ] && [ "${{ github.event.before }}" != "0000000000000000000000000000000000000000" ]; then
            echo "Checking changes between before=${{ github.event.before }} and sha=${{ github.sha }} for workflow file modifications..."
            if git diff --name-only "${{ github.event.before }}" "${{ github.sha }}" | grep -E '^\.github/workflows/' >/dev/null 2>&1; then
              CHANGED_WORKFLOWS=1
            fi
          else
            echo "No 'before' SHA available; checking this commit only for workflow file modifications..."
            if git diff-tree --no-commit-id --name-only -r "${{ github.sha }}" | grep -E '^\.github/workflows/' >/dev/null 2>&1; then
              CHANGED_WORKFLOWS=1
            fi
          fi

          if [ "$CHANGED_WORKFLOWS" -eq 1 ]; then
            echo "Detected changes to .github/workflows/* in this run's commit(s); skipping tag creation to avoid workflows permission error.";
            exit 0;
          fi

          git fetch --tags --depth=1 || true
            if git rev-parse -q --verify "refs/tags/$VERSION" >/dev/null; then
            echo "Tag $VERSION already exists; skipping creation."; exit 0; fi
          echo "Creating annotated tag $VERSION"
          git tag -a "$VERSION" -m "Release $VERSION (CI)"
          git push origin "$VERSION"
          echo "Tag $VERSION pushed successfully."
        env:
          GIT_AUTHOR_NAME: ci-bot
          GIT_AUTHOR_EMAIL: ci-bot@users.noreply.github.com
          GIT_COMMITTER_NAME: ci-bot
          GIT_COMMITTER_EMAIL: ci-bot@users.noreply.github.com

      - name: Extract and set container image for deployment
        id: final-output
        run: |
          set -e  # Exit on any error
          echo "=== COMBINED EXTRACT AND OUTPUT STEP ==="

          # Get tags from metadata step using heredoc to preserve newlines
          echo "Attempting to read metadata tags..."
          TAGS=$(cat << 'EOFTAGS'
          ${{ steps.meta.outputs.tags }}
          EOFTAGS
          )

          echo "Raw TAGS captured:"
          echo "---START TAGS---"
          echo "${TAGS}"
          echo "---END TAGS---"
          echo "Number of tags: $(echo "${TAGS}" | wc -l)"

          # Check if TAGS is empty or contains only whitespace
          if [ -z "$(echo "${TAGS}" | tr -d ' \t\n\r')" ]; then
            echo "ERROR: No tags received from metadata step or only whitespace!"
            echo "Meta step outputs: ${{ toJson(steps.meta.outputs) }}"
            exit 1
          fi

          # Prefer semantic version tag, then sha, else first tag
          SEMVER_TAG=$(echo "${TAGS}" | grep -E ":[0-9]+\.[0-9]+\.[0-9]+(-[A-Za-z0-9\.]+)?$" | head -1 | tr -d '\n\r' | xargs || true)
          SHA_TAG=$(echo "${TAGS}" | grep -E "sha-[a-f0-9]+" | head -1 | tr -d '\n\r' | xargs || true)
          if [ -n "$SEMVER_TAG" ]; then
            DEPLOY_IMAGE="$SEMVER_TAG"; echo "Using semantic version tag: $SEMVER_TAG";
          elif [ -n "$SHA_TAG" ]; then
            DEPLOY_IMAGE="$SHA_TAG"; echo "Using SHA tag: $SHA_TAG";
          else
            DEPLOY_IMAGE=$(echo "${TAGS}" | head -1 | tr -d '\n\r' | xargs); echo "Fallback deploy image: $DEPLOY_IMAGE";
          fi

          echo "=== SETTING OUTPUTS AND ARTIFACTS ==="
          echo "Final deployment image: '${DEPLOY_IMAGE}'"
          echo "DEPLOY_IMAGE length: ${#DEPLOY_IMAGE}"

          # Check if DEPLOY_IMAGE is empty
          if [ -z "${DEPLOY_IMAGE}" ]; then
            echo "ERROR: DEPLOY_IMAGE is empty after processing!"
            echo "This means the tag processing failed"
            exit 1
          fi

          # Write to artifact file for reliable transfer
          echo "=== CREATING ARTIFACT ==="
          mkdir -p build-outputs
          echo "${DEPLOY_IMAGE}" > build-outputs/container-image.txt
          echo "hello-from-combined-step" > build-outputs/test-output.txt

          echo "Artifact files created:"
          ls -la build-outputs/
          echo "Container image file contents:"
          cat build-outputs/container-image.txt
          echo "Test output file contents:"
          cat build-outputs/test-output.txt

          # Also try traditional GitHub outputs as backup
          echo "=== BACKUP GITHUB OUTPUT ==="
          echo "image=${DEPLOY_IMAGE}" >> "$GITHUB_OUTPUT"
          echo "test_output=hello-from-combined-step" >> "$GITHUB_OUTPUT"

          echo "GITHUB_OUTPUT contents:"
          cat "$GITHUB_OUTPUT"

          echo "=== END COMBINED STEP ==="

      - name: Extract and set API container image for deployment
        id: final-output-api
        run: |
          set -e
          echo "=== API IMAGE OUTPUT STEP ==="

          TAGS=$(cat << 'EOFTAGS'
          ${{ steps.meta-api.outputs.tags }}
          EOFTAGS
          )

          echo "API TAGS captured:"; echo "$TAGS"
          if [ -z "$(echo "$TAGS" | tr -d ' \t\n\r')" ]; then
            echo "ERROR: No API tags received from metadata step"; exit 1; fi

          SEMVER_TAG=$(echo "$TAGS" | grep -E ":[0-9]+\.[0-9]+\.[0-9]+(-[A-Za-z0-9\.]+)?$" | head -1 | tr -d '\n\r' | xargs || true)
          SHA_TAG=$(echo "$TAGS" | grep -E "sha-[a-f0-9]+" | head -1 | tr -d '\n\r' | xargs || true)
          if [ -n "$SEMVER_TAG" ]; then
            DEPLOY_IMAGE="$SEMVER_TAG"; echo "Using API semantic version tag: $SEMVER_TAG";
          elif [ -n "$SHA_TAG" ]; then
            DEPLOY_IMAGE="$SHA_TAG"; echo "Using API SHA tag: $SHA_TAG";
          else
            DEPLOY_IMAGE=$(echo "$TAGS" | head -1 | tr -d '\n\r' | xargs); echo "Fallback API deploy image: $DEPLOY_IMAGE";
          fi

          mkdir -p build-outputs
          echo "$DEPLOY_IMAGE" > build-outputs/container-image-api.txt
          echo "image=$DEPLOY_IMAGE" >> "$GITHUB_OUTPUT"
          echo "=== END API IMAGE OUTPUT STEP ==="

      - name: Extract and set MCP container image for deployment
        id: final-output-mcp
        run: |
          set -e
          echo "=== MCP IMAGE OUTPUT STEP ==="

          TAGS=$(cat << 'EOFTAGS'
          ${{ steps.meta-mcp.outputs.tags }}
          EOFTAGS
          )

          echo "MCP TAGS captured:"; echo "$TAGS"
          if [ -z "$(echo "$TAGS" | tr -d ' \t\n\r')" ]; then
            echo "ERROR: No MCP tags received from metadata step"; exit 1; fi

          SEMVER_TAG=$(echo "$TAGS" | grep -E ":[0-9]+\.[0-9]+\.[0-9]+(-[A-Za-z0-9\.]+)?$" | head -1 | tr -d '\n\r' | xargs || true)
          SHA_TAG=$(echo "$TAGS" | grep -E "sha-[a-f0-9]+" | head -1 | tr -d '\n\r' | xargs || true)
          if [ -n "$SEMVER_TAG" ]; then
            DEPLOY_IMAGE="$SEMVER_TAG"; echo "Using MCP semantic version tag: $SEMVER_TAG";
          elif [ -n "$SHA_TAG" ]; then
            DEPLOY_IMAGE="$SHA_TAG"; echo "Using MCP SHA tag: $SHA_TAG";
          else
            DEPLOY_IMAGE=$(echo "$TAGS" | head -1 | tr -d '\n\r' | xargs); echo "Fallback MCP deploy image: $DEPLOY_IMAGE";
          fi

          mkdir -p build-outputs
          echo "$DEPLOY_IMAGE" > build-outputs/container-image-mcp.txt
          echo "image=$DEPLOY_IMAGE" >> "$GITHUB_OUTPUT"
          echo "=== END MCP IMAGE OUTPUT STEP ==="

      - name: Upload build outputs as artifact
        uses: actions/upload-artifact@v4
        with:
          name: build-outputs
          path: build-outputs/
          retention-days: 1

      - name: Test final output
        run: |
          echo "=== FINAL OUTPUT TEST ==="
          echo "Can we read the final output immediately?"
          echo "Final step - Image: ${{ steps.final-output.outputs.image }}"
          echo "Final step - Test: ${{ steps.final-output.outputs.test_output }}"

      - name: Final verification
        run: |
          echo "=== FINAL VERIFICATION ==="
          echo "Final step outputs:"
          echo "  Image: ${{ steps.final-output.outputs.image }}"
          echo "  Test: ${{ steps.final-output.outputs.test_output }}"
          echo "=== JOB OUTPUTS WILL BE ==="
          echo "image: ${{ steps.final-output.outputs.image }}"
          echo "test_output: ${{ steps.final-output.outputs.test_output }}"

      - name: Job Summary (Build)
        if: always()
        run: |
          {
            echo "## ðŸ—ï¸ Build Job Summary";
            echo "**Overall Job Status:** ${{ job.status }}";
            echo "**Version:** ${{ steps.gitversion.outputs.fullSemVer }}";
            echo "**Primary Image:** ${{ steps.final-output.outputs.image }}";
            echo "**API Image:** ${{ steps.final-output-api.outputs.image }}";
            echo "**MCP Image:** ${{ steps.final-output-mcp.outputs.image }}";
            echo "\n### Security Scan Artifacts";
            echo "- Trivy SARIF uploaded (ui/api/mcp if present)";
          } >> "$GITHUB_STEP_SUMMARY"

  deploy-dev:
    runs-on: [self-hosted, linux, x64]
    needs: build
    name: Deploy to Development
    # Run for main branch pushes and manual deployment requests
    if: ${{ github.ref == 'refs/heads/main' || (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'dev') }}
    environment: ${{ github.event_name == 'workflow_dispatch' && format('development-{0}', github.event.inputs.instanceNumber) || 'development-002' }}
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download build outputs
        uses: actions/download-artifact@v4
        with:
          name: build-outputs
          path: build-outputs/

      - name: Load container image from artifact
        id: load-image
        run: |
          echo "=== LOADING CONTAINER IMAGE FROM ARTIFACT ==="
          if [ -f "build-outputs/container-image.txt" ]; then
            CONTAINER_IMAGE=$(cat build-outputs/container-image.txt)
            echo "Container image from artifact: '${CONTAINER_IMAGE}'"
            echo "container_image=${CONTAINER_IMAGE}" >> "$GITHUB_OUTPUT"
          else
            echo "ERROR: container-image.txt not found in artifacts!"
            exit 1
          fi

      - name: Load API container image from artifact
        id: load-image-api
        run: |
          echo "=== LOADING API CONTAINER IMAGE FROM ARTIFACT ==="
          if [ -f "build-outputs/container-image-api.txt" ]; then
            CONTAINER_IMAGE=$(cat build-outputs/container-image-api.txt)
            echo "API container image from artifact: '${CONTAINER_IMAGE}'"
            echo "container_image_api=${CONTAINER_IMAGE}" >> "$GITHUB_OUTPUT"
          else
            echo "ERROR: container-image-api.txt not found in artifacts!"
            exit 1
          fi

      - name: Load MCP container image from artifact
        id: load-image-mcp
        run: |
          echo "=== LOADING MCP CONTAINER IMAGE FROM ARTIFACT ==="
          if [ -f "build-outputs/container-image-mcp.txt" ]; then
            CONTAINER_IMAGE=$(cat build-outputs/container-image-mcp.txt)
            echo "MCP container image from artifact: '${CONTAINER_IMAGE}'"
            echo "container_image_mcp=${CONTAINER_IMAGE}" >> "$GITHUB_OUTPUT"
          else
            echo "ERROR: container-image-mcp.txt not found in artifacts!"
            exit 1
          fi

      - name: Derive appVersion from image tag (Dev)
        id: derive-version-dev
        run: |
          IMAGE="${{ steps.load-image.outputs.container_image }}"
          TAG="${IMAGE##*:}"
          if [[ "$TAG" =~ ^[0-9]+\.[0-9]+\.[0-9]+.*$ ]]; then
            echo "Semantic-like tag detected: $TAG"
            echo "app_version=$TAG" >> $GITHUB_OUTPUT
          else
            echo "Tag '$TAG' not semantic; app_version left empty"
          fi

      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ env.AZURE_CLIENT_ID }}
          tenant-id: ${{ env.AZURE_TENANT_ID }}
          subscription-id: ${{ env.AZURE_SUBSCRIPTION_ID }}

      - name: Deploy Bicep template
        uses: azure/arm-deploy@v1
        with:
          subscriptionId: ${{ env.AZURE_SUBSCRIPTION_ID }}
          # vars.* mapped via env at top to reduce linter warnings
          resourceGroupName: ${{ github.event_name == 'workflow_dispatch' && format('rg-aistock-dev-{0}', github.event.inputs.instanceNumber) || 'rg-aistock-dev-002' }}
          template: ./infrastructure/main.bicep
          parameters: ./infrastructure/parameters.dev.json instanceNumber=${{ github.event_name == 'workflow_dispatch' && github.event.inputs.instanceNumber || '002' }} containerImage=${{ steps.load-image.outputs.container_image }} containerImageApi=${{ steps.load-image-api.outputs.container_image }} containerImageMcp=${{ steps.load-image-mcp.outputs.container_image_mcp }} alphaVantageApiKey=${{ secrets.ALPHA_VANTAGE_API_KEY }} twelveDataApiKey=${{ secrets.TWELVE_DATA_API_KEY }} enableAzureAdOnlyAuth=true enablePrivateSql=true enablePrivateKeyVault=true manageNetworking=false manageSql=false vnetAddressSpace=10.50.0.0/16 appIntegrationSubnetPrefix=10.50.1.0/27 privateEndpointSubnetPrefix=10.50.2.0/28 appVersion=${{ steps.derive-version-dev.outputs.app_version }} appServicePlanSku=${{ github.event_name == 'workflow_dispatch' && github.event.inputs.appServicePlanSku || 'P0v3' }}
          failOnStdErr: false

      - name: Verify SQL Admin matches API Managed Identity (Dev)
        run: |
          set -e
          INSTANCE_NUM="${{ github.event_name == 'workflow_dispatch' && github.event.inputs.instanceNumber || '002' }}"
          RG_NAME="rg-aistock-dev-${INSTANCE_NUM}"
          API_WEBAPP_NAME="api-aistock-dev-${INSTANCE_NUM}"
          SQL_SERVER_NAME="sql-aistock-dev-${INSTANCE_NUM}"
          echo "ðŸ” Verifying Dev SQL AD admin is API web app MI (UAMI-aware)"
          # Resolve principalId and display name from user-assigned MI if present
          UAMI_ID=$(az webapp identity show --name "$API_WEBAPP_NAME" --resource-group "$RG_NAME" --query "userAssignedIdentities | keys(@)[0]" -o tsv 2>/dev/null || echo "")
          if [ -n "$UAMI_ID" ] && [ "$UAMI_ID" != "null" ]; then
            MI_PRINCIPAL_ID=$(az identity show --ids "$UAMI_ID" --query principalId -o tsv 2>/dev/null || echo "")
            ADMIN_DISPLAY_NAME=$(az identity show --ids "$UAMI_ID" --query name -o tsv 2>/dev/null || echo "$API_WEBAPP_NAME")
          else
            MI_PRINCIPAL_ID=$(az webapp identity show --name "$API_WEBAPP_NAME" --resource-group "$RG_NAME" --query principalId -o tsv 2>/dev/null || echo "")
            ADMIN_DISPLAY_NAME="$API_WEBAPP_NAME"
          fi
          if [ -z "$MI_PRINCIPAL_ID" ] || [ "$MI_PRINCIPAL_ID" = "null" ]; then echo "âŒ Web app MI principalId not found (UAMI/system)"; exit 1; fi
          ADMIN_LOGIN=$(az sql server ad-admin list --server "$SQL_SERVER_NAME" --resource-group "$RG_NAME" --query "[0].login" -o tsv 2>/dev/null || echo "")
          ADMIN_SID=$(az sql server ad-admin list --server "$SQL_SERVER_NAME" --resource-group "$RG_NAME" --query "[0].sid" -o tsv 2>/dev/null || echo "")
          echo "API Web App MI: $MI_PRINCIPAL_ID (${ADMIN_DISPLAY_NAME:-$API_WEBAPP_NAME})"; echo "Current Admin login: $ADMIN_LOGIN"; echo "Current Admin sid: $ADMIN_SID"
          if [ -z "$ADMIN_SID" ] || [ "$ADMIN_SID" = "null" ]; then echo "âŒ No Azure AD admin configured (expected MI)"; exit 1; fi
          if [ "$ADMIN_SID" != "$MI_PRINCIPAL_ID" ]; then
            echo "âŒ Admin sid mismatch (expected=$MI_PRINCIPAL_ID, found=$ADMIN_SID)";
            echo "Remediation: Run infra workflow or manually: az sql server ad-admin delete --server $SQL_SERVER_NAME --resource-group $RG_NAME && az sql server ad-admin create --server $SQL_SERVER_NAME --resource-group $RG_NAME --display-name ${ADMIN_DISPLAY_NAME:-$API_WEBAPP_NAME} --object-id $MI_PRINCIPAL_ID"; exit 1; fi
          echo "âœ… Dev SQL admin matches API web app MI."

      - name: Setup .NET for migrations
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Install Entity Framework tools
        run: dotnet tool install --global dotnet-ef

      - name: Run database migrations
        run: |
          INSTANCE_NUM="${{ github.event_name == 'workflow_dispatch' && github.event.inputs.instanceNumber || '002' }}"
          RG_NAME="rg-aistock-dev-${INSTANCE_NUM}"

          echo "Getting SQL Server connection details..."

          # Try to get connection string from Key Vault, but don't fail if access is denied
          KEY_VAULT_NAME="kv-aistock-dev-${INSTANCE_NUM}"
          CONNECTION_STRING=$(az keyvault secret show --vault-name "${KEY_VAULT_NAME}" --name "SqlConnectionString" --query "value" --output tsv 2>/dev/null || echo "")

          if [ -z "${CONNECTION_STRING}" ]; then
            echo "INFO: Could not retrieve connection string from Key Vault (permission may not be configured yet)."
            echo "Database migrations will run automatically on first app startup."
            echo "This is normal for first-time deployments."
          else
            echo "Running database migrations manually..."
            cd AiStockTradeApp
            export ConnectionStrings__DefaultConnection="${CONNECTION_STRING}"
            dotnet ef database update --verbose
          fi

      - name: Update Web App Container
        run: |
          INSTANCE_NUM="${{ github.event_name == 'workflow_dispatch' && github.event.inputs.instanceNumber || '002' }}"
          WEBAPP_NAME="app-aistock-dev-${INSTANCE_NUM}"
          RG_NAME="rg-aistock-dev-${INSTANCE_NUM}"

          # Get registry information from the same resource group
          REGISTRY_NAME=$(az acr list --resource-group "${RG_NAME}" --query '[0].name' --output tsv)
          REGISTRY_USERNAME=$(az acr credential show --name "${REGISTRY_NAME}" --query 'username' --output tsv)
          REGISTRY_PASSWORD=$(az acr credential show --name "${REGISTRY_NAME}" --query 'passwords[0].value' --output tsv)

          echo "Container Image: ${{ steps.load-image.outputs.container_image }}"
          echo "Web App Name: ${WEBAPP_NAME}"
          echo "Resource Group: ${RG_NAME}"
          echo "Registry Name: ${REGISTRY_NAME}"

          if [ -z "${{ steps.load-image.outputs.container_image }}" ]; then
            echo "ERROR: Container image is empty!"
            exit 1
          fi

          az webapp config container set \
            --name "${WEBAPP_NAME}" \
            --resource-group "${RG_NAME}" \
            --container-image-name "${{ steps.load-image.outputs.container_image }}" \
            --container-registry-url "https://${REGISTRY_NAME}.azurecr.io" \
            --container-registry-user "${REGISTRY_USERNAME}" \
            --container-registry-password "${REGISTRY_PASSWORD}"

      - name: Update API Web App Container
        run: |
          INSTANCE_NUM="${{ github.event_name == 'workflow_dispatch' && github.event.inputs.instanceNumber || '002' }}"
          WEBAPP_NAME="api-aistock-dev-${INSTANCE_NUM}"
          RG_NAME="rg-aistock-dev-${INSTANCE_NUM}"

          # Get registry information from the same resource group
          REGISTRY_NAME=$(az acr list --resource-group "${RG_NAME}" --query '[0].name' --output tsv)
          REGISTRY_USERNAME=$(az acr credential show --name "${REGISTRY_NAME}" --query 'username' --output tsv)
          REGISTRY_PASSWORD=$(az acr credential show --name "${REGISTRY_NAME}" --query 'passwords[0].value' --output tsv)

          echo "API Container Image: ${{ steps.load-image-api.outputs.container_image_api }}"
          echo "API Web App Name: ${WEBAPP_NAME}"
          echo "Resource Group: ${RG_NAME}"
          echo "Registry Name: ${REGISTRY_NAME}"

          if [ -z "${{ steps.load-image-api.outputs.container_image_api }}" ]; then
            echo "ERROR: API container image is empty!"; exit 1; fi

          az webapp config container set \
            --name "${WEBAPP_NAME}" \
            --resource-group "${RG_NAME}" \
            --container-image-name "${{ steps.load-image-api.outputs.container_image_api }}" \
            --container-registry-url "https://${REGISTRY_NAME}.azurecr.io" \
            --container-registry-user "${REGISTRY_USERNAME}" \
            --container-registry-password "${REGISTRY_PASSWORD}"

      - name: Update MCP Web App Container
        run: |
          INSTANCE_NUM="${{ github.event_name == 'workflow_dispatch' && github.event.inputs.instanceNumber || '002' }}"
          WEBAPP_NAME="mcp-aistock-dev-${INSTANCE_NUM}"
          RG_NAME="rg-aistock-dev-${INSTANCE_NUM}"

          # Get registry information from the same resource group
          REGISTRY_NAME=$(az acr list --resource-group "${RG_NAME}" --query '[0].name' --output tsv)
          REGISTRY_USERNAME=$(az acr credential show --name "${REGISTRY_NAME}" --query 'username' --output tsv)
          REGISTRY_PASSWORD=$(az acr credential show --name "${REGISTRY_NAME}" --query 'passwords[0].value' --output tsv)

          echo "MCP Container Image: ${{ steps.load-image-mcp.outputs.container_image_mcp }}"
          echo "MCP Web App Name: ${WEBAPP_NAME}"
          echo "Resource Group: ${RG_NAME}"
          echo "Registry Name: ${REGISTRY_NAME}"

          if [ -z "${{ steps.load-image-mcp.outputs.container_image_mcp }}" ]; then
            echo "ERROR: MCP container image is empty!"; exit 1; fi

          az webapp config container set \
            --name "${WEBAPP_NAME}" \
            --resource-group "${RG_NAME}" \
            --container-image-name "${{ steps.load-image-mcp.outputs.container_image_mcp }}" \
            --container-registry-url "https://${REGISTRY_NAME}.azurecr.io" \
            --container-registry-user "${REGISTRY_USERNAME}" \
            --container-registry-password "${REGISTRY_PASSWORD}"

      - name: Run Health Check
        run: |
          INSTANCE_NUM="${{ github.event_name == 'workflow_dispatch' && github.event.inputs.instanceNumber || '002' }}"
          WEBAPP_NAME="app-aistock-dev-${INSTANCE_NUM}"
          RG_NAME="rg-aistock-dev-${INSTANCE_NUM}"
          HEALTH_URL="https://${WEBAPP_NAME}.azurewebsites.net/health"
          BASE_URL="https://${WEBAPP_NAME}.azurewebsites.net"
          echo "ðŸ¥ Starting comprehensive health check (Dev UI)..."
          echo "Base URL: ${BASE_URL}"
          echo "Health URL: ${HEALTH_URL}"
          echo "Waiting for deployment to be ready..."
          sleep 60
          echo "Testing basic site accessibility..."
          for i in {1..5}; do
            if curl -f -s "${BASE_URL}" >/dev/null 2>&1; then
              echo "âœ… Site is accessible (attempt $i)"; break
            else
              echo "â³ Site not ready yet (attempt $i/5)..."; sleep 20
            fi
          done
          echo "Testing health endpoint..."
          for i in {1..10}; do
            echo "Health check attempt $i/10..."
            HTTP_CODE=$(curl -s -o /tmp/health_ui_dev.txt -w "%{http_code}" "${HEALTH_URL}")
            RESPONSE_BODY=$(cat /tmp/health_ui_dev.txt 2>/dev/null || echo "No response body")
            echo "HTTP Status: ${HTTP_CODE}"; echo "Response: ${RESPONSE_BODY}"
            if [ "${HTTP_CODE}" = "200" ]; then
              echo "âœ… Health check passed!"; exit 0
            fi
            sleep 30
          done
          echo "âŒ UI Health check failed (Dev)"; exit 1

      - name: Run API Health Check
        run: |
          INSTANCE_NUM="${{ github.event_name == 'workflow_dispatch' && github.event.inputs.instanceNumber || '002' }}"
          WEBAPP_NAME="api-aistock-dev-${INSTANCE_NUM}"
          RG_NAME="rg-aistock-dev-${INSTANCE_NUM}"
          HEALTH_URL="https://${WEBAPP_NAME}.azurewebsites.net/health"
          BASE_URL="https://${WEBAPP_NAME}.azurewebsites.net"
          echo "ðŸ¥ Starting API health check (Dev API)..."
          echo "Base URL: ${BASE_URL}"
          echo "Health URL: ${HEALTH_URL}"
          echo "Waiting for API deployment to be ready..."
          sleep 60
          for i in {1..10}; do
            echo "API Health check attempt $i/10..."
            HTTP_CODE=$(curl -s -o /tmp/health_api_dev.txt -w "%{http_code}" "${HEALTH_URL}")
            RESPONSE_BODY=$(cat /tmp/health_api_dev.txt 2>/dev/null || echo "No response body")
            echo "HTTP Status: ${HTTP_CODE}"; echo "Response: ${RESPONSE_BODY}"
            if [ "${HTTP_CODE}" = "200" ]; then
              echo "âœ… API Health check passed!"; exit 0
            fi
            sleep 30
          done
          echo "âŒ API Health check failed (Dev)"; exit 1

      - name: Validate External Stock API Keys (Dev)
        if: success() # Only run if prior health checks passed
        run: |
          set -e
          INSTANCE_NUM="${{ github.event_name == 'workflow_dispatch' && github.event.inputs.instanceNumber || '002' }}"
          API_APP="api-aistock-dev-${INSTANCE_NUM}"
          API_KEYS_URL="https://${API_APP}.azurewebsites.net/health/api-keys"
          echo "ðŸ” Validating external stock API key configuration via ${API_KEYS_URL}"          
          HTTP_CODE=$(curl -s -o api_keys_dev.json -w "%{http_code}" "${API_KEYS_URL}" || true)
          echo "HTTP Status: ${HTTP_CODE}"
          if [ "${HTTP_CODE}" != "200" ]; then
            echo "âŒ Unable to retrieve API key status (expected 200)."; cat api_keys_dev.json || true; exit 1; fi
          echo "Raw response:"; cat api_keys_dev.json
          echo "Evaluating key states (fail on unresolved-keyvault / placeholder; warn on missing)..."
          if grep -q '"status"[[:space:]]*:[[:space:]]*"unresolved-keyvault"' api_keys_dev.json; then
            echo "âŒ Found disallowed status 'unresolved-keyvault'"; exit 1; fi
          if grep -q '"status"[[:space:]]*:[[:space:]]*"placeholder"' api_keys_dev.json; then
            echo "âŒ Found disallowed status 'placeholder'"; exit 1; fi
          if grep -q '"status"[[:space:]]*:[[:space:]]*"missing"' api_keys_dev.json; then
            echo "âš ï¸  One or more keys are missing (allowed but degraded fallback will be used)"; fi
          echo "âœ… API key configuration validation completed."

      - name: Job Summary (Deploy Dev)
        if: always()
        run: |
          {
            echo "## ðŸš€ Deploy Dev Job Summary";
            echo "**Overall Job Status:** ${{ job.status }}";
            echo "**Image:** ${{ steps.load-image.outputs.container_image }}";
            echo "**API Image:** ${{ steps.load-image-api.outputs.container_image_api }}";
            echo "**MCP Image:** ${{ steps.load-image-mcp.outputs.container_image_mcp }}";
            if [ -f api_keys_dev.json ]; then
              echo "\n### API Key Status (raw excerpt)";
              cat api_keys_dev.json | head -100;
            else
              echo "\n_No API key status file captured._";
            fi
          } >> "$GITHUB_STEP_SUMMARY"

  deploy-prod:
    runs-on: [self-hosted, linux, x64]
    needs: [build, deploy-dev]
    name: Deploy to Production
    if: |
      always() && 
      (needs.build.result == 'success') &&
      (needs.deploy-dev.result == 'success' || needs.deploy-dev.result == 'skipped') &&
      (github.ref == 'refs/heads/main' || (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'prod'))
    environment: ${{ github.event_name == 'workflow_dispatch' && format('production-{0}', github.event.inputs.instanceNumber) || 'production-002' }}
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download build outputs
        uses: actions/download-artifact@v4
        with:
          name: build-outputs
          path: build-outputs/

      - name: Load container image from artifact
        id: load-image
        run: |
          echo "=== LOADING CONTAINER IMAGE FROM ARTIFACT ==="
          if [ -f "build-outputs/container-image.txt" ]; then
            CONTAINER_IMAGE=$(cat build-outputs/container-image.txt)
            echo "Container image from artifact: '${CONTAINER_IMAGE}'"
            echo "container_image=${CONTAINER_IMAGE}" >> "$GITHUB_OUTPUT"
          else
            echo "ERROR: container-image.txt not found in artifacts!"
            exit 1
          fi

      - name: Load API container image from artifact
        id: load-image-api
        run: |
          echo "=== LOADING API CONTAINER IMAGE FROM ARTIFACT ==="
          if [ -f "build-outputs/container-image-api.txt" ]; then
            CONTAINER_IMAGE=$(cat build-outputs/container-image-api.txt)
            echo "API container image from artifact: '${CONTAINER_IMAGE}'"
            echo "container_image_api=${CONTAINER_IMAGE}" >> "$GITHUB_OUTPUT"
          else
            echo "ERROR: container-image-api.txt not found in artifacts!"
            exit 1
          fi

      - name: Load MCP container image from artifact
        id: load-image-mcp
        run: |
          echo "=== LOADING MCP CONTAINER IMAGE FROM ARTIFACT ==="
          if [ -f "build-outputs/container-image-mcp.txt" ]; then
            CONTAINER_IMAGE=$(cat build-outputs/container-image-mcp.txt)
            echo "MCP container image from artifact: '${CONTAINER_IMAGE}'"
            echo "container_image_mcp=${CONTAINER_IMAGE}" >> "$GITHUB_OUTPUT"
          else
            echo "ERROR: container-image-mcp.txt not found in artifacts!"
            exit 1
          fi

      - name: Derive appVersion from image tag (Prod)
        id: derive-version-prod
        run: |
          IMAGE="${{ steps.load-image.outputs.container_image }}"
          TAG="${IMAGE##*:}"
          if [[ "$TAG" =~ ^[0-9]+\.[0-9]+\.[0-9]+.*$ ]]; then
            echo "Semantic-like tag detected: $TAG"
            echo "app_version=$TAG" >> $GITHUB_OUTPUT
          else
            echo "Tag '$TAG' not semantic; app_version left empty"
          fi

      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ env.AZURE_CLIENT_ID }}
          tenant-id: ${{ env.AZURE_TENANT_ID }}
          subscription-id: ${{ env.AZURE_SUBSCRIPTION_ID }}

      - name: Debug Variables
        run: |
          echo "=== DEPLOYMENT DEBUG INFO ==="
          echo "Job name: deploy-prod"
          echo "GitHub ref: ${{ github.ref }}"
          echo "Event name: ${{ github.event_name }}"
          echo "Environment input: ${{ github.event.inputs.environment }}"
          echo "Instance Number: ${{ github.event.inputs.instanceNumber }}"
          INSTANCE_NUM="${{ github.event_name == 'workflow_dispatch' && github.event.inputs.instanceNumber || '002' }}"
          echo "Resolved Instance Number: ${INSTANCE_NUM}"
          echo "Resource Group: rg-aistock-prod-${INSTANCE_NUM}"
          echo "Web App Name: app-aistock-prod-${INSTANCE_NUM}"
          echo "=== BUILD JOB OUTPUTS ==="
          echo "Build job result: ${{ needs.build.result }}"
          echo "Build job outputs: ${{ toJson(needs.build.outputs) }}"
          echo "Container image from needs: ${{ needs.build.outputs.image }}"
          echo "Test output: ${{ needs.build.outputs.test_output }}"
          echo "=== ARTIFACT DATA ==="
          echo "Container image from artifact: ${{ steps.load-image.outputs.container_image }}"
          echo "=== VARIABLES ==="
          echo "Subscription ID: ${{ env.AZURE_SUBSCRIPTION_ID }}"
          echo "Resolved Subscription ID via env: ${{ env.AZURE_SUBSCRIPTION_ID }}"
          echo "Container Image: ${{ steps.load-image.outputs.container_image }}"

      # Removed service principal-based SQL admin override. Infrastructure workflow already sets
      # the SQL Server Azure AD admin to the web app managed identity. We keep that and detect
      # Azure AD-only capability later.

      - name: Deploy Bicep template (AAD-only capable)
        uses: azure/arm-deploy@v1
        with:
          subscriptionId: ${{ env.AZURE_SUBSCRIPTION_ID }}
          # Using env mapping
          resourceGroupName: ${{ github.event_name == 'workflow_dispatch' && format('rg-aistock-prod-{0}', github.event.inputs.instanceNumber) || 'rg-aistock-prod-002' }}
          template: ./infrastructure/main.bicep
          # AAD-only auth is the standard. Bicep sets the SQL AAD admin to the API Web App MI when explicit admin values are not provided.
          parameters: ./infrastructure/parameters.prod.json instanceNumber=${{ github.event_name == 'workflow_dispatch' && github.event.inputs.instanceNumber || '002' }} containerImage=${{ steps.load-image.outputs.container_image }} containerImageApi=${{ steps.load-image-api.outputs.container_image }} containerImageMcp=${{ steps.load-image-mcp.outputs.container_image_mcp }} alphaVantageApiKey=${{ secrets.ALPHA_VANTAGE_API_KEY }} twelveDataApiKey=${{ secrets.TWELVE_DATA_API_KEY }} enableAzureAdOnlyAuth=true enablePrivateSql=true enablePrivateKeyVault=true manageNetworking=false manageSql=false vnetAddressSpace=10.51.0.0/16 appIntegrationSubnetPrefix=10.51.1.0/27 privateEndpointSubnetPrefix=10.51.2.0/28 appVersion=${{ steps.derive-version-prod.outputs.app_version }} appServicePlanSku=${{ github.event_name == 'workflow_dispatch' && github.event.inputs.appServicePlanSku || 'P0v3' }}
          failOnStdErr: false

      - name: Verify SQL Admin matches API Managed Identity (Prod)
        run: |
          set -e
          INSTANCE_NUM="${{ github.event_name == 'workflow_dispatch' && github.event.inputs.instanceNumber || '002' }}"
          RG_NAME="rg-aistock-prod-${INSTANCE_NUM}"
          API_WEBAPP_NAME="api-aistock-prod-${INSTANCE_NUM}"
          SQL_SERVER_NAME="sql-aistock-prod-${INSTANCE_NUM}"

          echo "ðŸ” Verifying Azure SQL Server AD admin is API web app managed identity (UAMI-aware)"
          UAMI_ID=$(az webapp identity show --name "$API_WEBAPP_NAME" --resource-group "$RG_NAME" --query "userAssignedIdentities | keys(@)[0]" -o tsv 2>/dev/null || echo "")
          if [ -n "$UAMI_ID" ] && [ "$UAMI_ID" != "null" ]; then
            MI_PRINCIPAL_ID=$(az identity show --ids "$UAMI_ID" --query principalId -o tsv 2>/dev/null || echo "")
            ADMIN_DISPLAY_NAME=$(az identity show --ids "$UAMI_ID" --query name -o tsv 2>/dev/null || echo "$API_WEBAPP_NAME")
          else
            MI_PRINCIPAL_ID=$(az webapp identity show --name "$API_WEBAPP_NAME" --resource-group "$RG_NAME" --query principalId -o tsv 2>/dev/null || echo "")
            ADMIN_DISPLAY_NAME="$API_WEBAPP_NAME"
          fi
          if [ -z "$MI_PRINCIPAL_ID" ] || [ "$MI_PRINCIPAL_ID" = "null" ]; then
            echo "âŒ Managed identity principalId not found for API web app $API_WEBAPP_NAME (UAMI/system)"; exit 1; fi

          ADMIN_LOGIN=$(az sql server ad-admin list --server "$SQL_SERVER_NAME" --resource-group "$RG_NAME" --query "[0].login" -o tsv 2>/dev/null || echo "")
          ADMIN_SID=$(az sql server ad-admin list --server "$SQL_SERVER_NAME" --resource-group "$RG_NAME" --query "[0].sid" -o tsv 2>/dev/null || echo "")

          echo "API Web App MI principalId: $MI_PRINCIPAL_ID (${ADMIN_DISPLAY_NAME:-$API_WEBAPP_NAME})"
          echo "Current SQL Admin login: $ADMIN_LOGIN"
          echo "Current SQL Admin sid:   $ADMIN_SID"

          if [ -z "$ADMIN_SID" ] || [ "$ADMIN_SID" = "null" ]; then
            echo "âŒ No Azure AD admin configured on SQL server (expected web app MI)."; exit 1; fi

          if [ "$ADMIN_SID" != "$MI_PRINCIPAL_ID" ]; then
            echo "âŒ SQL admin sid does not match API web app MI."
            echo "   Expected: $MI_PRINCIPAL_ID"
            echo "   Found:    $ADMIN_SID (login=$ADMIN_LOGIN)"
            echo "ðŸ’¡ Remediation: Re-run infrastructure workflow to enforce MI admin or manually:"
            echo "   az sql server ad-admin delete --server $SQL_SERVER_NAME --resource-group $RG_NAME || true"
            echo "   az sql server ad-admin create --server $SQL_SERVER_NAME --resource-group $RG_NAME --display-name ${ADMIN_DISPLAY_NAME:-$API_WEBAPP_NAME} --object-id $MI_PRINCIPAL_ID"
            exit 1
          fi
          echo "âœ… SQL admin sid matches API web app MI (login=$ADMIN_LOGIN)."

      - name: Setup .NET for migrations
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Install Entity Framework tools
        run: dotnet tool install --global dotnet-ef

      - name: Setup Web App SQL Database Access (Azure AD)
        run: |
          INSTANCE_NUM="${{ github.event_name == 'workflow_dispatch' && github.event.inputs.instanceNumber || '002' }}"
          RG_NAME="rg-aistock-prod-${INSTANCE_NUM}"
          WEBAPP_NAME="app-aistock-prod-${INSTANCE_NUM}"
          SQL_SERVER_NAME="sql-aistock-prod-${INSTANCE_NUM}"
          DATABASE_NAME="sqldb-aistock-prod-${INSTANCE_NUM}"
          # Dynamically detect if Azure AD admin (web app MI) is present
          echo "ðŸ” Detecting Azure AD admin (expect web app managed identity)..."
          CURRENT_ADMIN_LOGIN=$(az sql server ad-admin list --server "$SQL_SERVER_NAME" --resource-group "$RG_NAME" --query "[0].login" -o tsv 2>/dev/null || echo "")
          CURRENT_ADMIN_SID=$(az sql server ad-admin list --server "$SQL_SERVER_NAME" --resource-group "$RG_NAME" --query "[0].sid" -o tsv 2>/dev/null || echo "")
          # Prefer user-assigned identity principal for comparison
          UAMI_ID_WEBAPP=$(az webapp identity show --name "$WEBAPP_NAME" --resource-group "$RG_NAME" --query "userAssignedIdentities | keys(@)[0]" -o tsv 2>/dev/null || echo "")
          if [ -n "$UAMI_ID_WEBAPP" ] && [ "$UAMI_ID_WEBAPP" != "null" ]; then
            WEBAPP_MI_PRINCIPAL=$(az identity show --ids "$UAMI_ID_WEBAPP" --query principalId -o tsv 2>/dev/null || echo "")
            PRINCIPAL_NAME=$(az identity show --ids "$UAMI_ID_WEBAPP" --query name -o tsv 2>/dev/null || echo "$WEBAPP_NAME")
          else
            WEBAPP_MI_PRINCIPAL=$(az webapp identity show --name "$WEBAPP_NAME" --resource-group "$RG_NAME" --query principalId -o tsv 2>/dev/null || echo "")
            PRINCIPAL_NAME="$WEBAPP_NAME"
          fi
          if [ "$CURRENT_ADMIN_SID" = "$WEBAPP_MI_PRINCIPAL" ]; then
            ENABLE_AAD_ONLY=true
            echo "âœ… Azure AD admin matches web app MI (login=$CURRENT_ADMIN_LOGIN)"
          else
            ENABLE_AAD_ONLY=false
            echo "âš ï¸ Azure AD admin does not match web app MI (adminLogin=$CURRENT_ADMIN_LOGIN, adminSid=$CURRENT_ADMIN_SID, mi=$WEBAPP_MI_PRINCIPAL) - skipping MI DB user creation."
          fi

          echo "ðŸ”§ Setting up SQL Database access for Web App managed identity..."
          echo "Web App: ${WEBAPP_NAME}"
          echo "SQL Server: ${SQL_SERVER_NAME}"
          echo "Database: ${DATABASE_NAME}"
          echo "enableAzureAdOnlyAuth flag: ${ENABLE_AAD_ONLY}"

          if [ "${ENABLE_AAD_ONLY}" != "true" ]; then
            echo "âš ï¸ Azure AD only auth disabled (no admin present). Skipping managed identity user creation step."
            exit 0
          fi

          # First, verify the web app managed identity is enabled
          echo "ðŸ” Verifying web app managed identity..."
          MANAGED_IDENTITY=$(az webapp identity show --name "${WEBAPP_NAME}" --resource-group "${RG_NAME}" --query "principalId" --output tsv 2>/dev/null || echo "")

          if [ -z "${MANAGED_IDENTITY}" ] || [ "${MANAGED_IDENTITY}" == "null" ]; then
            echo "âš ï¸ Web app managed identity not found. Enabling it..."
            az webapp identity assign --name "${WEBAPP_NAME}" --resource-group "${RG_NAME}"
            sleep 10  # Wait for identity propagation
            MANAGED_IDENTITY=$(az webapp identity show --name "${WEBAPP_NAME}" --resource-group "${RG_NAME}" --query "principalId" --output tsv)
          fi

          echo "âœ… Web app managed identity ID: ${MANAGED_IDENTITY}"

          # Get the SQL Server FQDN
          SQL_SERVER_FQDN="${SQL_SERVER_NAME}.database.windows.net"

          echo "ðŸ” Attempting to create SQL user for managed identity..."

          # Install sqlcmd tools
          echo "Installing sqlcmd..."
          curl https://packages.microsoft.com/keys/microsoft.asc | sudo apt-key add -
          curl https://packages.microsoft.com/config/ubuntu/20.04/prod.list | sudo tee /etc/apt/sources.list.d/msprod.list
          sudo apt-get update
          sudo apt-get install -y mssql-tools unixodbc-dev

          echo "Testing basic connectivity to SQL Server..."
          if ! timeout 10 bash -c "</dev/tcp/${SQL_SERVER_NAME}.database.windows.net/1433" 2>/dev/null; then
            echo "âŒ Cannot connect to SQL Server on port 1433. Check firewall rules."
            exit 1
          else
            echo "âœ… SQL Server is reachable on port 1433"
          fi

          echo "ðŸŒ Polling API health endpoint for Managed Identity DB connectivity (pre-user-create)"
          API_URL="https://api-aistock-prod-${INSTANCE_NUM}.azurewebsites.net"
          for i in $(seq 1 8); do
            CODE=$(curl -s -o health_pre.json -w "%{http_code}" "$API_URL/health/db" || true)
            echo "Health attempt $i HTTP=$CODE"
            if [ "$CODE" = "200" ]; then
              if grep -q '@Microsoft.KeyVault' health_pre.json; then echo "âŒ Unresolved KeyVault token detected (pre-user-create)"; exit 1; fi
              break
            fi
            sleep 8
          done
          echo "Attempting to create managed identity user in SQL database (UAMI-aware)..."

          # Use resolved PRINCIPAL_NAME (UAMI display name when present) for SQL principal
          CREATE_USER_SQL="IF NOT EXISTS (SELECT 1 FROM sys.database_principals WHERE name = '${PRINCIPAL_NAME}') BEGIN PRINT 'Creating user ${PRINCIPAL_NAME}'; CREATE USER [${PRINCIPAL_NAME}] FROM EXTERNAL PROVIDER; END ELSE PRINT 'User ${PRINCIPAL_NAME} already exists';"
          ASSIGN_ROLES_SQL="DECLARE @u sysname='${PRINCIPAL_NAME}'; DECLARE @r TABLE(n sysname); INSERT INTO @r VALUES('db_datareader'),('db_datawriter'),('db_ddladmin'); DECLARE c CURSOR LOCAL FAST_FORWARD FOR SELECT n FROM @r; OPEN c; DECLARE @n sysname; FETCH NEXT FROM c INTO @n; WHILE @@FETCH_STATUS=0 BEGIN IF IS_ROLEMEMBER(@n,@u)=1 PRINT @n+' already assigned'; ELSE BEGIN DECLARE @sql nvarchar(300)=N'ALTER ROLE '+QUOTENAME(@n)+' ADD MEMBER '+QUOTENAME(@u)+';'; PRINT 'Assigning '+@n; EXEC(@sql); END; FETCH NEXT FROM c INTO @n; END CLOSE c; DEALLOCATE c;"
          FINAL_QUERY="${CREATE_USER_SQL} ${ASSIGN_ROLES_SQL} SELECT dp.name AS principal_name,r.name AS role_name FROM sys.database_principals dp JOIN sys.database_role_members rm ON dp.principal_id=rm.member_principal_id JOIN sys.database_principals r ON rm.role_principal_id=r.principal_id WHERE dp.name='${PRINCIPAL_NAME}';"

          echo "Executing SQL (length: ${#FINAL_QUERY}) with retry logic"

          MAX_RETRIES=5
          SLEEP_SECONDS=20
          attempt=1
          SUCCESS=0
          while [ $attempt -le $MAX_RETRIES ]; do
            echo "Attempt $attempt of $MAX_RETRIES..."
            if /opt/mssql-tools/bin/sqlcmd -S "${SQL_SERVER_FQDN}" -d "${DATABASE_NAME}" -G -l 30 -Q "${FINAL_QUERY}"; then
              echo "âœ… Successfully executed SQL script for managed identity setup on attempt $attempt"
              SUCCESS=1
              break
            else
              echo "âŒ Attempt $attempt failed"
              if [ $attempt -lt $MAX_RETRIES ]; then
                echo "Waiting ${SLEEP_SECONDS}s before retry..."
                sleep $SLEEP_SECONDS
              fi
            fi
            attempt=$((attempt+1))
          done

          if [ $SUCCESS -eq 1 ]; then
            echo "Testing managed identity connection..."
            cat > test_connection.sql << 'TEST_SQL_END'
          SELECT 
              USER_NAME() as current_user,
              SYSTEM_USER as system_user,
              DB_NAME() as database_name,
              GETDATE() as current_time;
          TEST_SQL_END
            if /opt/mssql-tools/bin/sqlcmd -S "${SQL_SERVER_FQDN}" -d "${DATABASE_NAME}" -G -l 30 -i test_connection.sql; then
              echo "Connection test successful"
            else
              echo "Connection test failed, but user creation may have succeeded"
            fi
            echo "ðŸ” Polling API health endpoint post user creation to confirm DB connection via MI"
            for i in $(seq 1 12); do
              CODE=$(curl -s -o health_post.json -w "%{http_code}" "$API_URL/health/db" || true)
              echo "Post-create health attempt $i HTTP=$CODE"
              if [ "$CODE" = "200" ]; then
                if grep -q '@Microsoft.KeyVault' health_post.json; then echo "âŒ Unresolved KeyVault token detected post user creation"; exit 1; fi
                if grep -q '"dbConnection"\s*:\s*true' health_post.json; then echo "âœ… API reports successful DB connection via Managed Identity"; break; fi
              fi
              sleep 10
            done
          else
            echo "âš ï¸ All $MAX_RETRIES attempts to create the managed identity user failed."
            echo "Manual Steps Required:"
            echo "  1. Connect to SQL Server as an Azure AD admin"
            echo "  2. Run the following commands (using resolved principal '${PRINCIPAL_NAME}'):"
            echo "     USE [${DATABASE_NAME}];"
            echo "     CREATE USER [${PRINCIPAL_NAME}] FROM EXTERNAL PROVIDER;"
            echo "     ALTER ROLE db_datareader ADD MEMBER [${PRINCIPAL_NAME}];"
            echo "     ALTER ROLE db_datawriter ADD MEMBER [${PRINCIPAL_NAME}];"
            echo "     ALTER ROLE db_ddladmin ADD MEMBER [${PRINCIPAL_NAME}];"
            echo "Proceeding without blocking deployment. Application may have DB access issues until resolved."
          fi

      - name: Run database migrations
        run: |
          INSTANCE_NUM="${{ github.event_name == 'workflow_dispatch' && github.event.inputs.instanceNumber || '002' }}"
          RG_NAME="rg-aistock-prod-${INSTANCE_NUM}"

          echo "ðŸ—„ï¸ Checking database migration options..."
          echo "Resource Group: ${RG_NAME}"

          # Try to get connection string from Key Vault, but don't fail if access is denied
          KEY_VAULT_NAME="kv-aistock-prod-${INSTANCE_NUM}"
          echo "Attempting to retrieve connection string from Key Vault: ${KEY_VAULT_NAME}"

          CONNECTION_STRING=$(az keyvault secret show --vault-name "${KEY_VAULT_NAME}" --name "SqlConnectionString" --query "value" --output tsv 2>/dev/null || echo "")

          if [ -z "${CONNECTION_STRING}" ]; then
            echo "â„¹ï¸ Could not retrieve connection string from Key Vault."
            echo "This is expected for first-time deployments or when pipeline doesn't have Key Vault access."
            echo ""
            echo "ðŸš€ Database migrations will run automatically on first app startup."
            echo "The application is configured to:"
            echo "  1. Use Azure AD managed identity authentication"
            echo "  2. Run Entity Framework migrations automatically"
            echo "  3. Create necessary database schema"
            echo ""
            echo "âœ… Skipping manual migration - letting app handle it during startup"
          else
            echo "âœ… Retrieved connection string from Key Vault"
            echo "Connection string type: $(echo "${CONNECTION_STRING}" | grep -o 'Authentication=[^;]*' || echo 'SQL Authentication')"
            
            if echo "${CONNECTION_STRING}" | grep -q "Authentication=Active Directory Default"; then
              echo "ðŸ” Using Azure AD authentication for migrations"
            else
              echo "ðŸ”‘ Using SQL authentication for migrations"
            fi
            
            echo "Running database migrations manually..."
            cd AiStockTradeApp
            export ConnectionStrings__DefaultConnection="${CONNECTION_STRING}"
            
            # Run with verbose output
            echo "Starting Entity Framework migration..."
            dotnet ef database update --verbose
            
            if [ $? -eq 0 ]; then
              echo "âœ… Database migrations completed successfully"
            else
              echo "âš ï¸ Migration failed, but this may be handled during app startup"
            fi
          fi

      - name: Update Web App Container
        run: |
          INSTANCE_NUM="${{ github.event_name == 'workflow_dispatch' && github.event.inputs.instanceNumber || '002' }}"
          WEBAPP_NAME="app-aistock-prod-${INSTANCE_NUM}"
          RG_NAME="rg-aistock-prod-${INSTANCE_NUM}"

          # Get registry information from DEV resource group (shared registry)
          DEV_RG_NAME="rg-aistock-dev-${INSTANCE_NUM}"
          REGISTRY_NAME=$(az acr list --resource-group "${DEV_RG_NAME}" --query '[0].name' --output tsv)
          REGISTRY_USERNAME=$(az acr credential show --name "${REGISTRY_NAME}" --query 'username' --output tsv)
          REGISTRY_PASSWORD=$(az acr credential show --name "${REGISTRY_NAME}" --query 'passwords[0].value' --output tsv)

          echo "Container Image: ${{ steps.load-image.outputs.container_image }}"
          echo "Web App Name: ${WEBAPP_NAME}"
          echo "Prod Resource Group: ${RG_NAME}"
          echo "Dev Registry Resource Group: ${DEV_RG_NAME}"
          echo "Shared Registry Name: ${REGISTRY_NAME}"

          if [ -z "${{ steps.load-image.outputs.container_image }}" ]; then
            echo "ERROR: Container image is empty!"
            exit 1
          fi

          az webapp config container set \
            --name "${WEBAPP_NAME}" \
            --resource-group "${RG_NAME}" \
            --container-image-name "${{ steps.load-image.outputs.container_image }}" \
            --container-registry-url "https://${REGISTRY_NAME}.azurecr.io" \
            --container-registry-user "${REGISTRY_USERNAME}" \
            --container-registry-password "${REGISTRY_PASSWORD}"

      - name: Update API Web App Container
        run: |
          INSTANCE_NUM="${{ github.event_name == 'workflow_dispatch' && github.event.inputs.instanceNumber || '002' }}"
          WEBAPP_NAME="api-aistock-prod-${INSTANCE_NUM}"
          RG_NAME="rg-aistock-prod-${INSTANCE_NUM}"

          # Get registry information from DEV resource group (shared registry)
          DEV_RG_NAME="rg-aistock-dev-${INSTANCE_NUM}"
          REGISTRY_NAME=$(az acr list --resource-group "${DEV_RG_NAME}" --query '[0].name' --output tsv)
          REGISTRY_USERNAME=$(az acr credential show --name "${REGISTRY_NAME}" --query 'username' --output tsv)
          REGISTRY_PASSWORD=$(az acr credential show --name "${REGISTRY_NAME}" --query 'passwords[0].value' --output tsv)

          echo "API Container Image: ${{ steps.load-image-api.outputs.container_image_api }}"
          echo "API Web App Name: ${WEBAPP_NAME}"
          echo "Prod Resource Group: ${RG_NAME}"
          echo "Dev Registry Resource Group: ${DEV_RG_NAME}"
          echo "Shared Registry Name: ${REGISTRY_NAME}"

          if [ -z "${{ steps.load-image-api.outputs.container_image_api }}" ]; then
            echo "ERROR: API container image is empty!"; exit 1; fi

          az webapp config container set \
            --name "${WEBAPP_NAME}" \
            --resource-group "${RG_NAME}" \
            --container-image-name "${{ steps.load-image-api.outputs.container_image_api }}" \
            --container-registry-url "https://${REGISTRY_NAME}.azurecr.io" \
            --container-registry-user "${REGISTRY_USERNAME}" \
            --container-registry-password "${REGISTRY_PASSWORD}"

      - name: Update MCP Web App Container
        run: |
          INSTANCE_NUM="${{ github.event_name == 'workflow_dispatch' && github.event.inputs.instanceNumber || '002' }}"
          WEBAPP_NAME="mcp-aistock-prod-${INSTANCE_NUM}"
          RG_NAME="rg-aistock-prod-${INSTANCE_NUM}"

          # Get registry information from DEV resource group (shared registry)
          DEV_RG_NAME="rg-aistock-dev-${INSTANCE_NUM}"
          REGISTRY_NAME=$(az acr list --resource-group "${DEV_RG_NAME}" --query '[0].name' --output tsv)
          REGISTRY_USERNAME=$(az acr credential show --name "${REGISTRY_NAME}" --query 'username' --output tsv)
          REGISTRY_PASSWORD=$(az acr credential show --name "${REGISTRY_NAME}" --query 'passwords[0].value' --output tsv)

          echo "MCP Container Image: ${{ steps.load-image-mcp.outputs.container_image_mcp }}"
          echo "MCP Web App Name: ${WEBAPP_NAME}"
          echo "Prod Resource Group: ${RG_NAME}"
          echo "Dev Registry Resource Group: ${DEV_RG_NAME}"
          echo "Shared Registry Name: ${REGISTRY_NAME}"

          if [ -z "${{ steps.load-image-mcp.outputs.container_image_mcp }}" ]; then
            echo "ERROR: MCP container image is empty!"; exit 1; fi

          az webapp config container set \
            --name "${WEBAPP_NAME}" \
            --resource-group "${RG_NAME}" \
            --container-image-name "${{ steps.load-image-mcp.outputs.container_image_mcp }}" \
            --container-registry-url "https://${REGISTRY_NAME}.azurecr.io" \
            --container-registry-user "${REGISTRY_USERNAME}" \
            --container-registry-password "${REGISTRY_PASSWORD}"

      - name: Run Health Check
        run: |
          INSTANCE_NUM="${{ github.event_name == 'workflow_dispatch' && github.event.inputs.instanceNumber || '002' }}"
          WEBAPP_NAME="app-aistock-prod-${INSTANCE_NUM}"
          RG_NAME="rg-aistock-prod-${INSTANCE_NUM}"
          echo "[DIAG] Dumping resolved connection string authentication mode before health checks (shared script)..."
          bash ./scripts/sql-conn-auth-dump.sh "$RG_NAME" "$WEBAPP_NAME" || echo "[DIAG] Script execution failed (non-fatal)"
          INSTANCE_NUM="${{ github.event_name == 'workflow_dispatch' && github.event.inputs.instanceNumber || '002' }}"
          WEBAPP_NAME="app-aistock-prod-${INSTANCE_NUM}"
          HEALTH_URL="https://${WEBAPP_NAME}.azurewebsites.net/health"
          BASE_URL="https://${WEBAPP_NAME}.azurewebsites.net"

          echo "ðŸ¥ Starting comprehensive health check..."
          echo "Base URL: ${BASE_URL}"
          echo "Health URL: ${HEALTH_URL}"

          # Wait for initial deployment
          echo "Waiting for deployment to be ready..."
          sleep 60

          # Check if the site is accessible at all
          echo "Testing basic site accessibility..."
          for i in {1..5}; do
            if curl -f -s "${BASE_URL}" >/dev/null 2>&1; then
              echo "âœ… Site is accessible (attempt $i)"
              break
            else
              echo "â³ Site not ready yet (attempt $i/5)..."
              sleep 30
            fi
          done

          # Check health endpoint specifically
          echo "Testing health endpoint..."
          for i in {1..10}; do
            echo "Health check attempt $i/10..."
            
            # Get detailed response
            HTTP_CODE=$(curl -s -o /tmp/health_response.txt -w "%{http_code}" "${HEALTH_URL}")
            RESPONSE_BODY=$(cat /tmp/health_response.txt 2>/dev/null || echo "No response body")
            
            echo "HTTP Status: ${HTTP_CODE}"
            echo "Response: ${RESPONSE_BODY}"
            
            if [ "${HTTP_CODE}" = "200" ]; then
              echo "âœ… Health check passed!"
              echo "Deployment successful and application is healthy."
              exit 0
            elif [ "${HTTP_CODE}" = "503" ] || [ "${HTTP_CODE}" = "500" ]; then
              echo "âš ï¸ Application error detected (HTTP ${HTTP_CODE})"
              echo "This might be a database connectivity issue."
              
              # Try to get more detailed logs
              echo "Attempting to get application logs..."
              az webapp log tail --name "${WEBAPP_NAME}" --resource-group "rg-aistock-prod-${INSTANCE_NUM}" --timeout 30 || echo "Could not retrieve logs"
              
              if [ $i -eq 10 ]; then
                echo "âŒ Health check failed after 10 attempts"
                echo "Last response (HTTP ${HTTP_CODE}): ${RESPONSE_BODY}"
                echo ""
                echo "ðŸ” Troubleshooting steps:"
                echo "1. Check Azure portal for app service logs"
                echo "2. Verify managed identity SQL user was created"
                echo "3. Check Key Vault access permissions"
                echo "4. Verify SQL Server firewall allows Azure services"
                exit 1
              fi
            else
              echo "â³ Unexpected response (HTTP ${HTTP_CODE}), retrying..."
            fi
            
            sleep 30
          done

          echo "âŒ Health check failed - no successful response received"
          exit 1

      - name: Run API Health Check
        run: |
          echo "[DIAG] Dumping resolved connection string authentication mode before API health checks (shared script)..."
          INSTANCE_NUM="${{ github.event_name == 'workflow_dispatch' && github.event.inputs.instanceNumber || '002' }}"
          API_WEBAPP_NAME="api-aistock-prod-${INSTANCE_NUM}"
          RG_NAME="rg-aistock-prod-${INSTANCE_NUM}"
          bash ./scripts/sql-conn-auth-dump.sh "$RG_NAME" "$API_WEBAPP_NAME" || echo "[DIAG] Script execution failed (non-fatal)"
          HEALTH_URL="https://${API_WEBAPP_NAME}.azurewebsites.net/health"
          BASE_URL="https://${API_WEBAPP_NAME}.azurewebsites.net"

          echo "ðŸ¥ Starting API health check..."
          echo "Base URL: ${BASE_URL}"
          echo "Health URL: ${HEALTH_URL}"
          sleep 60
          for i in {1..10}; do
            echo "API Health check attempt $i/10..."
            HTTP_CODE=$(curl -s -o /tmp/health_api_response.txt -w "%{http_code}" "${HEALTH_URL}")
            RESPONSE_BODY=$(cat /tmp/health_api_response.txt 2>/dev/null || echo "No response body")
            echo "HTTP Status: ${HTTP_CODE}"; echo "Response: ${RESPONSE_BODY}"
            if [ "${HTTP_CODE}" = "200" ]; then
              echo "âœ… API Health check passed!"; exit 0
            fi
            sleep 30
          done
          echo "âŒ API Health check failed"; exit 1

      - name: Validate External Stock API Keys (Prod)
        if: success()
        run: |
          set -e
          INSTANCE_NUM="${{ github.event_name == 'workflow_dispatch' && github.event.inputs.instanceNumber || '002' }}"
          API_APP="api-aistock-prod-${INSTANCE_NUM}"
          API_KEYS_URL="https://${API_APP}.azurewebsites.net/health/api-keys"
          echo "ðŸ” Validating external stock API key configuration (Prod) via ${API_KEYS_URL}"          
          HTTP_CODE=$(curl -s -o api_keys_prod.json -w "%{http_code}" "${API_KEYS_URL}" || true)
          echo "HTTP Status: ${HTTP_CODE}"
          if [ "${HTTP_CODE}" != "200" ]; then
            echo "âŒ Unable to retrieve API key status (expected 200)."; cat api_keys_prod.json || true; exit 1; fi
          echo "Raw response:"; cat api_keys_prod.json
          echo "Evaluating key states (fail on unresolved-keyvault / placeholder; warn on missing)..."
          if grep -q '"status"[[:space:]]*:[[:space:]]*"unresolved-keyvault"' api_keys_prod.json; then
            echo "âŒ Found disallowed status 'unresolved-keyvault'"; exit 1; fi
          if grep -q '"status"[[:space:]]*:[[:space:]]*"placeholder"' api_keys_prod.json; then
            echo "âŒ Found disallowed status 'placeholder'"; exit 1; fi
          if grep -q '"status"[[:space:]]*:[[:space:]]*"missing"' api_keys_prod.json; then
            echo "âš ï¸  One or more keys are missing (allowed but degraded fallback will be used)"; fi
          echo "âœ… API key configuration validation (Prod) completed."

      - name: Job Summary (Deploy Prod)
        if: always()
        run: |
          {
            echo "## ðŸš€ Deploy Prod Job Summary";
            echo "**Overall Job Status:** ${{ job.status }}";
            echo "**Image:** ${{ steps.load-image.outputs.container_image }}";
            echo "**API Image:** ${{ steps.load-image-api.outputs.container_image_api }}";
            echo "**MCP Image:** ${{ steps.load-image-mcp.outputs.container_image_mcp }}";
            if [ -f api_keys_prod.json ]; then
              echo "\n### API Key Status (raw excerpt)";
              cat api_keys_prod.json | head -100;
            else
              echo "\n_No API key status file captured._";
            fi
          } >> "$GITHUB_STEP_SUMMARY"

  security-scan:
    runs-on: [self-hosted, linux, x64]
    needs: build
    name: Security Scan
    if: github.event_name == 'pull_request'
    permissions:
      contents: read
      security-events: write
      actions: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download build outputs
        uses: actions/download-artifact@v4
        with:
          name: build-outputs
          path: build-outputs/

      - name: Load container image from artifact
        id: load-image
        run: |
          if [ -f "build-outputs/container-image.txt" ]; then
            CONTAINER_IMAGE=$(cat build-outputs/container-image.txt)
            echo "Container image from artifact: '${CONTAINER_IMAGE}'"
            echo "container_image=${CONTAINER_IMAGE}" >> "$GITHUB_OUTPUT"
          else
            echo "ERROR: container-image.txt not found in artifacts!"
            exit 1
          fi

      - name: Run Trivy vulnerability scanner
        # Skipping remote Trivy scan here â€” we will consume SARIF artifacts produced during the build job.
        run: echo "Skipping remote Trivy scan; will use SARIF artifacts from build job"

      - name: Download Trivy SARIF artifacts
        uses: actions/download-artifact@v4
        with:
          name: trivy-sarif
          path: build-outputs/
      
      - name: Detect SARIF files
        id: check-sarif
        run: |
          UI_SARIF="build-outputs/trivy-ui.sarif"
          API_SARIF="build-outputs/trivy-api.sarif"
          MCP_SARIF="build-outputs/trivy-mcp.sarif"
          FOUND_UI=false
          FOUND_API=false
          FOUND_MCP=false
          if [ -f "$UI_SARIF" ]; then FOUND_UI=true; fi
          if [ -f "$API_SARIF" ]; then FOUND_API=true; fi
          if [ -f "$MCP_SARIF" ]; then FOUND_MCP=true; fi
          echo "found_ui=$FOUND_UI" >> "$GITHUB_OUTPUT"
          echo "found_api=$FOUND_API" >> "$GITHUB_OUTPUT"
          echo "found_mcp=$FOUND_MCP" >> "$GITHUB_OUTPUT"

      - name: Upload Trivy UI SARIF to GitHub Security tab
        if: ${{ steps.check-sarif.outputs.found_ui == 'true' }}
        uses: github/codeql-action/upload-sarif@v3
        env:
          GITHUB_TOKEN: ${{ secrets.SARIF_UPLOAD_TOKEN }}
        with:
          sarif_file: build-outputs/trivy-ui.sarif
          category: trivy-ui
 
      - name: Upload Trivy API SARIF to GitHub Security tab
        if: ${{ steps.check-sarif.outputs.found_api == 'true' }}
        uses: github/codeql-action/upload-sarif@v3
        env:
          GITHUB_TOKEN: ${{ secrets.SARIF_UPLOAD_TOKEN }}
        with:
          sarif_file: build-outputs/trivy-api.sarif
          category: trivy-api
 
      - name: Upload Trivy MCP SARIF to GitHub Security tab
        if: ${{ steps.check-sarif.outputs.found_mcp == 'true' }}
        uses: github/codeql-action/upload-sarif@v3
        env:
          GITHUB_TOKEN: ${{ secrets.SARIF_UPLOAD_TOKEN }}
        with:
          sarif_file: build-outputs/trivy-mcp.sarif
          category: trivy-mcp

      - name: Job Summary (Security Scan)
        if: always()
        run: |
          {
            echo "## ðŸ”’ Security Scan Job Summary";
            echo "**Overall Job Status:** ${{ job.status }}";
            echo "**Images Scanned:** ${{ needs.build.outputs.image }} (plus API & MCP)";
            if [ -f build-outputs/trivy-ui.sarif ]; then echo "- UI SARIF present"; else echo "- UI SARIF missing"; fi
            if [ -f build-outputs/trivy-api.sarif ]; then echo "- API SARIF present"; else echo "- API SARIF missing"; fi
            if [ -f build-outputs/trivy-mcp.sarif ]; then echo "- MCP SARIF present"; else echo "- MCP SARIF missing"; fi
            echo "\n> Review SARIF results in the Security tab for detailed vulnerability information.";
          } >> "$GITHUB_STEP_SUMMARY"
