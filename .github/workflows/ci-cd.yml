name: CI/CD Pipeline

on:
  # push:
  #   branches: [main, develop]
  #   paths-ignore:
  #     - '**.md'
  #     - '**/README.md'
  #     - 'docs/**'
  #     - '*.txt'
  #     - '.gitignore'
  #     - '.vscode/**'
  #     - '.vs/**'
  #     - '.azuredevops/**'
  #     #- '.github/**'
  #     - 'AGENTS.md'
  #     - 'LICENSE'
  # pull_request:
  #   branches: [main]
  #   paths-ignore:
  #     - '**.md'
  #     - '**/README.md'
  #     - 'docs/**'
  #     - '*.txt'
  #     - '.gitignore'
  #     - '.vscode/**'
  #     - '.vs/**'
  #     - '.azuredevops/**'
  #     #- '.github/**'
  #     - 'AGENTS.md'
  #     - 'LICENSE'
  # CI triggers temporarily disabled; manual runs only
  workflow_dispatch:
    inputs:
      environment:
        description: "Environment to deploy to"
        required: true
        default: "dev"
        type: choice
        options:
          - dev
          - prod
      instanceNumber:
        description: 'Instance number for resource differentiation'
        required: true
        default: '002'
        type: string

env:
  AZURE_WEBAPP_PACKAGE_PATH: "."
  DOTNET_VERSION: "9.0.x"

jobs:
  test:
    runs-on: ubuntu-latest
    name: Test Application

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}


      - name: Restore dependencies
        run: dotnet restore

      - name: Build application
        run: dotnet build --no-restore --configuration Release

      - name: Setup SQL Server for testing
        uses: potatoqualitee/mssqlsuite@v1.7
        with:
          install: sqlengine, sqlclient
          version: 2022
          sa-password: "YourStrong@Passw0rd"
          show-log: true

      - name: Wait for SQL Server to start
        run: sleep 30

      - name: Warm up EF Core (ensure context can connect without migrations)
        run: |
          cd ai-stock-trade-app
          export ConnectionStrings__DefaultConnection="Server=localhost;Database=StockTrackerTest;User Id=sa;Password=YourStrong@Passw0rd;TrustServerCertificate=true;Encrypt=false"
          dotnet exec /usr/share/dotnet/sdk/$(dotnet --version)/Roslyn/builtins/../csc.dll >/dev/null 2>&1 || true
        env:
          ConnectionStrings__DefaultConnection: "Server=localhost;Database=StockTrackerTest;User Id=sa;Password=YourStrong@Passw0rd;TrustServerCertificate=true;Encrypt=false"

      - name: Run tests
        run: dotnet test --no-build --configuration Release --verbosity normal --filter "FullyQualifiedName!~UITests"
        env:
          ConnectionStrings__DefaultConnection: "Server=localhost;Database=StockTrackerTest;User Id=sa;Password=YourStrong@Passw0rd;TrustServerCertificate=true;Encrypt=false"

  ui-test:
    runs-on: ubuntu-latest
    needs: test
    name: UI Tests with Playwright

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}


      - name: Restore dependencies
        run: dotnet restore

      - name: Build application
        run: dotnet build --no-restore --configuration Release

      - name: Setup SQL Server for UI testing
        uses: potatoqualitee/mssqlsuite@v1.7
        with:
          install: sqlengine, sqlclient
          version: 2022
          sa-password: "YourStrong@Passw0rd"
          show-log: true

      - name: Wait for SQL Server to start
        run: sleep 30

      - name: Warm up EF Core (UI test DB no migrations)
        run: |
          cd ai-stock-trade-app
          export ConnectionStrings__DefaultConnection="Server=localhost;Database=StockTrackerTestUI;User Id=sa;Password=YourStrong@Passw0rd;TrustServerCertificate=true;Encrypt=false"
          dotnet --info > /dev/null
        env:
          ConnectionStrings__DefaultConnection: "Server=localhost;Database=StockTrackerTestUI;User Id=sa;Password=YourStrong@Passw0rd;TrustServerCertificate=true;Encrypt=false"

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Install Playwright browsers
        run: |
          npx playwright install
          npx playwright install-deps

      - name: Start application in background
        run: |
          cd ai-stock-trade-app
          dotnet run --no-build --configuration Release --no-launch-profile &
          APP_PID=$!
          echo "APP_PID=${APP_PID}" >> $GITHUB_ENV
          echo "Started application with PID: ${APP_PID}"
        env:
          ASPNETCORE_ENVIRONMENT: "Development"
          ASPNETCORE_URLS: "http://localhost:5000"
          ConnectionStrings__DefaultConnection: "Server=localhost;Database=StockTrackerTestUI;User Id=sa;Password=YourStrong@Passw0rd;TrustServerCertificate=true;Encrypt=false"
          USE_INMEMORY_DB: "true" # Use EF in-memory provider for faster UI tests (auto-start logic also supports this)

      - name: Wait for application to be ready
        run: |
          echo "Waiting for application to start..."
          timeout=60
          while [ $timeout -gt 0 ]; do
            if curl -f http://localhost:5000 >/dev/null 2>&1; then
              echo "Application is ready!"
              break
            fi
            echo "Waiting for application... ($timeout seconds remaining)"
            sleep 2
            timeout=$((timeout-2))
          done
          
          if [ $timeout -le 0 ]; then
            echo "Application failed to start within timeout"
            exit 1
          fi

      - name: List UI Tests to be executed
        run: dotnet test ai-stock-trade-app.UITests --list-tests --verbosity normal --filter "FullyQualifiedName~UITests"

      - name: Run Playwright UI Tests
        run: |
          echo "Starting UI test execution..."
          dotnet test ai-stock-trade-app.UITests --no-build --configuration Release --verbosity normal --filter "FullyQualifiedName~UITests" --logger "trx;LogFileName=ui-test-results.trx" --settings ./test.runsettings
          echo "UI test execution completed with exit code: $?"
        timeout-minutes: 25
        env:
          PLAYWRIGHT_BASE_URL: "http://localhost:5000"
          ASPNETCORE_ENVIRONMENT: "Development"
          ConnectionStrings__DefaultConnection: "Server=localhost;Database=StockTrackerTestUI;User Id=sa;Password=YourStrong@Passw0rd;TrustServerCertificate=true;Encrypt=false"
          USE_INMEMORY_DB: "true" # In-memory DB accelerates UI tests and avoids local SQL dependency

      - name: Upload UI Test Results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: ui-test-results
          path: "**/ui-test-results.trx"
          retention-days: 5

      - name: Check application logs on failure
        if: failure()
        run: |
          echo "=== APPLICATION LOGS (last 100 lines) ==="
          # Check if the application is still running
          if pgrep -f "dotnet.*ai-stock-trade-app" > /dev/null; then
            echo "Application is still running"
            ps aux | grep dotnet
          else
            echo "Application is not running"
          fi
          
          echo "=== RECENT SYSTEM LOGS ==="
          journalctl --since "10 minutes ago" | tail -50 || echo "No journalctl available"

      - name: Stop application
        if: always()
        run: |
          if [ ! -z "$APP_PID" ]; then
            echo "Stopping application with PID: $APP_PID"
            kill $APP_PID || true
            sleep 5
          fi
          # Cleanup any remaining dotnet processes
          pkill -f "dotnet.*ai-stock-trade-app" || true

  build:
    runs-on: ubuntu-latest
    needs: [test, ui-test]
    name: Build and Push Container
    outputs:
      image: ${{ steps.final-output.outputs.image }}
      test_output: ${{ steps.final-output.outputs.test_output }}

    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Azure Login for Registry Access
        uses: azure/login@v2
        with:
          client-id: ${{ vars.AZURE_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}

      - name: Get Container Registry Information
        id: registry
        run: |
          # Always use dev environment container registry (shared across all environments)
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            INSTANCE_NUM="${{ github.event.inputs.instanceNumber }}"
            echo "Workflow dispatch detected - Instance: ${INSTANCE_NUM}"
          else
            INSTANCE_NUM="002"
            echo "Branch push detected - Using default instance: ${INSTANCE_NUM}"
          fi
          
          # Always target dev resource group for container registry
          ENV="dev"
          RG_NAME="rg-aistock-${ENV}-${INSTANCE_NUM}"
          
          echo "=== BUILD ENVIRONMENT INFO ==="
          echo "Container Registry Environment: ${ENV} (shared registry)"
          echo "Instance Number: ${INSTANCE_NUM}"
          echo "Registry Resource Group: ${RG_NAME}"
          echo "GitHub Ref: ${{ github.ref }}"
          echo "Event Name: ${{ github.event_name }}"
          
          # Get container registry name from dev resource group
          REGISTRY_NAME=$(az acr list --resource-group "${RG_NAME}" --query '[0].name' --output tsv)
          
          if [ -z "${REGISTRY_NAME}" ] || [ "${REGISTRY_NAME}" == "null" ]; then
            echo "ERROR: No container registry found in resource group ${RG_NAME}"
            echo "Available resource groups:"
            az group list --query '[].name' --output table
            echo "This might mean the dev infrastructure hasn't been deployed yet for instance ${INSTANCE_NUM}"
            echo "Please deploy dev environment first to create the shared container registry."
            exit 1
          fi
          
          echo "Found shared registry: ${REGISTRY_NAME}"
          echo "registry_name=${REGISTRY_NAME}" >> $GITHUB_OUTPUT
          echo "resource_group=${RG_NAME}" >> $GITHUB_OUTPUT
          echo "environment=${ENV}" >> $GITHUB_OUTPUT
          echo "instance_number=${INSTANCE_NUM}" >> $GITHUB_OUTPUT

      - name: Get Container Registry Credentials
        id: registry-creds
        run: |
          REGISTRY_NAME="${{ steps.registry.outputs.registry_name }}"
          RG_NAME="${{ steps.registry.outputs.resource_group }}"
          
          # Get admin credentials
          REGISTRY_USERNAME=$(az acr credential show --name "${REGISTRY_NAME}" --query 'username' --output tsv)
          REGISTRY_PASSWORD=$(az acr credential show --name "${REGISTRY_NAME}" --query 'passwords[0].value' --output tsv)
          
          echo "Registry Username: ${REGISTRY_USERNAME}"
          echo "Password length: ${#REGISTRY_PASSWORD}"
          
          echo "registry_username=${REGISTRY_USERNAME}" >> $GITHUB_OUTPUT
          echo "registry_password=${REGISTRY_PASSWORD}" >> $GITHUB_OUTPUT

      - name: Debug Registry Information
        run: |
          echo "=== REGISTRY DEBUG INFO ==="
          echo "Target Environment: ${{ steps.registry.outputs.environment }}"
          echo "Instance Number: ${{ steps.registry.outputs.instance_number }}"
          echo "Registry name: ${{ steps.registry.outputs.registry_name }}"
          echo "Resource group: ${{ steps.registry.outputs.resource_group }}"
          echo "Registry URL: ${{ steps.registry.outputs.registry_name }}.azurecr.io"
          echo "Username: ${{ steps.registry-creds.outputs.registry_username }}"
          echo "Password available: ${{ steps.registry-creds.outputs.registry_password != '' }}"
          echo "=== TRIGGER INFO ==="
          echo "GitHub Ref: ${{ github.ref }}"
          echo "Event Name: ${{ github.event_name }}"
          echo "Workflow Dispatch Environment: ${{ github.event.inputs.environment || 'N/A' }}"
          echo "Workflow Dispatch Instance: ${{ github.event.inputs.instanceNumber || 'N/A' }}"

      - name: Log in to Azure Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ steps.registry.outputs.registry_name }}.azurecr.io
          username: ${{ steps.registry-creds.outputs.registry_username }}
          password: ${{ steps.registry-creds.outputs.registry_password }}

      - name: Verify Docker login
        run: |
          echo "Docker login successful"
          echo "Registry: ${{ steps.registry.outputs.registry_name }}.azurecr.io"

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ steps.registry.outputs.registry_name }}.azurecr.io/ai-stock-trade-app
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix=sha-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Debug metadata outputs
        run: |
          echo "=== METADATA STEP DEBUG ==="
          echo "Meta step ID: meta"
          echo "Meta outputs (JSON): ${{ toJson(steps.meta.outputs) }}"
          echo "Meta tags raw:"
          echo '${{ steps.meta.outputs.tags }}'
          echo "Meta version: '${{ steps.meta.outputs.version }}'"
          echo "=== END METADATA DEBUG ==="

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: ./ai-stock-trade-app
          file: ./ai-stock-trade-app/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}

      - name: Extract and set container image for deployment
        id: final-output
        run: |
          set -e  # Exit on any error
          echo "=== COMBINED EXTRACT AND OUTPUT STEP ==="
          
          # Get tags from metadata step using heredoc to preserve newlines
          echo "Attempting to read metadata tags..."
          TAGS=$(cat << 'EOFTAGS'
          ${{ steps.meta.outputs.tags }}
          EOFTAGS
          )
          
          echo "Raw TAGS captured:"
          echo "---START TAGS---"
          echo "${TAGS}"
          echo "---END TAGS---"
          echo "Number of tags: $(echo "${TAGS}" | wc -l)"
          
          # Check if TAGS is empty or contains only whitespace
          if [ -z "$(echo "${TAGS}" | tr -d ' \t\n\r')" ]; then
            echo "ERROR: No tags received from metadata step or only whitespace!"
            echo "Meta step outputs: ${{ toJson(steps.meta.outputs) }}"
            exit 1
          fi
          
          # Find SHA tag (preferred for deployment) - handle multiline properly
          echo "Searching for SHA tag..."
          SHA_TAG=$(echo "${TAGS}" | grep -E "sha-[a-f0-9]+" | head -1 | tr -d '\n\r' | xargs)
          echo "SHA_TAG search result: '${SHA_TAG}'"
          echo "SHA_TAG length: ${#SHA_TAG}"
          
          if [ -n "${SHA_TAG}" ]; then
            echo "Found SHA tag: ${SHA_TAG}"
            DEPLOY_IMAGE="${SHA_TAG}"
          else
            echo "No SHA tag found, using first tag..."
            # Fallback to first tag - strip whitespace and newlines
            DEPLOY_IMAGE=$(echo "${TAGS}" | head -1 | tr -d '\n\r' | xargs)
            echo "Using first tag: ${DEPLOY_IMAGE}"
          fi
          
          echo "=== SETTING OUTPUTS AND ARTIFACTS ==="
          echo "Final deployment image: '${DEPLOY_IMAGE}'"
          echo "DEPLOY_IMAGE length: ${#DEPLOY_IMAGE}"
          
          # Check if DEPLOY_IMAGE is empty
          if [ -z "${DEPLOY_IMAGE}" ]; then
            echo "ERROR: DEPLOY_IMAGE is empty after processing!"
            echo "This means the tag processing failed"
            exit 1
          fi
          
          # Write to artifact file for reliable transfer
          echo "=== CREATING ARTIFACT ==="
          mkdir -p build-outputs
          echo "${DEPLOY_IMAGE}" > build-outputs/container-image.txt
          echo "hello-from-combined-step" > build-outputs/test-output.txt
          
          echo "Artifact files created:"
          ls -la build-outputs/
          echo "Container image file contents:"
          cat build-outputs/container-image.txt
          echo "Test output file contents:"
          cat build-outputs/test-output.txt
          
          # Also try traditional GitHub outputs as backup
          echo "=== BACKUP GITHUB OUTPUT ==="
          echo "image=${DEPLOY_IMAGE}" >> "$GITHUB_OUTPUT"
          echo "test_output=hello-from-combined-step" >> "$GITHUB_OUTPUT"
          
          echo "GITHUB_OUTPUT contents:"
          cat "$GITHUB_OUTPUT"
          
          echo "=== END COMBINED STEP ==="
          
      - name: Upload build outputs as artifact
        uses: actions/upload-artifact@v4
        with:
          name: build-outputs
          path: build-outputs/
          retention-days: 1
          
      - name: Test final output
        run: |
          echo "=== FINAL OUTPUT TEST ==="
          echo "Can we read the final output immediately?"
          echo "Final step - Image: ${{ steps.final-output.outputs.image }}"
          echo "Final step - Test: ${{ steps.final-output.outputs.test_output }}"
          
      - name: Final verification
        run: |
          echo "=== FINAL VERIFICATION ==="
          echo "Final step outputs:"
          echo "  Image: ${{ steps.final-output.outputs.image }}"
          echo "  Test: ${{ steps.final-output.outputs.test_output }}"
          echo "=== JOB OUTPUTS WILL BE ==="
          echo "image: ${{ steps.final-output.outputs.image }}"
          echo "test_output: ${{ steps.final-output.outputs.test_output }}"

  deploy-dev:
    runs-on: ubuntu-latest
    needs: build
    name: Deploy to Development
    if: github.ref == 'refs/heads/develop' || (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'dev')
    environment: ${{ github.event_name == 'workflow_dispatch' && format('development-{0}', github.event.inputs.instanceNumber) || 'development-002' }}

    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download build outputs
        uses: actions/download-artifact@v4
        with:
          name: build-outputs
          path: build-outputs/

      - name: Load container image from artifact
        id: load-image
        run: |
          echo "=== LOADING CONTAINER IMAGE FROM ARTIFACT ==="
          if [ -f "build-outputs/container-image.txt" ]; then
            CONTAINER_IMAGE=$(cat build-outputs/container-image.txt)
            echo "Container image from artifact: '${CONTAINER_IMAGE}'"
            echo "container_image=${CONTAINER_IMAGE}" >> "$GITHUB_OUTPUT"
          else
            echo "ERROR: container-image.txt not found in artifacts!"
            ls -la build-outputs/
            exit 1
          fi

      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ vars.AZURE_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}

      - name: Deploy Bicep template
        uses: azure/arm-deploy@v1
        with:
          subscriptionId: ${{ vars.AZURE_SUBSCRIPTION_ID }}
          resourceGroupName: ${{ github.event_name == 'workflow_dispatch' && format('rg-aistock-dev-{0}', github.event.inputs.instanceNumber) || 'rg-aistock-dev-002' }}
          template: ./ai-stock-trade-app/infrastructure/main.bicep
          parameters: ./ai-stock-trade-app/infrastructure/parameters.dev.json instanceNumber=${{ github.event_name == 'workflow_dispatch' && github.event.inputs.instanceNumber || '002' }} containerImage=${{ steps.load-image.outputs.container_image }} alphaVantageApiKey=${{ secrets.ALPHA_VANTAGE_API_KEY }} twelveDataApiKey=${{ secrets.TWELVE_DATA_API_KEY }} sqlAdminPassword=${{ secrets.SQL_ADMIN_PASSWORD }}
          failOnStdErr: false

      - name: Verify SQL Admin matches Web App Managed Identity (Dev)
        run: |
          set -e
          INSTANCE_NUM="${{ github.event_name == 'workflow_dispatch' && github.event.inputs.instanceNumber || '002' }}"
          RG_NAME="rg-aistock-dev-${INSTANCE_NUM}"
            WEBAPP_NAME="app-aistock-dev-${INSTANCE_NUM}"
          SQL_SERVER_NAME="sql-aistock-dev-${INSTANCE_NUM}"
          echo "🔍 Verifying Dev SQL AD admin is web app MI"
          MI_PRINCIPAL_ID=$(az webapp identity show --name "$WEBAPP_NAME" --resource-group "$RG_NAME" --query principalId -o tsv 2>/dev/null || echo "")
          if [ -z "$MI_PRINCIPAL_ID" ] || [ "$MI_PRINCIPAL_ID" = "null" ]; then echo "❌ Web app MI principalId not found"; exit 1; fi
          ADMIN_LOGIN=$(az sql server ad-admin list --server "$SQL_SERVER_NAME" --resource-group "$RG_NAME" --query "[0].login" -o tsv 2>/dev/null || echo "")
          ADMIN_SID=$(az sql server ad-admin list --server "$SQL_SERVER_NAME" --resource-group "$RG_NAME" --query "[0].sid" -o tsv 2>/dev/null || echo "")
          echo "Web App MI: $MI_PRINCIPAL_ID"; echo "Current Admin login: $ADMIN_LOGIN"; echo "Current Admin sid: $ADMIN_SID"
          if [ -z "$ADMIN_SID" ] || [ "$ADMIN_SID" = "null" ]; then echo "❌ No Azure AD admin configured (expected MI)"; exit 1; fi
          if [ "$ADMIN_SID" != "$MI_PRINCIPAL_ID" ]; then
            echo "❌ Admin sid mismatch (expected=$MI_PRINCIPAL_ID, found=$ADMIN_SID)";
            echo "Remediation: Run infra workflow or manually: az sql server ad-admin delete --server $SQL_SERVER_NAME --resource-group $RG_NAME && az sql server ad-admin create --server $SQL_SERVER_NAME --resource-group $RG_NAME --display-name $WEBAPP_NAME --object-id $MI_PRINCIPAL_ID"; exit 1; fi
          echo "✅ Dev SQL admin matches web app MI."

      - name: Setup .NET for migrations
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Install Entity Framework tools
        run: dotnet tool install --global dotnet-ef

      - name: Run database migrations
        run: |
          INSTANCE_NUM="${{ github.event_name == 'workflow_dispatch' && github.event.inputs.instanceNumber || '002' }}"
          RG_NAME="rg-aistock-dev-${INSTANCE_NUM}"
          
          echo "Getting SQL Server connection details..."
          
          # Try to get connection string from Key Vault, but don't fail if access is denied
          KEY_VAULT_NAME="kv-aistock-dev-${INSTANCE_NUM}"
          CONNECTION_STRING=$(az keyvault secret show --vault-name "${KEY_VAULT_NAME}" --name "SqlConnectionString" --query "value" --output tsv 2>/dev/null || echo "")
          
          if [ -z "${CONNECTION_STRING}" ]; then
            echo "INFO: Could not retrieve connection string from Key Vault (permission may not be configured yet)."
            echo "Database migrations will run automatically on first app startup."
            echo "This is normal for first-time deployments."
          else
            echo "Running database migrations manually..."
            cd ai-stock-trade-app
            export ConnectionStrings__DefaultConnection="${CONNECTION_STRING}"
            dotnet ef database update --verbose
          fi

      - name: Update Web App Container
        run: |
          INSTANCE_NUM="${{ github.event_name == 'workflow_dispatch' && github.event.inputs.instanceNumber || '002' }}"
          WEBAPP_NAME="app-aistock-dev-${INSTANCE_NUM}"
          RG_NAME="rg-aistock-dev-${INSTANCE_NUM}"
          
          # Get registry information from the same resource group
          REGISTRY_NAME=$(az acr list --resource-group "${RG_NAME}" --query '[0].name' --output tsv)
          REGISTRY_USERNAME=$(az acr credential show --name "${REGISTRY_NAME}" --query 'username' --output tsv)
          REGISTRY_PASSWORD=$(az acr credential show --name "${REGISTRY_NAME}" --query 'passwords[0].value' --output tsv)
          
          echo "Container Image: ${{ steps.load-image.outputs.container_image }}"
          echo "Web App Name: ${WEBAPP_NAME}"
          echo "Resource Group: ${RG_NAME}"
          echo "Registry Name: ${REGISTRY_NAME}"
          
          if [ -z "${{ steps.load-image.outputs.container_image }}" ]; then
            echo "ERROR: Container image is empty!"
            exit 1
          fi
          
          az webapp config container set \
            --name "${WEBAPP_NAME}" \
            --resource-group "${RG_NAME}" \
            --container-image-name "${{ steps.load-image.outputs.container_image }}" \
            --container-registry-url "https://${REGISTRY_NAME}.azurecr.io" \
            --container-registry-user "${REGISTRY_USERNAME}" \
            --container-registry-password "${REGISTRY_PASSWORD}"

      - name: Run Health Check
        run: |
          INSTANCE_NUM="${{ github.event_name == 'workflow_dispatch' && github.event.inputs.instanceNumber || '002' }}"
          WEBAPP_NAME="app-aistock-dev-${INSTANCE_NUM}"
          HEALTH_URL="https://${WEBAPP_NAME}.azurewebsites.net/health"
          echo "Waiting for deployment to be ready..."
          echo "Health check URL: ${HEALTH_URL}"
          sleep 30
          curl -f "${HEALTH_URL}" || exit 1
          echo "Health check passed!"

  deploy-prod:
    runs-on: ubuntu-latest
    needs: [build, deploy-dev]
    name: Deploy to Production
    if: |
      always() && 
      (needs.build.result == 'success') &&
      (needs.deploy-dev.result == 'success' || needs.deploy-dev.result == 'skipped') &&
      (github.ref == 'refs/heads/main' || (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'prod'))
    environment: ${{ github.event_name == 'workflow_dispatch' && format('production-{0}', github.event.inputs.instanceNumber) || 'production-002' }}

    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download build outputs
        uses: actions/download-artifact@v4
        with:
          name: build-outputs
          path: build-outputs/

      - name: Load container image from artifact
        id: load-image
        run: |
          echo "=== LOADING CONTAINER IMAGE FROM ARTIFACT ==="
          if [ -f "build-outputs/container-image.txt" ]; then
            CONTAINER_IMAGE=$(cat build-outputs/container-image.txt)
            echo "Container image from artifact: '${CONTAINER_IMAGE}'"
            echo "container_image=${CONTAINER_IMAGE}" >> "$GITHUB_OUTPUT"
          else
            echo "ERROR: container-image.txt not found in artifacts!"
            ls -la build-outputs/
            exit 1
          fi

      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ vars.AZURE_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}

      - name: Debug Variables
        run: |
          echo "=== DEPLOYMENT DEBUG INFO ==="
          echo "Job name: deploy-prod"
          echo "GitHub ref: ${{ github.ref }}"
          echo "Event name: ${{ github.event_name }}"
          echo "Environment input: ${{ github.event.inputs.environment }}"
          echo "Instance Number: ${{ github.event.inputs.instanceNumber }}"
          INSTANCE_NUM="${{ github.event_name == 'workflow_dispatch' && github.event.inputs.instanceNumber || '002' }}"
          echo "Resolved Instance Number: ${INSTANCE_NUM}"
          echo "Resource Group: rg-aistock-prod-${INSTANCE_NUM}"
          echo "Web App Name: app-aistock-prod-${INSTANCE_NUM}"
          echo "=== BUILD JOB OUTPUTS ==="
          echo "Build job result: ${{ needs.build.result }}"
          echo "Build job outputs: ${{ toJson(needs.build.outputs) }}"
          echo "Container image from needs: ${{ needs.build.outputs.image }}"
          echo "Test output: ${{ needs.build.outputs.test_output }}"
          echo "=== ARTIFACT DATA ==="
          echo "Container image from artifact: ${{ steps.load-image.outputs.container_image }}"
          echo "=== VARIABLES ==="
          echo "Subscription ID: ${{ vars.AZURE_SUBSCRIPTION_ID }}"
          echo "Container Image: ${{ steps.load-image.outputs.container_image }}"

      # Removed service principal-based SQL admin override. Infrastructure workflow already sets
      # the SQL Server Azure AD admin to the web app managed identity. We keep that and detect
      # Azure AD-only capability later.

      - name: Deploy Bicep template (AAD-only capable)
        uses: azure/arm-deploy@v1
        with:
          subscriptionId: ${{ vars.AZURE_SUBSCRIPTION_ID }}
          resourceGroupName: ${{ github.event_name == 'workflow_dispatch' && format('rg-aistock-prod-{0}', github.event.inputs.instanceNumber) || 'rg-aistock-prod-002' }}
          template: ./ai-stock-trade-app/infrastructure/main.bicep
          # Pass sqlAdminPassword to avoid accidental blanking; also surface enableAzureAdOnlyAuth if AAD admin already established.
          # For GitHub we infer enabling AAD-only via an input/secret flag (ENABLE_AAD_ONLY_AUTH) or default to true for prod to standardize.
          # Currently leaving enableAzureAdOnlyAuth=false until AZURE_AD_ADMIN_* values are explicitly provided.
          # To enable AAD-only auth: define repository variables AZURE_AD_ADMIN_OBJECT_ID + AZURE_AD_ADMIN_LOGIN then replace enableAzureAdOnlyAuth=false below with true and include those values.
          parameters: ./ai-stock-trade-app/infrastructure/parameters.prod.json instanceNumber=${{ github.event_name == 'workflow_dispatch' && github.event.inputs.instanceNumber || '002' }} containerImage=${{ steps.load-image.outputs.container_image }} alphaVantageApiKey=${{ secrets.ALPHA_VANTAGE_API_KEY }} twelveDataApiKey=${{ secrets.TWELVE_DATA_API_KEY }} sqlAdminPassword=${{ secrets.SQL_ADMIN_PASSWORD }} enableAzureAdOnlyAuth=false
          failOnStdErr: false

      - name: Verify SQL Admin matches Web App Managed Identity (Prod)
        run: |
          set -e
          INSTANCE_NUM="${{ github.event_name == 'workflow_dispatch' && github.event.inputs.instanceNumber || '002' }}"
          RG_NAME="rg-aistock-prod-${INSTANCE_NUM}"
          WEBAPP_NAME="app-aistock-prod-${INSTANCE_NUM}"
          SQL_SERVER_NAME="sql-aistock-prod-${INSTANCE_NUM}"

          echo "🔍 Verifying Azure SQL Server AD admin is web app managed identity"
          MI_PRINCIPAL_ID=$(az webapp identity show --name "$WEBAPP_NAME" --resource-group "$RG_NAME" --query principalId -o tsv 2>/dev/null || echo "")
          if [ -z "$MI_PRINCIPAL_ID" ] || [ "$MI_PRINCIPAL_ID" = "null" ]; then
            echo "❌ Managed identity principalId not found for web app $WEBAPP_NAME"; exit 1; fi

          ADMIN_LOGIN=$(az sql server ad-admin list --server "$SQL_SERVER_NAME" --resource-group "$RG_NAME" --query "[0].login" -o tsv 2>/dev/null || echo "")
          ADMIN_SID=$(az sql server ad-admin list --server "$SQL_SERVER_NAME" --resource-group "$RG_NAME" --query "[0].sid" -o tsv 2>/dev/null || echo "")

          echo "Web App MI principalId: $MI_PRINCIPAL_ID"
          echo "Current SQL Admin login: $ADMIN_LOGIN"
          echo "Current SQL Admin sid:   $ADMIN_SID"

          if [ -z "$ADMIN_SID" ] || [ "$ADMIN_SID" = "null" ]; then
            echo "❌ No Azure AD admin configured on SQL server (expected web app MI)."; exit 1; fi

          if [ "$ADMIN_SID" != "$MI_PRINCIPAL_ID" ]; then
            echo "❌ SQL admin sid does not match web app MI."
            echo "   Expected: $MI_PRINCIPAL_ID"
            echo "   Found:    $ADMIN_SID (login=$ADMIN_LOGIN)"
            echo "💡 Remediation: Re-run infrastructure workflow to enforce MI admin or manually:"
            echo "   az sql server ad-admin delete --server $SQL_SERVER_NAME --resource-group $RG_NAME || true"
            echo "   az sql server ad-admin create --server $SQL_SERVER_NAME --resource-group $RG_NAME --display-name $WEBAPP_NAME --object-id $MI_PRINCIPAL_ID"
            exit 1
          fi
          echo "✅ SQL admin sid matches web app MI (login=$ADMIN_LOGIN)."

      - name: Setup .NET for migrations
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Install Entity Framework tools
        run: dotnet tool install --global dotnet-ef

      - name: Setup Web App SQL Database Access (Azure AD)
        run: |
          INSTANCE_NUM="${{ github.event_name == 'workflow_dispatch' && github.event.inputs.instanceNumber || '002' }}"
          RG_NAME="rg-aistock-prod-${INSTANCE_NUM}"
          WEBAPP_NAME="app-aistock-prod-${INSTANCE_NUM}"
          SQL_SERVER_NAME="sql-aistock-prod-${INSTANCE_NUM}"
          DATABASE_NAME="sqldb-aistock-prod-${INSTANCE_NUM}"
          # Dynamically detect if Azure AD admin (web app MI) is present
          echo "🔍 Detecting Azure AD admin (expect web app managed identity)..."
          CURRENT_ADMIN_LOGIN=$(az sql server ad-admin list --server "$SQL_SERVER_NAME" --resource-group "$RG_NAME" --query "[0].login" -o tsv 2>/dev/null || echo "")
          CURRENT_ADMIN_SID=$(az sql server ad-admin list --server "$SQL_SERVER_NAME" --resource-group "$RG_NAME" --query "[0].sid" -o tsv 2>/dev/null || echo "")
          WEBAPP_MI_PRINCIPAL=$(az webapp identity show --name "$WEBAPP_NAME" --resource-group "$RG_NAME" --query principalId -o tsv 2>/dev/null || echo "")
          if [ "$CURRENT_ADMIN_SID" = "$WEBAPP_MI_PRINCIPAL" ]; then
            ENABLE_AAD_ONLY=true
            echo "✅ Azure AD admin matches web app MI (login=$CURRENT_ADMIN_LOGIN)"
          else
            ENABLE_AAD_ONLY=false
            echo "⚠️ Azure AD admin does not match web app MI (adminLogin=$CURRENT_ADMIN_LOGIN, adminSid=$CURRENT_ADMIN_SID, mi=$WEBAPP_MI_PRINCIPAL) - skipping MI DB user creation."
          fi
          
          echo "🔧 Setting up SQL Database access for Web App managed identity..."
          echo "Web App: ${WEBAPP_NAME}"
          echo "SQL Server: ${SQL_SERVER_NAME}"
          echo "Database: ${DATABASE_NAME}"
          echo "enableAzureAdOnlyAuth flag: ${ENABLE_AAD_ONLY}"

          if [ "${ENABLE_AAD_ONLY}" != "true" ]; then
            echo "⚠️ Azure AD only auth disabled (no admin present). Skipping managed identity user creation step."
            exit 0
          fi
          
          # First, verify the web app managed identity is enabled
          echo "🔍 Verifying web app managed identity..."
          MANAGED_IDENTITY=$(az webapp identity show --name "${WEBAPP_NAME}" --resource-group "${RG_NAME}" --query "principalId" --output tsv 2>/dev/null || echo "")
          
          if [ -z "${MANAGED_IDENTITY}" ] || [ "${MANAGED_IDENTITY}" == "null" ]; then
            echo "⚠️ Web app managed identity not found. Enabling it..."
            az webapp identity assign --name "${WEBAPP_NAME}" --resource-group "${RG_NAME}"
            sleep 10  # Wait for identity propagation
            MANAGED_IDENTITY=$(az webapp identity show --name "${WEBAPP_NAME}" --resource-group "${RG_NAME}" --query "principalId" --output tsv)
          fi
          
          echo "✅ Web app managed identity ID: ${MANAGED_IDENTITY}"
          
          # Get the SQL Server FQDN
          SQL_SERVER_FQDN="${SQL_SERVER_NAME}.database.windows.net"
          
          echo "🔐 Attempting to create SQL user for managed identity..."
          
          # Install sqlcmd tools
          echo "Installing sqlcmd..."
          curl https://packages.microsoft.com/keys/microsoft.asc | sudo apt-key add -
          curl https://packages.microsoft.com/config/ubuntu/20.04/prod.list | sudo tee /etc/apt/sources.list.d/msprod.list
          sudo apt-get update
          sudo apt-get install -y mssql-tools unixodbc-dev
          
          echo "Testing basic connectivity to SQL Server..."
          if ! timeout 10 bash -c "</dev/tcp/${SQL_SERVER_NAME}.database.windows.net/1433" 2>/dev/null; then
            echo "❌ Cannot connect to SQL Server on port 1433. Check firewall rules."
            exit 1
          else
            echo "✅ SQL Server is reachable on port 1433"
          fi
          
          echo "Attempting to create managed identity user in SQL database (simplified)..."

          CREATE_USER_SQL="IF NOT EXISTS (SELECT 1 FROM sys.database_principals WHERE name = '${WEBAPP_NAME}') BEGIN PRINT 'Creating user ${WEBAPP_NAME}'; CREATE USER [${WEBAPP_NAME}] FROM EXTERNAL PROVIDER; END ELSE PRINT 'User ${WEBAPP_NAME} already exists';"
          ASSIGN_ROLES_SQL="DECLARE @u sysname='${WEBAPP_NAME}'; DECLARE @r TABLE(n sysname); INSERT INTO @r VALUES('db_datareader'),('db_datawriter'),('db_ddladmin'); DECLARE c CURSOR LOCAL FAST_FORWARD FOR SELECT n FROM @r; OPEN c; DECLARE @n sysname; FETCH NEXT FROM c INTO @n; WHILE @@FETCH_STATUS=0 BEGIN IF IS_ROLEMEMBER(@n,@u)=1 PRINT @n+' already assigned'; ELSE BEGIN DECLARE @sql nvarchar(300)=N'ALTER ROLE '+QUOTENAME(@n)+' ADD MEMBER '+QUOTENAME(@u)+';'; PRINT 'Assigning '+@n; EXEC(@sql); END; FETCH NEXT FROM c INTO @n; END CLOSE c; DEALLOCATE c;"
          FINAL_QUERY="${CREATE_USER_SQL} ${ASSIGN_ROLES_SQL} SELECT dp.name AS principal_name,r.name AS role_name FROM sys.database_principals dp JOIN sys.database_role_members rm ON dp.principal_id=rm.member_principal_id JOIN sys.database_principals r ON rm.role_principal_id=r.principal_id WHERE dp.name='${WEBAPP_NAME}';"

          echo "Executing SQL (length: ${#FINAL_QUERY}) with retry logic"

          MAX_RETRIES=5
          SLEEP_SECONDS=20
          attempt=1
          SUCCESS=0
          while [ $attempt -le $MAX_RETRIES ]; do
            echo "Attempt $attempt of $MAX_RETRIES..."
            if /opt/mssql-tools/bin/sqlcmd -S "${SQL_SERVER_FQDN}" -d "${DATABASE_NAME}" -G -l 30 -Q "${FINAL_QUERY}"; then
              echo "✅ Successfully executed SQL script for managed identity setup on attempt $attempt"
              SUCCESS=1
              break
            else
              echo "❌ Attempt $attempt failed"
              if [ $attempt -lt $MAX_RETRIES ]; then
                echo "Waiting ${SLEEP_SECONDS}s before retry..."
                sleep $SLEEP_SECONDS
              fi
            fi
            attempt=$((attempt+1))
          done

          if [ $SUCCESS -eq 1 ]; then
            echo "Testing managed identity connection..."
            cat > test_connection.sql << 'TEST_SQL_END'
          SELECT 
              USER_NAME() as current_user,
              SYSTEM_USER as system_user,
              DB_NAME() as database_name,
              GETDATE() as current_time;
          TEST_SQL_END
            if /opt/mssql-tools/bin/sqlcmd -S "${SQL_SERVER_FQDN}" -d "${DATABASE_NAME}" -G -l 30 -i test_connection.sql; then
              echo "Connection test successful"
            else
              echo "Connection test failed, but user creation may have succeeded"
            fi
          else
            echo "⚠️ All $MAX_RETRIES attempts to create the managed identity user failed."
            echo "Manual Steps Required:"
            echo "  1. Connect to SQL Server as an Azure AD admin"
            echo "  2. Run the following commands:"
            echo "     USE [${DATABASE_NAME}];"
            echo "     CREATE USER [${WEBAPP_NAME}] FROM EXTERNAL PROVIDER;"
            echo "     ALTER ROLE db_datareader ADD MEMBER [${WEBAPP_NAME}];"
            echo "     ALTER ROLE db_datawriter ADD MEMBER [${WEBAPP_NAME}];"
            echo "     ALTER ROLE db_ddladmin ADD MEMBER [${WEBAPP_NAME}];"
            echo "Proceeding without blocking deployment. Application may have DB access issues until resolved."
          fi

      - name: Run database migrations
        run: |
          INSTANCE_NUM="${{ github.event_name == 'workflow_dispatch' && github.event.inputs.instanceNumber || '002' }}"
          RG_NAME="rg-aistock-prod-${INSTANCE_NUM}"
          
          echo "🗄️ Checking database migration options..."
          echo "Resource Group: ${RG_NAME}"
          
          # Try to get connection string from Key Vault, but don't fail if access is denied
          KEY_VAULT_NAME="kv-aistock-prod-${INSTANCE_NUM}"
          echo "Attempting to retrieve connection string from Key Vault: ${KEY_VAULT_NAME}"
          
          CONNECTION_STRING=$(az keyvault secret show --vault-name "${KEY_VAULT_NAME}" --name "SqlConnectionString" --query "value" --output tsv 2>/dev/null || echo "")
          
          if [ -z "${CONNECTION_STRING}" ]; then
            echo "ℹ️ Could not retrieve connection string from Key Vault."
            echo "This is expected for first-time deployments or when pipeline doesn't have Key Vault access."
            echo ""
            echo "🚀 Database migrations will run automatically on first app startup."
            echo "The application is configured to:"
            echo "  1. Use Azure AD managed identity authentication"
            echo "  2. Run Entity Framework migrations automatically"
            echo "  3. Create necessary database schema"
            echo ""
            echo "✅ Skipping manual migration - letting app handle it during startup"
          else
            echo "✅ Retrieved connection string from Key Vault"
            echo "Connection string type: $(echo "${CONNECTION_STRING}" | grep -o 'Authentication=[^;]*' || echo 'SQL Authentication')"
            
            if echo "${CONNECTION_STRING}" | grep -q "Authentication=Active Directory Default"; then
              echo "🔐 Using Azure AD authentication for migrations"
            else
              echo "🔑 Using SQL authentication for migrations"
            fi
            
            echo "Running database migrations manually..."
            cd ai-stock-trade-app
            export ConnectionStrings__DefaultConnection="${CONNECTION_STRING}"
            
            # Run with verbose output
            echo "Starting Entity Framework migration..."
            dotnet ef database update --verbose
            
            if [ $? -eq 0 ]; then
              echo "✅ Database migrations completed successfully"
            else
              echo "⚠️ Migration failed, but this may be handled during app startup"
            fi
          fi

      - name: Update Web App Container
        run: |
          INSTANCE_NUM="${{ github.event_name == 'workflow_dispatch' && github.event.inputs.instanceNumber || '002' }}"
          WEBAPP_NAME="app-aistock-prod-${INSTANCE_NUM}"
          RG_NAME="rg-aistock-prod-${INSTANCE_NUM}"
          
          # Get registry information from DEV resource group (shared registry)
          DEV_RG_NAME="rg-aistock-dev-${INSTANCE_NUM}"
          REGISTRY_NAME=$(az acr list --resource-group "${DEV_RG_NAME}" --query '[0].name' --output tsv)
          REGISTRY_USERNAME=$(az acr credential show --name "${REGISTRY_NAME}" --query 'username' --output tsv)
          REGISTRY_PASSWORD=$(az acr credential show --name "${REGISTRY_NAME}" --query 'passwords[0].value' --output tsv)
          
          echo "Container Image: ${{ steps.load-image.outputs.container_image }}"
          echo "Web App Name: ${WEBAPP_NAME}"
          echo "Prod Resource Group: ${RG_NAME}"
          echo "Dev Registry Resource Group: ${DEV_RG_NAME}"
          echo "Shared Registry Name: ${REGISTRY_NAME}"
          
          if [ -z "${{ steps.load-image.outputs.container_image }}" ]; then
            echo "ERROR: Container image is empty!"
            exit 1
          fi
          
          az webapp config container set \
            --name "${WEBAPP_NAME}" \
            --resource-group "${RG_NAME}" \
            --container-image-name "${{ steps.load-image.outputs.container_image }}" \
            --container-registry-url "https://${REGISTRY_NAME}.azurecr.io" \
            --container-registry-user "${REGISTRY_USERNAME}" \
            --container-registry-password "${REGISTRY_PASSWORD}"

      - name: Run Health Check
        run: |
          INSTANCE_NUM="${{ github.event_name == 'workflow_dispatch' && github.event.inputs.instanceNumber || '002' }}"
          WEBAPP_NAME="app-aistock-prod-${INSTANCE_NUM}"
          RG_NAME="rg-aistock-prod-${INSTANCE_NUM}"
          echo "[DIAG] Dumping resolved connection string authentication mode before health checks (shared script)..."
          bash ./scripts/sql-conn-auth-dump.sh "$RG_NAME" "$WEBAPP_NAME" || echo "[DIAG] Script execution failed (non-fatal)"
          INSTANCE_NUM="${{ github.event_name == 'workflow_dispatch' && github.event.inputs.instanceNumber || '002' }}"
          WEBAPP_NAME="app-aistock-prod-${INSTANCE_NUM}"
          HEALTH_URL="https://${WEBAPP_NAME}.azurewebsites.net/health"
          BASE_URL="https://${WEBAPP_NAME}.azurewebsites.net"
          
          echo "🏥 Starting comprehensive health check..."
          echo "Base URL: ${BASE_URL}"
          echo "Health URL: ${HEALTH_URL}"
          
          # Wait for initial deployment
          echo "Waiting for deployment to be ready..."
          sleep 60
          
          # Check if the site is accessible at all
          echo "Testing basic site accessibility..."
          for i in {1..5}; do
            if curl -f -s "${BASE_URL}" >/dev/null 2>&1; then
              echo "✅ Site is accessible (attempt $i)"
              break
            else
              echo "⏳ Site not ready yet (attempt $i/5)..."
              sleep 30
            fi
          done
          
          # Check health endpoint specifically
          echo "Testing health endpoint..."
          for i in {1..10}; do
            echo "Health check attempt $i/10..."
            
            # Get detailed response
            HTTP_CODE=$(curl -s -o /tmp/health_response.txt -w "%{http_code}" "${HEALTH_URL}")
            RESPONSE_BODY=$(cat /tmp/health_response.txt 2>/dev/null || echo "No response body")
            
            echo "HTTP Status: ${HTTP_CODE}"
            echo "Response: ${RESPONSE_BODY}"
            
            if [ "${HTTP_CODE}" = "200" ]; then
              echo "✅ Health check passed!"
              echo "Deployment successful and application is healthy."
              exit 0
            elif [ "${HTTP_CODE}" = "503" ] || [ "${HTTP_CODE}" = "500" ]; then
              echo "⚠️ Application error detected (HTTP ${HTTP_CODE})"
              echo "This might be a database connectivity issue."
              
              # Try to get more detailed logs
              echo "Attempting to get application logs..."
              az webapp log tail --name "${WEBAPP_NAME}" --resource-group "rg-aistock-prod-${INSTANCE_NUM}" --timeout 30 || echo "Could not retrieve logs"
              
              if [ $i -eq 10 ]; then
                echo "❌ Health check failed after 10 attempts"
                echo "Last response (HTTP ${HTTP_CODE}): ${RESPONSE_BODY}"
                echo ""
                echo "🔍 Troubleshooting steps:"
                echo "1. Check Azure portal for app service logs"
                echo "2. Verify managed identity SQL user was created"
                echo "3. Check Key Vault access permissions"
                echo "4. Verify SQL Server firewall allows Azure services"
                exit 1
              fi
            else
              echo "⏳ Unexpected response (HTTP ${HTTP_CODE}), retrying..."
            fi
            
            sleep 30
          done
          
          echo "❌ Health check failed - no successful response received"
          exit 1

  security-scan:
    runs-on: ubuntu-latest
    needs: build
    name: Security Scan
    if: github.event_name == 'pull_request'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download build outputs
        uses: actions/download-artifact@v4
        with:
          name: build-outputs
          path: build-outputs/

      - name: Load container image from artifact
        id: load-image
        run: |
          if [ -f "build-outputs/container-image.txt" ]; then
            CONTAINER_IMAGE=$(cat build-outputs/container-image.txt)
            echo "Container image from artifact: '${CONTAINER_IMAGE}'"
            echo "container_image=${CONTAINER_IMAGE}" >> "$GITHUB_OUTPUT"
          else
            echo "ERROR: container-image.txt not found in artifacts!"
            exit 1
          fi

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ steps.load-image.outputs.container_image }}
          format: "sarif"
          output: "trivy-results.sarif"

      - name: Upload Trivy scan results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v2
        with:
          sarif_file: "trivy-results.sarif"
