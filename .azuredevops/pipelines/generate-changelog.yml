# Azure DevOps pipeline: Run Changelog-Weaver with Azure OpenAI
# - Clone Hankanman/Changelog-Weaver
# - Install requirements
# - Create .env (using secure pipeline variables)
# - Run a small wrapper to configure the OpenAI Azure client and execute changelog generation
# - Publish generated markdown as a pipeline artifact
# - Optionally update a GitHub release body when GITHUB_RELEASE_ID is provided

# NOTE: Set the following pipeline variables (in pipeline UI or a variable group) and mark the secrets as secret:
# - AZURE_OPENAI_ENDPOINT
# - AZURE_OPENAI_KEY
# - AZURE_OPENAI_DEPLOYMENT_NAME
# - GITHUB_TOKEN (personal access token or repo token with repo scope to update releases)
# - Optionally: GITHUB_RELEASE_ID (release id to patch)

trigger: none
pr: none

pool:
  - script: |
      set -euo pipefail
      echo "Preparing Azure DevOps Wiki content..."

      # Locate the generated changelog file
      FILE=$(find changelog-weaver -type f -name '*.md' -path '*/Releases/*' | head -n1 || true)
      if [ -z "$FILE" ]; then
        echo "No changelog file found; skipping wiki publish"
        exit 0
      fi

      # Derive release tag/name
      TO_TAG="${BUILD_SOURCEBRANCHNAME:-}"
      if [ -z "$TO_TAG" ]; then TO_TAG="manual"; fi

      # Extract prev tag used earlier if present in .env
      PREV_TAG=$(grep '^FROM_TAG=' changelog-weaver/.env | cut -d'=' -f2 || true)

      # Build combined page content
      DATE_UTC=$(date -u +%Y-%m-%d)
      GH_RELEASE_URL="https://github.com/${BUILD_REPOSITORY_NAME}/releases/tag/${TO_TAG}"
      {
        echo "# Release ${TO_TAG}"
        echo
        echo "- Repository: ${BUILD_REPOSITORY_NAME}"
        echo "- Date: ${DATE_UTC}"
        if [ -n "$PREV_TAG" ]; then echo "- Previous tag: ${PREV_TAG}"; fi
        echo "- GitHub Release: ${GH_RELEASE_URL}"
        echo
        echo "## Changelog"
        echo
        cat "$FILE"
        echo
      } > /tmp/wiki_page.md

      # Setup wiki identifiers
      ORG_URL="${SYSTEM_COLLECTIONURI}"
      PROJECT="${SYSTEM_TEAMPROJECT}"
      WIKI_ID="${WIKI_IDENTIFIER:-${SYSTEM_TEAMPROJECT}.wiki}"
      ROOT_PATH="${WIKI_PATH_ROOT:-/Releases}"
      PAGE_PATH="${ROOT_PATH}/${TO_TAG}"

      # URL-encode the page path safely
      PAGE_PATH_ESC=$(python -c "import urllib.parse,sys;print(urllib.parse.quote(sys.argv[1], safe='/'))" "$PAGE_PATH")

      BASE_API="${ORG_URL%/}/${PROJECT}/_apis/wiki/wikis/${WIKI_ID}"
      GET_URL="${BASE_API}/pages?path=${PAGE_PATH_ESC}&includeContent=true&api-version=7.0"
      PUT_URL="${BASE_API}/pages?path=${PAGE_PATH_ESC}&api-version=7.0"

      echo "Fetching existing wiki page (if any): $GET_URL"

      if [ -z "${SYSTEM_ACCESSTOKEN:-}" ]; then
        echo "System.AccessToken is not available. Enable 'Allow scripts to access OAuth token' and ensure Wiki write permission." >&2
        exit 1
      fi
      # Capture headers to extract ETag if it exists
      HTTP_GET=$(curl -s -D /tmp/wiki_headers.txt -o /tmp/wiki_get.json -w "%{http_code}" \
        -H "Authorization: Bearer ${SYSTEM_ACCESSTOKEN}" \
        - script: |
            set -euo pipefail
            echo "Preparing Azure DevOps Wiki content..."

            # Locate the generated changelog file
            FILE=$(find changelog-weaver -type f -name '*.md' -path '*/Releases/*' | head -n1 || true)
            if [ -z "$FILE" ]; then
              echo "No changelog file found; skipping wiki publish"
              exit 0
            fi

            # Derive release tag/name
            TO_TAG="${BUILD_SOURCEBRANCHNAME:-}"
            if [ -z "$TO_TAG" ]; then TO_TAG="manual"; fi

            # Extract prev tag used earlier if present in .env
            PREV_TAG=$(grep '^FROM_TAG=' changelog-weaver/.env | cut -d'=' -f2 || true)

            # Build combined page content
            DATE_UTC=$(date -u +%Y-%m-%d)
            GH_RELEASE_URL="https://github.com/${BUILD_REPOSITORY_NAME}/releases/tag/${TO_TAG}"
            {
              echo "# Release ${TO_TAG}"
              echo
              echo "- Repository: ${BUILD_REPOSITORY_NAME}"
              echo "- Date: ${DATE_UTC}"
              if [ -n "$PREV_TAG" ]; then echo "- Previous tag: ${PREV_TAG}"; fi
              echo "- GitHub Release: ${GH_RELEASE_URL}"
              echo
              echo "## Changelog"
              echo
              cat "$FILE"
              echo
            } > /tmp/wiki_page.md

            # Setup wiki identifiers
            ORG_URL="${SYSTEM_COLLECTIONURI}"
            PROJECT="${SYSTEM_TEAMPROJECT}"
            WIKI_ID="${WIKI_IDENTIFIER:-${SYSTEM_TEAMPROJECT}.wiki}"
            ROOT_PATH="${WIKI_PATH_ROOT:-/Releases}"
            PAGE_PATH="${ROOT_PATH}/${TO_TAG}"

            # URL-encode the page path safely
            PAGE_PATH_ESC=$(python -c "import urllib.parse,sys;print(urllib.parse.quote(sys.argv[1], safe='/'))" "$PAGE_PATH")

            BASE_API="${ORG_URL%/}/${PROJECT}/_apis/wiki/wikis/${WIKI_ID}"
            GET_URL="${BASE_API}/pages?path=${PAGE_PATH_ESC}&includeContent=true&api-version=7.0"
            PUT_URL="${BASE_API}/pages?path=${PAGE_PATH_ESC}&api-version=7.0"

            echo "Fetching existing wiki page (if any): $GET_URL"

            if [ -z "${SYSTEM_ACCESSTOKEN:-}" ]; then
              echo "System.AccessToken is not available. Enable 'Allow scripts to access OAuth token' and ensure Wiki write permission." >&2
              exit 1
            fi
            # Capture headers to extract ETag if it exists
            HTTP_GET=$(curl -s -D /tmp/wiki_headers.txt -o /tmp/wiki_get.json -w "%{http_code}" \
              -H "Authorization: Bearer ${SYSTEM_ACCESSTOKEN}" \
              -H "Content-Type: application/json" \
              "$GET_URL" || true)
            echo "GET status: $HTTP_GET"

            ETAG=$(grep -i '^etag:' /tmp/wiki_headers.txt | awk '{print $2}' | tr -d '\r\n' || true)
            if [ -z "$ETAG" ]; then
              ETAG=$(python -c "import json,io,sys; d=json.load(io.open('/tmp/wiki_get.json','r',encoding='utf-8')); print(str(d.get('eTag') or d.get('etag') or '')) if isinstance(d,dict) else print('')" 2>/dev/null || echo "")
            fi

            CONTENT_JSON=$(python -c "import json,io; print(json.dumps({'content': io.open('/tmp/wiki_page.md','r',encoding='utf-8').read()}))")

            echo "Publishing wiki page to: $PUT_URL"
            if [ "$HTTP_GET" = "200" ] && [ -n "$ETAG" ]; then
              # Update existing page with concurrency control
              HTTP_PUT=$(curl -s -o /tmp/wiki_put.json -w "%{http_code}" -X PUT \
                -H "Authorization: Bearer ${SYSTEM_ACCESSTOKEN}" \
                -H "Content-Type: application/json" \
                -H "If-Match: $ETAG" \
                --data "$CONTENT_JSON" \
                "$PUT_URL")
            else
              # Create new page
              HTTP_PUT=$(curl -s -o /tmp/wiki_put.json -w "%{http_code}" -X PUT \
                -H "Authorization: Bearer ${SYSTEM_ACCESSTOKEN}" \
                -H "Content-Type: application/json" \
                --data "$CONTENT_JSON" \
                "$PUT_URL")
            fi

            echo "PUT status: $HTTP_PUT"
            head -c 500 /tmp/wiki_put.json || true

            if [ "$HTTP_PUT" != "200" ] && [ "$HTTP_PUT" != "201" ]; then
              echo "Wiki publish failed" >&2
              exit 1
            fi
            echo "Wiki publish succeeded"
      if p.exists():
          s = p.read_text()
          old = 'self.client = openai.OpenAI(api_key=api_details.key)'
          if old in s:
              s = s.replace(old, 'openai.api_key = api_details.key\n        self.client = openai')
              p.write_text(s)
              print('Patched model.py to use module-level openai')
          else:
              print('Patch not required or already applied')
      else:
          print('model.py not found; skipping patch')
      PY
    displayName: "Patch Changelog-Weaver model for Azure"

  - script: |
      set -euo pipefail
      cd changelog-weaver
      # Ensure Releases/<owner> exists so the generator can write output
      OWNER=${BUILD_REPOSITORY_NAME%%/*}
      if [ -z "$OWNER" ]; then
        OWNER="${BUILD_REPOSITORY_NAME:-}"
      fi
      mkdir -p "Releases/$OWNER"
      python run_changelog.py
    displayName: "Run Changelog-Weaver"
    env:
      ACCESS_TOKEN: $(GITHUB_TOKEN)
      REPO_NAME: $(Build.Repository.Name)
      BRANCH: main
      GPT_API_KEY: $(AZURE_OPENAI_KEY)
      MODEL_BASE_URL: $(AZURE_OPENAI_ENDPOINT)
      MODEL: $(AZURE_OPENAI_DEPLOYMENT_NAME)
      OPENAI_API_BASE: $(AZURE_OPENAI_ENDPOINT)
      OPENAI_BASE_URL: $(AZURE_OPENAI_ENDPOINT)
      OPENAI_API_KEY: $(AZURE_OPENAI_KEY)
      OPENAI_API_TYPE: azure
      OPENAI_API_VERSION: 2023-10-01-preview
      AZURE_OPENAI_ENDPOINT: $(AZURE_OPENAI_ENDPOINT)
      AZURE_OPENAI_KEY: $(AZURE_OPENAI_KEY)

  - script: |
      mkdir -p "$(Build.ArtifactStagingDirectory)/changelog"
      find changelog-weaver -type f -name '*.md' -path '*/Releases/*' -exec cp {} "$(Build.ArtifactStagingDirectory)/changelog/" \;
      ls -la "$(Build.ArtifactStagingDirectory)/changelog" || true
    displayName: "Gather generated changelog files"

  - task: PublishPipelineArtifact@1
    inputs:
      targetPath: "$(Build.ArtifactStagingDirectory)/changelog"
      artifact: "changelog"
    displayName: "Publish changelog artifact"

  - script: |
      set -euo pipefail
      echo "Preparing Azure DevOps Wiki content..."

      # Locate the generated changelog file
      FILE=$(find changelog-weaver -type f -name '*.md' -path '*/Releases/*' | head -n1 || true)
      if [ -z "$FILE" ]; then
        echo "No changelog file found; skipping wiki publish"
        exit 0
      fi

      # Derive release tag/name
      TO_TAG="${BUILD_SOURCEBRANCHNAME:-}"
      if [ -z "$TO_TAG" ]; then TO_TAG="manual"; fi

      # Extract prev tag used earlier if present in .env
      PREV_TAG=$(grep '^FROM_TAG=' changelog-weaver/.env | cut -d'=' -f2 || true)

      # Build combined page content
      DATE_UTC=$(date -u +%Y-%m-%d)
      GH_RELEASE_URL="https://github.com/${BUILD_REPOSITORY_NAME}/releases/tag/${TO_TAG}"
      {
        echo "# Release ${TO_TAG}"
        echo
        echo "- Repository: ${BUILD_REPOSITORY_NAME}"
        echo "- Date: ${DATE_UTC}"
        if [ -n "$PREV_TAG" ]; then echo "- Previous tag: ${PREV_TAG}"; fi
        echo "- GitHub Release: ${GH_RELEASE_URL}"
        echo
        echo "## Changelog"
        echo
        cat "$FILE"
        echo
      } > /tmp/wiki_page.md

      # Setup wiki identifiers
      ORG_URL="${SYSTEM_COLLECTIONURI}"
      PROJECT="${SYSTEM_TEAMPROJECT}"
      WIKI_ID="${WIKI_IDENTIFIER:-${SYSTEM_TEAMPROJECT}.wiki}"
      ROOT_PATH="${WIKI_PATH_ROOT:-/Releases}"
      PAGE_PATH="${ROOT_PATH}/${TO_TAG}"

      # URL-encode the page path safely
      PAGE_PATH_ESC=$(python -c 'import urllib.parse,sys;print(urllib.parse.quote(sys.argv[1], safe="/"))' "$PAGE_PATH")

      BASE_API="${ORG_URL%/}/${PROJECT}/_apis/wiki/wikis/${WIKI_ID}"
      GET_URL="${BASE_API}/pages?path=${PAGE_PATH_ESC}&includeContent=true&api-version=7.0"
      PUT_URL="${BASE_API}/pages?path=${PAGE_PATH_ESC}&api-version=7.0"

      echo "Fetching existing wiki page (if any): $GET_URL"

      if [ -z "${SYSTEM_ACCESSTOKEN:-}" ]; then
        echo "System.AccessToken is not available. Ensure 'Allow scripts to access OAuth token' is enabled and the pipeline has permission to write to Wiki." >&2
        exit 1
      fi
      # Capture headers to extract ETag if it exists
      HTTP_GET=$(curl -s -D /tmp/wiki_headers.txt -o /tmp/wiki_get.json -w "%{http_code}" \
        -H "Authorization: Bearer ${SYSTEM_ACCESSTOKEN}" \
        -H "Content-Type: application/json" \
        "$GET_URL") || true
      echo "GET status: $HTTP_GET"

      ETAG=$(grep -i '^etag:' /tmp/wiki_headers.txt | awk '{print $2}' | tr -d '\r\n' || true)
      if [ -z "$ETAG" ]; then
        # Some Wiki APIs return eTag in the JSON body instead of header; try that as a fallback
        ETAG=$(python -c "import json,io; d=json.load(io.open('/tmp/wiki_get.json','r',encoding='utf-8')); print(str(d.get('eTag') or d.get('etag') or '')) if isinstance(d,dict) else print('')" 2>/dev/null || echo "")
      fi

      CONTENT_JSON=$(python -c "import json,io; print(json.dumps({'content': io.open('/tmp/wiki_page.md','r',encoding='utf-8').read()}))")

      echo "Publishing wiki page to: $PUT_URL"
      if [ "$HTTP_GET" = "200" ] && [ -n "$ETAG" ]; then
        # Update existing page with concurrency control
        HTTP_PUT=$(curl -s -o /tmp/wiki_put.json -w "%{http_code}" -X PUT \
          -H "Authorization: Bearer ${SYSTEM_ACCESSTOKEN}" \
          -H "Content-Type: application/json" \
          -H "If-Match: $ETAG" \
          --data "$CONTENT_JSON" \
          "$PUT_URL")
      else
        # Create new page
        HTTP_PUT=$(curl -s -o /tmp/wiki_put.json -w "%{http_code}" -X PUT \
          -H "Authorization: Bearer ${SYSTEM_ACCESSTOKEN}" \
          -H "Content-Type: application/json" \
          --data "$CONTENT_JSON" \
          "$PUT_URL")
      fi

      echo "PUT status: $HTTP_PUT"
      head -c 500 /tmp/wiki_put.json || true

      if [ "$HTTP_PUT" != "200" ] && [ "$HTTP_PUT" != "201" ]; then
        echo "Wiki publish failed" >&2
        exit 1
      fi
      echo "Wiki publish succeeded"
    displayName: "Publish release to Azure DevOps Wiki"
    env:
      SYSTEM_COLLECTIONURI: $(System.CollectionUri)
      SYSTEM_TEAMPROJECT: $(System.TeamProject)
      SYSTEM_ACCESSTOKEN: $(System.AccessToken)
      WIKI_IDENTIFIER: $(WIKI_IDENTIFIER)
      WIKI_PATH_ROOT: $(WIKI_PATH_ROOT)

  - script: |
      if [ -n "${GITHUB_RELEASE_ID:-}" ]; then
        FILE=$(find changelog-weaver -type f -name '*.md' -path '*/Releases/*' | head -n1 || true)
        if [ -z "$FILE" ]; then
          echo "No changelog file found to attach to release"
          exit 0
        fi

        BODY=$(python -c 'import sys,json; print(json.dumps(open(sys.argv[1],"r",encoding="utf-8").read()))' "$FILE")
        if [ -z "$BODY" ] || [ "$BODY" = '""' ]; then
          echo "Empty changelog; skipping release patch"
          exit 0
        fi

        PAYLOAD=$(printf '{"body": %s}' "$BODY")
        echo "Patching GitHub release id: ${GITHUB_RELEASE_ID}"
        curl -s -X PATCH \
          -H "Authorization: token ${GITHUB_TOKEN}" \
          -H "Content-Type: application/json" \
          -d "$PAYLOAD" \
          "https://api.github.com/repos/$(Build.Repository.Name)/releases/${GITHUB_RELEASE_ID}" -o /tmp/resp.json -w "%{http_code}"
        cat /tmp/resp.json || true
      else
        echo "GITHUB_RELEASE_ID not set; skipping release patch"
      fi
    displayName: "Optionally update GitHub release body"
    condition: and(succeeded(), ne(variables['GITHUB_RELEASE_ID'], ''))
