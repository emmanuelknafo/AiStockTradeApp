# Azure DevOps pipeline: Run Changelog-Weaver with Azure OpenAI
# - Clone Hankanman/Changelog-Weaver
# - Install requirements
# - Create .env (using secure pipeline variables)
# - Run a small wrapper to configure the OpenAI Azure client and execute changelog generation
# - Publish generated markdown as a pipeline artifact
# - Optionally update a GitHub release body when GITHUB_RELEASE_ID is provided

# NOTE: Set the following pipeline variables (in pipeline UI or a variable group) and mark the secrets as secret:
# - AZURE_OPENAI_ENDPOINT
# - AZURE_OPENAI_KEY
# - AZURE_OPENAI_DEPLOYMENT_NAME
# - GITHUB_TOKEN (personal access token or repo token with repo scope to update releases)
# - Optionally: GITHUB_RELEASE_ID (release id to patch)

trigger: none
pr: none

pool:
  vmImage: "ubuntu-latest"

variables:
  - group: "AiStockTradeApp"
    # # Variables below are expected to be set in the pipeline configuration or variable group
    # AZURE_OPENAI_ENDPOINT: $(AZURE_OPENAI_ENDPOINT)
    # AZURE_OPENAI_KEY: $(AZURE_OPENAI_KEY)
    # AZURE_OPENAI_DEPLOYMENT_NAME: $(AZURE_OPENAI_DEPLOYMENT_NAME)
    # GITHUB_TOKEN: $(GITHUB_TOKEN)
    # # You can optionally set GITHUB_RELEASE_ID to patch an existing GitHub release
    # GITHUB_RELEASE_ID: $(GITHUB_RELEASE_ID)

steps:
  - checkout: self
    persistCredentials: true

  - task: UsePythonVersion@0
    inputs:
      versionSpec: "3.x"
    displayName: "Use Python 3.x"

  - script: |
      git clone --depth 1 https://github.com/Hankanman/Changelog-Weaver.git changelog-weaver
    displayName: "Clone Changelog-Weaver"

  - script: |
      python -m pip install --upgrade pip
      python -m pip install -r changelog-weaver/requirements.txt
    displayName: "Install Changelog-Weaver dependencies"

  - script: |
      set -euo pipefail
      TO_TAG="${BUILD_SOURCEBRANCHNAME:-}"
      # When pipeline is manually run there may be no branch name; allow overriding with a variable if needed
      if [ -z "$TO_TAG" ]; then
        TO_TAG="manual"
      fi

      cd changelog-weaver
      # Ensure tags are available for prev-tag detection
      git fetch --tags --quiet || true
      PREV_TAG=$(git tag --sort=-creatordate | grep -v "^${TO_TAG}$" | head -n1 || echo "v0.0.0")

      echo "SOLUTION_NAME=${BUILD_REPOSITORY_NAME:-}" > .env
      echo "RELEASE_VERSION=${TO_TAG}" >> .env
      echo "SOFTWARE_SUMMARY=Release ${TO_TAG}" >> .env
      echo "GET_ITEM_SUMMARY=True" >> .env
      echo "GET_CHANGELOG_SUMMARY=True" >> .env
      echo "INCLUDE_COMMITS=False" >> .env
      echo "PROJECT_URL=https://github.com/${BUILD_REPOSITORY_NAME:-}" >> .env
      echo "QUERY=is:closed" >> .env
      echo "ACCESS_TOKEN=${GITHUB_TOKEN:-}" >> .env
      echo "REPO_NAME=${BUILD_REPOSITORY_NAME:-}" >> .env
      echo "BRANCH=wikiMaster" >> .env
      echo "FROM_TAG=${PREV_TAG}" >> .env
      echo "TO_TAG=${TO_TAG}" >> .env

      # Azure OpenAI configuration (set as pipeline variables/secrets)
      echo "GPT_API_KEY=${AZURE_OPENAI_KEY:-}" >> .env
      echo "MODEL_BASE_URL=${AZURE_OPENAI_ENDPOINT:-}" >> .env
      echo "MODEL=${AZURE_OPENAI_DEPLOYMENT_NAME:-}" >> .env

      echo "OUTPUT_FOLDER=Releases" >> .env
      echo "LOG_LEVEL=INFO" >> .env

      # Also add OPENAI_* and AZURE_* variants expected by various client versions
      echo "OPENAI_API_BASE=${AZURE_OPENAI_ENDPOINT:-}" >> .env
      echo "OPENAI_API_KEY=${AZURE_OPENAI_KEY:-}" >> .env
      echo "OPENAI_API_TYPE=azure" >> .env
      echo "OPENAI_API_VERSION=2023-10-01-preview" >> .env

      echo "AZURE_OPENAI_ENDPOINT=${AZURE_OPENAI_ENDPOINT:-}" >> .env
      echo "AZURE_OPENAI_KEY=${AZURE_OPENAI_KEY:-}" >> .env

      echo ".env generated at $(pwd)/.env"
    displayName: "Create .env for Changelog-Weaver"
    env:
      AZURE_OPENAI_ENDPOINT: $(AZURE_OPENAI_ENDPOINT)
      AZURE_OPENAI_DEPLOYMENT_NAME: $(AZURE_OPENAI_DEPLOYMENT_NAME)
      AZURE_OPENAI_KEY: $(AZURE_OPENAI_KEY)
      GITHUB_TOKEN: $(GITHUB_TOKEN)

  - script: |
      cat > changelog-weaver/run_changelog.py <<'PY'
      import os
      from dotenv import load_dotenv
      load_dotenv('.env')
      import openai
      import sys
      print('=== Azure/OpenAI env diagnostics ===')
      print('MODEL_BASE_URL:', os.getenv('MODEL_BASE_URL'))
      print('OPENAI_API_BASE:', os.getenv('OPENAI_API_BASE'))
      print('OPENAI_API_TYPE:', os.getenv('OPENAI_API_TYPE'))
      print('OPENAI_API_VERSION:', os.getenv('OPENAI_API_VERSION'))
      key = os.getenv('OPENAI_API_KEY', os.getenv('GPT_API_KEY', ''))
      print('OPENAI_API_KEY set:', bool(key))
      if key:
          print('OPENAI_API_KEY preview:', key[:8] + '...')
      sys.stdout.flush()

      openai.api_type = os.getenv('OPENAI_API_TYPE', '')
      openai.api_base = os.getenv('OPENAI_API_BASE', os.getenv('MODEL_BASE_URL', ''))
      openai.api_version = os.getenv('OPENAI_API_VERSION', '')
      openai.api_key = key

      print('Resolved openai.api_base:', getattr(openai, 'api_base', None))
      print('Resolved openai.api_key set:', bool(getattr(openai, 'api_key', None)))
      sys.stdout.flush()

      from changelog_weaver.changelog import main as main_function
      import asyncio
      asyncio.run(main_function())
      PY
    displayName: "Prepare run_changelog.py wrapper"

  - script: |
      set -euo pipefail
      echo "Masked env diagnostics (presence + masked preview):"
      dump() {
        name="$1"
        value="$(printenv "$name" || true)"
        if [ -z "$value" ]; then
          echo "$name: <missing>"
        else
          echo "$name: ${value:0:6}***"
        fi
      }
      echo "BUILD_REPOSITORY_NAME: ${BUILD_REPOSITORY_NAME:-<missing>}"
      dump AZURE_OPENAI_ENDPOINT
      dump AZURE_OPENAI_DEPLOYMENT_NAME
      dump AZURE_OPENAI_KEY
      dump GITHUB_TOKEN
      echo "---- end diagnostics ----"
    displayName: "Masked env diagnostics"
    env:
      AZURE_OPENAI_ENDPOINT: $(AZURE_OPENAI_ENDPOINT)
      AZURE_OPENAI_DEPLOYMENT_NAME: $(AZURE_OPENAI_DEPLOYMENT_NAME)
      AZURE_OPENAI_KEY: $(AZURE_OPENAI_KEY)
      GITHUB_TOKEN: $(GITHUB_TOKEN)

  - script: |
      set -euo pipefail
      echo "Running Azure OpenAI pre-flight test..."
      AZ_BASE="${AZURE_OPENAI_ENDPOINT:-}"
      AZ_DEPLOY="${AZURE_OPENAI_DEPLOYMENT_NAME:-}"
      AZ_KEY="${AZURE_OPENAI_KEY:-}"

      if [ -z "$AZ_BASE" ] || [ -z "$AZ_DEPLOY" ] || [ -z "$AZ_KEY" ]; then
        echo "Missing AZURE_OPENAI_ENDPOINT, AZURE_OPENAI_DEPLOYMENT_NAME or AZURE_OPENAI_KEY; failing pre-flight."
        exit 1
      fi

      HTTP_CODE=$(curl -s -o /tmp/aztest.json -w "%{http_code}" -X POST "$AZ_BASE/openai/deployments/$AZ_DEPLOY/chat/completions?api-version=2023-10-01-preview" \
        -H "Content-Type: application/json" \
        -H "api-key: $AZ_KEY" \
        -d '{"messages":[{"role":"user","content":"ping"}],"max_tokens":1}')

      if [ "$HTTP_CODE" != "200" ]; then
        echo "Azure OpenAI pre-flight failed (HTTP $HTTP_CODE):"
        head -c 1000 /tmp/aztest.json || true
        exit 1
      fi
      echo "Azure OpenAI pre-flight succeeded (HTTP $HTTP_CODE)."
      head -c 200 /tmp/aztest.json || true
    displayName: "Azure OpenAI pre-flight test"
    env:
      AZURE_OPENAI_ENDPOINT: $(AZURE_OPENAI_ENDPOINT)
      AZURE_OPENAI_DEPLOYMENT_NAME: $(AZURE_OPENAI_DEPLOYMENT_NAME)
      AZURE_OPENAI_KEY: $(AZURE_OPENAI_KEY)
      GITHUB_TOKEN: $(GITHUB_TOKEN)

  - script: |
      python - <<'PY'
      from pathlib import Path
      p = Path('changelog-weaver/changelog_weaver/configuration/model.py')
      if p.exists():
          s = p.read_text()
          old = 'self.client = openai.OpenAI(api_key=api_details.key)'
          if old in s:
              s = s.replace(old, 'openai.api_key = api_details.key\n        self.client = openai')
              p.write_text(s)
              print('Patched model.py to use module-level openai')
          else:
              print('Patch not required or already applied')
      else:
          print('model.py not found; skipping patch')
      PY
    displayName: "Patch Changelog-Weaver model for Azure"

  - script: |
      set -euo pipefail
      cd changelog-weaver
      # Ensure Releases/<owner> exists so the generator can write output
      OWNER=${BUILD_REPOSITORY_NAME%%/*}
      if [ -z "$OWNER" ]; then
        OWNER="${BUILD_REPOSITORY_NAME:-}"
      fi
      mkdir -p "Releases/$OWNER"
      python run_changelog.py
    displayName: "Run Changelog-Weaver"
    env:
      ACCESS_TOKEN: $(GITHUB_TOKEN)
      REPO_NAME: $(Build.Repository.Name)
      BRANCH: wikiMaster
      GPT_API_KEY: $(AZURE_OPENAI_KEY)
      MODEL_BASE_URL: $(AZURE_OPENAI_ENDPOINT)
      MODEL: $(AZURE_OPENAI_DEPLOYMENT_NAME)
      OPENAI_API_BASE: $(AZURE_OPENAI_ENDPOINT)
      OPENAI_BASE_URL: $(AZURE_OPENAI_ENDPOINT)
      OPENAI_API_KEY: $(AZURE_OPENAI_KEY)
      OPENAI_API_TYPE: azure
      OPENAI_API_VERSION: 2023-10-01-preview
      AZURE_OPENAI_ENDPOINT: $(AZURE_OPENAI_ENDPOINT)
      AZURE_OPENAI_KEY: $(AZURE_OPENAI_KEY)

  - script: |
      mkdir -p "$(Build.ArtifactStagingDirectory)/changelog"
      find changelog-weaver -type f -name '*.md' -path '*/Releases/*' -exec cp {} "$(Build.ArtifactStagingDirectory)/changelog/" \;
      ls -la "$(Build.ArtifactStagingDirectory)/changelog" || true
    displayName: "Gather generated changelog files"

  - task: PublishPipelineArtifact@1
    inputs:
      targetPath: "$(Build.ArtifactStagingDirectory)/changelog"
      artifact: "changelog"
    displayName: "Publish changelog artifact"

  - script: |
      if [ -n "${GITHUB_RELEASE_ID:-}" ]; then
        FILE=$(find changelog-weaver -type f -name '*.md' -path '*/Releases/*' | head -n1 || true)
        if [ -z "$FILE" ]; then
          echo "No changelog file found to attach to release"
          exit 0
        fi

        BODY=$(python -c 'import sys,json; print(json.dumps(open(sys.argv[1],"r",encoding="utf-8").read()))' "$FILE")
        if [ -z "$BODY" ] || [ "$BODY" = '""' ]; then
          echo "Empty changelog; skipping release patch"
          exit 0
        fi

        PAYLOAD=$(printf '{"body": %s}' "$BODY")
        echo "Patching GitHub release id: ${GITHUB_RELEASE_ID}"
        curl -s -X PATCH \
          -H "Authorization: token ${GITHUB_TOKEN}" \
          -H "Content-Type: application/json" \
          -d "$PAYLOAD" \
          "https://api.github.com/repos/$(Build.Repository.Name)/releases/${GITHUB_RELEASE_ID}" -o /tmp/resp.json -w "%{http_code}"
        cat /tmp/resp.json || true
      else
        echo "GITHUB_RELEASE_ID not set; skipping release patch"
      fi
    displayName: "Optionally update GitHub release body"
    condition: and(succeeded(), ne(variables['GITHUB_RELEASE_ID'], ''))

  - script: |
      set -euo pipefail
      FILE=$(find changelog-weaver -type f -name '*.md' -path '*/Releases/*' | head -n1 || true)
      if [ -n "$FILE" ]; then
        echo "Changelog found: $FILE"
        echo "##vso[task.setvariable variable=HasChangelog]true"
      else
        echo "No changelog found; Wiki publish will be skipped"
        echo "##vso[task.setvariable variable=HasChangelog]false"
      fi
    displayName: "Detect changelog presence for Wiki"

  - script: |
      set -euo pipefail
      echo "Preparing Azure DevOps Wiki content..."

      # Locate the generated changelog file (prefer original location)
      FILE=$(find changelog-weaver -type f -name '*.md' -path '*/Releases/*' | head -n1 || true)
      if [ -z "$FILE" ]; then
        echo "No changelog file found; skipping wiki publish"
        exit 0
      fi

      # Derive release tag/name
      TO_TAG="${BUILD_SOURCEBRANCHNAME:-}"
      if [ -z "$TO_TAG" ]; then TO_TAG="manual"; fi

      # Extract prev tag used earlier if present in .env
      PREV_TAG=$(grep '^FROM_TAG=' changelog-weaver/.env | cut -d'=' -f2 || true)

      # Build combined page content
      DATE_UTC=$(date -u +%Y-%m-%d)
      GH_RELEASE_URL="https://github.com/${BUILD_REPOSITORY_NAME}/releases/tag/${TO_TAG}"
      {
        echo "# Release ${TO_TAG}"
        echo
        echo "- Repository: ${BUILD_REPOSITORY_NAME}"
        echo "- Date: ${DATE_UTC}"
        if [ -n "$PREV_TAG" ]; then echo "- Previous tag: ${PREV_TAG}"; fi
        echo "- GitHub Release: ${GH_RELEASE_URL}"
        echo
        echo "## Changelog"
        echo
        cat "$FILE"
        echo
      } > /tmp/wiki_page.md

      # Setup wiki identifiers
      ORG_URL="${SYSTEM_COLLECTIONURI}"
      PROJECT="${SYSTEM_TEAMPROJECT}"
      # Resolve WIKI_IDENTIFIER robustly by querying the list of wikis and preferring the project's wiki
      RAW_WIKI="${WIKI_IDENTIFIER:-}"
      WIKI_ID=""
      WIKI_NAME=""
      # If user provided an identifier (GUID or name), trust it and skip discovery
      if [ -n "$RAW_WIKI" ] && [[ ! "$RAW_WIKI" == *'$('* ]]; then
        # Trim quotes, braces and spaces
        RW_TRIM=$(printf "%s" "$RAW_WIKI" | sed -e 's/^\s*[\"{]\?//' -e 's/[\"}]\?\s*$//')
        WIKI_ID="$RW_TRIM"
        echo "Using WIKI_IDENTIFIER directly: $WIKI_ID"
      else
        LIST_URL="${ORG_URL%/}/${PROJECT}/_apis/wiki/wikis?api-version=7.0"
        echo "Listing wikis: $LIST_URL"
        HTTP_LIST=$(curl -s -o /tmp/wiki_list.json -w "%{http_code}" \
          -H "Authorization: Bearer ${SYSTEM_ACCESSTOKEN}" \
          -H "Content-Type: application/json" \
          "$LIST_URL" || true)
        echo "LIST status: $HTTP_LIST"
        COUNT=$(jq -r '(.count // (.value|length)) // 0' /tmp/wiki_list.json 2>/dev/null || echo 0)
        if [ "$HTTP_LIST" != "200" ] || [ "$COUNT" = "0" ]; then
          # Fallback 1: organization-level list
          LIST_URL_ALT="${ORG_URL%/}/_apis/wiki/wikis?api-version=7.0"
          echo "Primary list empty; trying org-level: $LIST_URL_ALT"
          HTTP_LIST=$(curl -s -o /tmp/wiki_list.json -w "%{http_code}" \
            -H "Authorization: Bearer ${SYSTEM_ACCESSTOKEN}" \
            -H "Content-Type: application/json" \
            "$LIST_URL_ALT" || true)
          echo "ORG LIST status: $HTTP_LIST"
          COUNT=$(jq -r '(.count // (.value|length)) // 0' /tmp/wiki_list.json 2>/dev/null || echo 0)
        fi
        if [ "$HTTP_LIST" = "200" ] && [ "$COUNT" = "0" ] && [ -n "${SYSTEM_TEAMPROJECTID:-}" ]; then
          # Fallback 2: projectId-scoped list
          LIST_URL_ID="${ORG_URL%/}/${SYSTEM_TEAMPROJECTID}/_apis/wiki/wikis?api-version=7.0"
          echo "Org list empty; trying projectId-scoped: $LIST_URL_ID"
          HTTP_LIST=$(curl -s -o /tmp/wiki_list.json -w "%{http_code}" \
            -H "Authorization: Bearer ${SYSTEM_ACCESSTOKEN}" \
            -H "Content-Type: application/json" \
            "$LIST_URL_ID" || true)
          echo "ID LIST status: $HTTP_LIST"
        fi
        if [ "$HTTP_LIST" = "200" ]; then
          # Normalize RAW_WIKI (trim quotes/spaces)
          if [ -n "$RAW_WIKI" ] && [[ ! "$RAW_WIKI" == *'$('* ]]; then
            RW_TRIM=$(printf "%s" "$RAW_WIKI" | sed -e 's/^\s*\"\?//' -e 's/\"\?\s*$//')
            # Try to match by GUID id, repositoryId, or name (case-insensitive); always take the object's .id (GUID)
            WIKI_ID=$(jq -r --arg rw "$RW_TRIM" '
              ([.value[]
                | select((.id//"")==$rw or (.repositoryId//"")==$rw or ((.name//"")|ascii_downcase)==($rw|ascii_downcase))
                | .id] | first) // ""' /tmp/wiki_list.json)
            WIKI_NAME=$(jq -r --arg rw "$RW_TRIM" '
              ([.value[]
                | select((.id//"")==$rw or (.repositoryId//"")==$rw or ((.name//"")|ascii_downcase)==($rw|ascii_downcase))
                | .name] | first) // ""' /tmp/wiki_list.json)
          fi
          # If still not resolved, prefer the project wiki entry
          if [ -z "$WIKI_ID" ] || [ "$WIKI_ID" = "null" ]; then
            WIKI_ID=$(jq -r '([.value[] | select(.type=="projectWiki") | .id] | first) // (.value[0].id // "")' /tmp/wiki_list.json)
            WIKI_NAME=$(jq -r '([.value[] | select(.type=="projectWiki") | .name] | first) // (.value[0].name // "")' /tmp/wiki_list.json)
          fi
        fi
      fi
      # If still not resolved, fail fast with diagnostics rather than using name (which can 404)
      if [ -z "$WIKI_ID" ] || [ "$WIKI_ID" = "null" ]; then
        echo "Could not resolve Wiki GUID from list. Contents of /tmp/wiki_list.json:" >&2
        head -c 2000 /tmp/wiki_list.json || true
        echo >&2
        echo "Set a valid WIKI_IDENTIFIER (GUID) or ensure the Project Wiki exists." >&2
        exit 1
      fi
      # Resolve ROOT_PATH similarly, default to /Releases
      RAW_ROOT="${WIKI_PATH_ROOT:-}"
      if [ -z "$RAW_ROOT" ] || [[ "$RAW_ROOT" == *'$('* ]]; then
        ROOT_PATH="/Releases"
      else
        ROOT_PATH="$RAW_ROOT"
      fi
      if [ -n "$WIKI_NAME" ]; then
        echo "Resolved WIKI_ID=$WIKI_ID (name=$WIKI_NAME)"
      else
        echo "Resolved WIKI_ID=$WIKI_ID"
      fi
      echo "Resolved ROOT_PATH=$ROOT_PATH"
      # Resolve WIKI_BRANCH similarly, default to wikiMaster
      RAW_WBR="${WIKI_BRANCH:-}"
      if [ -z "$RAW_WBR" ] || [[ "$RAW_WBR" == *'$('* ]]; then
        WIKI_BRANCH="wikiMaster"
      else
        WIKI_BRANCH="$RAW_WBR"
      fi
      echo "Resolved WIKI_BRANCH=$WIKI_BRANCH"
      # Publish to a stable path for the wiki branch label
      PAGE_PATH="${ROOT_PATH}/${WIKI_BRANCH}"

      # URL-encode the page path safely
      PAGE_PATH_ESC=$(python -c "import urllib.parse,sys;print(urllib.parse.quote(sys.argv[1], safe='/'))" "$PAGE_PATH")

      BASE_API="${ORG_URL%/}/${PROJECT}/_apis/wiki/wikis/${WIKI_ID}"
      # Always pass versionDescriptor to target the wiki branch label (e.g., wikiMaster)
      VER_QS="versionDescriptor.version=${WIKI_BRANCH}&versionDescriptor.versionType=branch"
      GET_URL="${BASE_API}/pages?path=${PAGE_PATH_ESC}&includeContent=true&${VER_QS}&api-version=7.0"
      PUT_URL="${BASE_API}/pages?path=${PAGE_PATH_ESC}&${VER_QS}&api-version=7.0"

      echo "Fetching existing wiki page (if any): $GET_URL"

      if [ -z "${SYSTEM_ACCESSTOKEN:-}" ]; then
        echo "System.AccessToken is not available. Enable 'Allow scripts to access OAuth token' and ensure Wiki write permission." >&2
        exit 1
      fi
      # Capture headers to extract ETag if it exists
      HTTP_GET=$(curl -s -D /tmp/wiki_headers.txt -o /tmp/wiki_get.json -w "%{http_code}" \
        -H "Authorization: Bearer ${SYSTEM_ACCESSTOKEN}" \
        -H "Content-Type: application/json" \
        "$GET_URL" || true)
      echo "GET status: $HTTP_GET"

      ETAG=$(grep -i '^etag:' /tmp/wiki_headers.txt | awk '{print $2}' | tr -d '\r\n' || true)
      if [ -z "$ETAG" ]; then
        ETAG=$(python -c "import json,io; d=json.load(io.open('/tmp/wiki_get.json','r',encoding='utf-8')); print(str(d.get('eTag') or d.get('etag') or '')) if isinstance(d,dict) else print('')" 2>/dev/null || echo "")
      fi

      CONTENT_JSON=$(python -c "import json,io; print(json.dumps({'content': io.open('/tmp/wiki_page.md','r',encoding='utf-8').read()}))")

      echo "Publishing wiki page to: $PUT_URL"
      if [ "$HTTP_GET" = "200" ] && [ -n "$ETAG" ]; then
        # Update existing page with concurrency control
        HTTP_PUT=$(curl -s -o /tmp/wiki_put.json -w "%{http_code}" -X PUT \
          -H "Authorization: Bearer ${SYSTEM_ACCESSTOKEN}" \
          -H "Content-Type: application/json" \
          -H "If-Match: $ETAG" \
          --data "$CONTENT_JSON" \
          "$PUT_URL")
      else
        # Create new page
        HTTP_PUT=$(curl -s -o /tmp/wiki_put.json -w "%{http_code}" -X PUT \
          -H "Authorization: Bearer ${SYSTEM_ACCESSTOKEN}" \
          -H "Content-Type: application/json" \
          --data "$CONTENT_JSON" \
          "$PUT_URL")
      fi

      echo "PUT status: $HTTP_PUT"
      head -c 500 /tmp/wiki_put.json || true

      # If PUT failed with 404 using a GUID, retry using the project wiki name (common for project wikis)
      USED_GUID=0
      if echo "$WIKI_ID" | grep -Eiq '^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$'; then
        USED_GUID=1
      fi
      if [ "$HTTP_PUT" = "404" ] && [ "$USED_GUID" = "1" ]; then
        ALT_WIKI_NAME="${PROJECT}.wiki"
        ALT_BASE_API="${ORG_URL%/}/${PROJECT}/_apis/wiki/wikis/${ALT_WIKI_NAME}"
        ALT_PUT_URL="${ALT_BASE_API}/pages?path=${PAGE_PATH_ESC}&${VER_QS}&api-version=7.0"
        echo "PUT failed with 404 using GUID. Retrying with wiki name: ${ALT_WIKI_NAME}"
        echo "Publishing wiki page to (fallback): $ALT_PUT_URL"
        HTTP_PUT=$(curl -s -o /tmp/wiki_put.json -w "%{http_code}" -X PUT \
          -H "Authorization: Bearer ${SYSTEM_ACCESSTOKEN}" \
          -H "Content-Type: application/json" \
          --data "$CONTENT_JSON" \
          "$ALT_PUT_URL")
        echo "Fallback PUT status: $HTTP_PUT"
        head -c 500 /tmp/wiki_put.json || true
      fi

      # If still failing, try using projectId in the path instead of project name
      if [ "$HTTP_PUT" != "200" ] && [ "$HTTP_PUT" != "201" ] && [ -n "${SYSTEM_TEAMPROJECTID:-}" ]; then
        # Prefer the last wiki identifier we attempted (name fallback if we used it, else original WIKI_ID)
        FINAL_WIKI_IDENTIFIER="$WIKI_ID"
        if [ "$USED_GUID" = "1" ] && [ -n "$ALT_WIKI_NAME" ]; then
          FINAL_WIKI_IDENTIFIER="$ALT_WIKI_NAME"
        fi
        ALT2_BASE_API="${ORG_URL%/}/${SYSTEM_TEAMPROJECTID}/_apis/wiki/wikis/${FINAL_WIKI_IDENTIFIER}"
        ALT2_PUT_URL="${ALT2_BASE_API}/pages?path=${PAGE_PATH_ESC}&${VER_QS}&api-version=7.0"
        echo "Previous PUT failed. Retrying with projectId in URL: $ALT2_PUT_URL"
        HTTP_PUT=$(curl -s -o /tmp/wiki_put.json -w "%{http_code}" -X PUT \
          -H "Authorization: Bearer ${SYSTEM_ACCESSTOKEN}" \
          -H "Content-Type: application/json" \
          --data "$CONTENT_JSON" \
          "$ALT2_PUT_URL")
        echo "ProjectId-path PUT status: $HTTP_PUT"
        head -c 500 /tmp/wiki_put.json || true
      fi

      if [ "$HTTP_PUT" != "200" ] && [ "$HTTP_PUT" != "201" ]; then
        echo "Wiki publish failed" >&2
        echo "If this is a permission issue, grant 'Contribute' to the wiki for the build identity: '${SYSTEM_TEAMPROJECT} Build Service (\<org\>)' in Project Settings > Repos > Wiki > Select '${PROJECT}.wiki' > Security, and ensure 'Allow scripts to access OAuth token' is enabled for the pipeline." >&2
        exit 1
      fi
      echo "Wiki publish succeeded"
    displayName: "Publish release to Azure DevOps Wiki"
    condition: and(succeeded(), eq(variables['HasChangelog'], 'true'))
    env:
      SYSTEM_COLLECTIONURI: $(System.CollectionUri)
      SYSTEM_TEAMPROJECT: $(System.TeamProject)
      SYSTEM_TEAMPROJECTID: $(System.TeamProjectId)
      SYSTEM_ACCESSTOKEN: $(System.AccessToken)
      WIKI_IDENTIFIER: $(WIKI_IDENTIFIER)
      WIKI_PATH_ROOT: $(WIKI_PATH_ROOT)
      WIKI_BRANCH: $(WIKI_BRANCH)