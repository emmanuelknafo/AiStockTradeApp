# Azure DevOps CI/CD Pipeline
# Converted from GitHub Actions workflow

trigger:
  branches:
    include:
      - main
      - develop
  paths:
    exclude:
      - "**.md"
      - "**/README.md"
      - "docs/**"
      - "*.txt"
      - ".gitignore"
      - ".vscode/**"
      - ".vs/**"
      #- '.azuredevops/**'
      - ".github/**"
      - "AGENTS.md"
      - "LICENSE"

pr:
  branches:
    include:
      - main
  paths:
    exclude:
      - "**.md"
      - "**/README.md"
      - "docs/**"
      - "*.txt"
      - ".gitignore"
      - ".vscode/**"
      - ".vs/**"
      #- '.azuredevops/**'
      - ".github/**"
      - "AGENTS.md"
      - "LICENSE"
# trigger: none  # CI temporarily disabled

# pr: none  # PR validation temporarily disabled

parameters:
  - name: environment
    displayName: "Environment to deploy to"
    type: string
    default: "dev"
    values:
      - dev
      - prod

  - name: instanceNumber
    displayName: "Instance number for resource differentiation"
    type: string
    default: "003"

variables:
  - group: "ai-stock-trade-app" # Variable group for shared variables
  - name: AZURE_SERVICE_CONNECTION
    value: "svc_CSA_sub" # Replace with your Azure service connection name
  - name: AZURE_SUBSCRIPTION_ID
    value: "64c3d212-40ed-4c6d-a825-6adfbdf25dad" # Replace with your Azure subscription ID
  - name: AZURE_WEBAPP_PACKAGE_PATH
    value: "."
  - name: DOTNET_VERSION
    value: "9.0.x"
  - name: vmImageName
    value: "ubuntu-latest"

pool:
  vmImage: $(vmImageName)

stages:
  - stage: Test
    displayName: "Test Application"
    jobs:
      - job: TestJob
        displayName: "Test Application"
        services:
          sqlserver:
            image: mcr.microsoft.com/mssql/server:2022-latest
            env:
              SA_PASSWORD: "YourStrong@Passw0rd"
              ACCEPT_EULA: "Y"
            ports:
              - 1433:1433
        steps:
          - checkout: self
            displayName: "Checkout code"
            fetchDepth: 0  # full history for GitVersion
            persistCredentials: true

          - task: UseDotNet@2
            displayName: "Setup .NET"
            inputs:
              packageType: "sdk"
              version: $(DOTNET_VERSION)

          - task: Bash@3
            displayName: "Determine Semantic Version (GitVersion CLI Fallback)"
            inputs:
              targetType: inline
              script: |
                set -e
                echo "Ensuring full git history (unshallow + tags) for GitVersion..."
                git fetch --prune --unshallow --tags || git fetch --prune --tags || true
                echo "Commit count: $(git rev-list --count HEAD 2>/dev/null || echo '?')"
                git --no-pager log --oneline -n 5 || true
                echo "Installing GitVersion CLI as global dotnet tool..."
                dotnet tool install --global GitVersion.Tool --version 5.* || { echo "Failed to install GitVersion.Tool"; exit 1; }
                export PATH="$PATH:$HOME/.dotnet/tools"
                echo "Running GitVersion..."
                RAW=$(dotnet-gitversion /config GitVersion.yml /output json 2>&1 || true)
                echo "Raw GitVersion output (first 60 lines):"; echo "$RAW" | head -60
                if ! echo "$RAW" | grep -q '"FullSemVer"'; then
                  echo "GitVersion did not return JSON with FullSemVer. Using placeholder version.";
                  FULL="0.0.0-local"; ASM="0.0.0"; INFO="0.0.0-local";
                else
                  if ! command -v jq >/dev/null 2>&1; then sudo apt-get update -y && sudo apt-get install -y jq; fi
                  FULL=$(echo "$RAW" | jq -r '.FullSemVer // empty')
                  ASM=$(echo "$RAW" | jq -r '.AssemblySemVer // empty')
                  INFO=$(echo "$RAW" | jq -r '.InformationalVersion // empty')
                  [ -n "$FULL" ] || FULL="0.0.0-local"
                  [ -n "$ASM" ] || ASM="0.0.0"
                  [ -n "$INFO" ] || INFO="$FULL"
                fi
                echo "Computed FullSemVer=$FULL"
                echo "##vso[task.setvariable variable=GitVersion.FullSemVer]$FULL"
                echo "##vso[task.setvariable variable=GitVersion.AssemblySemVer]$ASM"
                echo "##vso[task.setvariable variable=GitVersion.InformationalVersion]$INFO"
                echo "##vso[task.setvariable variable=FullSemVer]$FULL"
                echo "##vso[task.setvariable variable=AssemblySemVer]$ASM"
                echo "##vso[task.setvariable variable=InformationalVersion]$INFO"
                echo "GitVersion fallback step complete"

          - task: DotNetCoreCLI@2
            displayName: "Install Entity Framework tools"
            inputs:
              command: "custom"
              custom: "tool"
              arguments: "install --global dotnet-ef"

          - task: DotNetCoreCLI@2
            displayName: "Restore dependencies"
            inputs:
              command: "restore"
              projects: "**/*.csproj"

          - task: DotNetCoreCLI@2
            displayName: "Build application"
            inputs:
              command: "build"
              projects: "**/*.csproj"
              arguments: "--no-restore --configuration Release"

          - script: |
              # Wait for SQL Server to be ready
              echo "Waiting for SQL Server to start..."
              for i in {1..30}; do
                if sqlcmd -S localhost -U sa -P "YourStrong@Passw0rd" -Q "SELECT 1" >/dev/null 2>&1; then
                  echo "SQL Server is ready"
                  break
                fi
                echo "Waiting for SQL Server... ($i/30)"
                sleep 2
              done
            displayName: "Wait for SQL Server to start"

          # Removed EF Core database update: migrations will run at application startup in deployed environment

          - task: DotNetCoreCLI@2
            displayName: "Run tests"
            inputs:
              command: "test"
              projects: "**/*.csproj"
              arguments: '--no-build --configuration Release --verbosity normal --filter "FullyQualifiedName!~UITests"'
            env:
              ASPNETCORE_ENVIRONMENT: "Testing"
              ConnectionStrings__DefaultConnection: "Server=localhost;Database=StockTrackerTest;User Id=sa;Password=YourStrong@Passw0rd;TrustServerCertificate=true;Encrypt=false"

      - job: UITestJob
        displayName: "UI Tests with Playwright"
        dependsOn: TestJob
        condition: succeeded()
        services:
          sqlserver:
            image: mcr.microsoft.com/mssql/server:2022-latest
            env:
              SA_PASSWORD: "YourStrong@Passw0rd"
              ACCEPT_EULA: "Y"
            ports:
              - 1433:1433
        steps:
          - checkout: self
            displayName: "Checkout code"

          - task: UseDotNet@2
            displayName: "Setup .NET"
            inputs:
              packageType: "sdk"
              version: $(DOTNET_VERSION)

          - task: DotNetCoreCLI@2
            displayName: "Restore dependencies"
            inputs:
              command: "restore"
              projects: "**/*.csproj"

          - task: DotNetCoreCLI@2
            displayName: "Build application"
            inputs:
              command: "build"
              projects: "**/*.csproj"
              arguments: "--no-restore --configuration Release"

          - task: DotNetCoreCLI@2
            displayName: "Install Entity Framework tools"
            inputs:
              command: "custom"
              custom: "tool"
              arguments: "install --global dotnet-ef"

          - script: |
              # Wait for SQL Server to be ready
              echo "Waiting for SQL Server to start..."
              for i in {1..30}; do
                if sqlcmd -S localhost -U sa -P "YourStrong@Passw0rd" -Q "SELECT 1" >/dev/null 2>&1; then
                  echo "SQL Server is ready"
                  break
                fi
                echo "Waiting for SQL Server... ($i/30)"
                sleep 2
              done
            displayName: "Wait for SQL Server to start"

          # Removed EF Core database update for UI tests: app handles migrations on startup (post-deployment)

          - task: NodeTool@0
            displayName: "Setup Node.js"
            inputs:
              versionSpec: "18.x"

          - script: |
              echo "Installing Playwright via npm (JS driver used by .NET binding)..."
              cd ai-stock-trade-app.UITests
              npm ci || npm install
              npx playwright install --with-deps chromium
              npx playwright --version
              echo "Listing browser cache..."
              ls -R ~/.cache/ms-playwright || true
            displayName: "Install Playwright browsers"

          - script: |
              # Start application in background
              echo "Starting application in background..."
              cd ai-stock-trade-app
              nohup dotnet run --no-build --configuration Release --no-launch-profile > app.log 2>&1 &
              APP_PID=$!
              echo "Started application with PID: $APP_PID"
              echo $APP_PID > app.pid

              # Wait for application to be ready
              echo "Waiting for application to start..."
              timeout=120
              while [ $timeout -gt 0 ]; do
                if curl -f http://localhost:5000 >/dev/null 2>&1; then
                  echo "Application is ready!"
                  break
                fi
                echo "Waiting for application... ($timeout seconds remaining)"
                sleep 2
                timeout=$((timeout-2))
              done

              if [ $timeout -le 0 ]; then
                echo "Application failed to start within timeout"
                echo "Application logs:"
                cat app.log
                exit 1
              fi
            displayName: "Start application in background"
            env:
              ASPNETCORE_ENVIRONMENT: "Development"
              ASPNETCORE_URLS: "http://localhost:5000"
              ConnectionStrings__DefaultConnection: "Server=localhost;Database=StockTrackerTestUI;User Id=sa;Password=YourStrong@Passw0rd;TrustServerCertificate=true;Encrypt=false"

          - script: |
              echo "Waiting for application to start..."
              timeout=60
              while [ $timeout -gt 0 ]; do
                if curl -f http://localhost:5000 >/dev/null 2>&1; then
                  echo "Application is ready!"
                  break
                fi
                echo "Waiting for application... ($timeout seconds remaining)"
                sleep 2
                timeout=$((timeout-2))
              done

              if [ $timeout -le 0 ]; then
                echo "Application failed to start within timeout"
                exit 1
              fi
            displayName: "Wait for application to be ready"

          - script: |
              echo "=== Pre-test debugging ==="
              echo "Checking if UITests project built correctly..."
              ls -la ai-stock-trade-app.UITests/bin/Release/net9.0/ || echo "Build output directory not found"

              echo "Checking for required assemblies..."
              ls -la ai-stock-trade-app.UITests/bin/Release/net9.0/*Playwright* || echo "Playwright assemblies not found"
              ls -la ai-stock-trade-app.UITests/bin/Release/net9.0/*NUnit* || echo "NUnit assemblies not found"

              echo "Checking test.runsettings file..."
              cat test.runsettings || echo "test.runsettings not found"

              echo "Environment variables:"
              echo "PLAYWRIGHT_BASE_URL: $PLAYWRIGHT_BASE_URL"
              echo "ASPNETCORE_ENVIRONMENT: $ASPNETCORE_ENVIRONMENT"
              echo "DISPLAY: $DISPLAY"
              echo "CI: $CI"
              echo "AZURE_PIPELINES: $AZURE_PIPELINES"

              echo "Testing application accessibility..."
              curl -v http://localhost:5000 || echo "Application not responding"

              echo "Skipping X11 display probe (not required for headless Chromium)"

              echo "Checking Playwright installation (npx)..."
              (cd ai-stock-trade-app.UITests && npx playwright --version) || echo "Playwright CLI not available"

              echo "Checking if Playwright browsers are installed..."
              ls -la /ms/playwright/ || echo "Playwright browser cache not found"
              find ~/.cache/ms-playwright -name "chromium*" -type d | head -5 || echo "Chromium browser not found"

              echo "Testing simple browser launch..."
              echo "Testing simple browser launch via dotnet playwright (dry run using codegen list)..."
              (cd ai-stock-trade-app.UITests && npx playwright install chromium) || true
              # Quick launch validation using a minimal script
                echo "Installing dotnet-script for inline launch probe..."
                dotnet tool install --global dotnet-script || true
                export PATH="$PATH:$HOME/.dotnet/tools"
              cat > mini-browser-test.csx <<'CSX'
              #r "nuget: Microsoft.Playwright"
              using Microsoft.Playwright;
              var pw = await Playwright.CreateAsync();
              var browser = await pw.Chromium.LaunchAsync(new() { Headless = true, Args = new[]{"--no-sandbox","--disable-setuid-sandbox","--disable-dev-shm-usage"} });
              var ctx = await browser.NewContextAsync();
              var page = await ctx.NewPageAsync();
              await page.GotoAsync("https://example.com");
              Console.WriteLine("Browser navigation OK: " + await page.TitleAsync());
              await browser.CloseAsync();
              CSX
              dotnet script mini-browser-test.csx || echo "Mini browser test failed (will let tests attempt)."
            displayName: "Pre-test debugging"
            env:
              ASPNETCORE_ENVIRONMENT: "Development"
              PLAYWRIGHT_BASE_URL: "http://localhost:5000"
              DISPLAY: ":99.0"
              CI: "true"
              AZURE_PIPELINES: "true"
              USE_INMEMORY_DB: "true" # Use EF in-memory provider for faster UI tests

          - script: |
              echo "Listing all tests in UITests project..."
              dotnet test ai-stock-trade-app.UITests --list-tests --verbosity normal
            displayName: "List UI Tests to be executed"

          - task: DotNetCoreCLI@2
            displayName: "Run Playwright UI Tests"
            inputs:
              command: "test"
              projects: "ai-stock-trade-app.UITests/ai-stock-trade-app.UITests.csproj"
              arguments: '--no-build --configuration Release --verbosity diagnostic --logger "trx;LogFileName=ui-test-results.trx" --settings ./test.runsettings --logger "console;verbosity=diagnostic"'
            env:
              ASPNETCORE_ENVIRONMENT: "Development"
              PLAYWRIGHT_BASE_URL: "http://localhost:5000"
              ConnectionStrings__DefaultConnection: "Server=localhost;Database=StockTrackerTestUI;User Id=sa;Password=YourStrong@Passw0rd;TrustServerCertificate=true;Encrypt=false"
              DISPLAY: ":99.0"
              PLAYWRIGHT_LAUNCH_OPTIONS: '{"headless":true,"args":["--no-sandbox","--disable-setuid-sandbox","--disable-dev-shm-usage","--disable-gpu","--no-first-run","--no-default-browser-check","--disable-background-timer-throttling","--disable-backgrounding-occluded-windows","--disable-renderer-backgrounding"]}'
              PWDEBUG: "0"
              DEBUG: "pw:api"
              CI: "true"
              AZURE_PIPELINES: "true"
              NODE_PATH: "$(System.DefaultWorkingDirectory)/ai-stock-trade-app.UITests/node_modules"
              USE_INMEMORY_DB: "true" # In-memory DB accelerates UI tests
            condition: succeededOrFailed()
            timeoutInMinutes: 25

          - task: PublishTestResults@2
            displayName: "Publish UI Test Results"
            inputs:
              testResultsFormat: "VSTest"
              testResultsFiles: "**/*ui-test-results.trx"
              testRunTitle: "Playwright UI Tests"
              mergeTestResults: true
            condition: succeededOrFailed()

          - script: |
              echo "Capturing application logs for debugging..."
              if [ -f "ai-stock-trade-app/app.log" ]; then
                echo "=== Application Logs ==="
                cat ai-stock-trade-app/app.log
                echo "=== End Application Logs ==="
              else
                echo "No application log file found"
              fi
            displayName: "Debug: Show application logs"
            condition: failed()

          - script: |
              echo "Stopping application..."
              if [ -f "ai-stock-trade-app/app.pid" ]; then
                APP_PID=$(cat ai-stock-trade-app/app.pid)
                echo "Stopping application with PID: $APP_PID"
                kill $APP_PID || true
                sleep 5
              fi
              # Cleanup any remaining dotnet processes
              pkill -f "dotnet.*ai-stock-trade-app" || true
            displayName: "Stop application"
            condition: always()

          - script: |
              echo "Cleaning up SQL Server container..."
              docker stop sqlserver-ui-test || true
              docker rm sqlserver-ui-test || true
            displayName: "Cleanup SQL Server"
            condition: always()

  - stage: Build
    displayName: "Build and Push Container"
    dependsOn: Test
    condition: succeeded()
    jobs:
      - job: BuildJob
        displayName: "Build and Push Container"
        variables:
          - name: containerImage
            value: ""
          - name: registryName
            value: ""
          - name: resourceGroup
            value: ""
          - name: instanceNum
            value: ""

        steps:
          - checkout: self
            displayName: "Checkout code"

          - task: AzureCLI@2
            displayName: "Get Container Registry Information"
            inputs:
              azureSubscription: "$(AZURE_SERVICE_CONNECTION)"
              scriptType: "bash"
              scriptLocation: "inlineScript"
              inlineScript: |
                # Always use dev environment container registry (shared across all environments)
                if [[ "$(Build.Reason)" == "Manual" ]]; then
                  INSTANCE_NUM="${{ parameters.instanceNumber }}"
                  echo "Manual trigger detected - Instance: ${INSTANCE_NUM}"
                else
                  INSTANCE_NUM="003"
                  echo "Branch push detected - Using default instance: ${INSTANCE_NUM}"
                fi

                # Always target dev resource group for container registry
                ENV="dev"
                RG_NAME="rg-aistock-${ENV}-${INSTANCE_NUM}"

                echo "=== BUILD ENVIRONMENT INFO ==="
                echo "Container Registry Environment: ${ENV} (shared registry)"
                echo "Instance Number: ${INSTANCE_NUM}"
                echo "Registry Resource Group: ${RG_NAME}"
                echo "Build Source Branch: $(Build.SourceBranch)"
                echo "Build Reason: $(Build.Reason)"

                # Get container registry name from dev resource group
                REGISTRY_NAME=$(az acr list --resource-group "${RG_NAME}" --query '[0].name' --output tsv)

                if [ -z "${REGISTRY_NAME}" ] || [ "${REGISTRY_NAME}" == "null" ]; then
                  echo "ERROR: No container registry found in resource group ${RG_NAME}"
                  echo "Available resource groups:"
                  az group list --query '[].name' --output table
                  echo "This might mean the dev infrastructure hasn't been deployed yet for instance ${INSTANCE_NUM}"
                  echo "Please deploy dev environment first to create the shared container registry."
                  exit 1
                fi

                echo "Found shared registry: ${REGISTRY_NAME}"
                echo "##vso[task.setvariable variable=registryName]${REGISTRY_NAME}"
                echo "##vso[task.setvariable variable=resourceGroup]${RG_NAME}"
                echo "##vso[task.setvariable variable=instanceNum]${INSTANCE_NUM}"

          - task: AzureCLI@2
            displayName: "Get Container Registry Credentials"
            inputs:
              azureSubscription: "$(AZURE_SERVICE_CONNECTION)"
              scriptType: "bash"
              scriptLocation: "inlineScript"
              inlineScript: |
                # Get admin credentials
                REGISTRY_USERNAME=$(az acr credential show --name "$(registryName)" --query 'username' --output tsv)
                REGISTRY_PASSWORD=$(az acr credential show --name "$(registryName)" --query 'passwords[0].value' --output tsv)

                echo "Registry Username: ${REGISTRY_USERNAME}"
                echo "Password length: ${#REGISTRY_PASSWORD}"

                echo "##vso[task.setvariable variable=registryUsername;issecret=true]${REGISTRY_USERNAME}"
                echo "##vso[task.setvariable variable=registryPassword;issecret=true]${REGISTRY_PASSWORD}"

          - task: Bash@3
            displayName: "Debug Registry Information"
            inputs:
              targetType: "inline"
              script: |
                echo "=== REGISTRY DEBUG INFO ==="
                echo "Instance Number: $(instanceNum)"
                echo "Registry name: $(registryName)"
                echo "Resource group: $(resourceGroup)"
                echo "Registry URL: $(registryName).azurecr.io"
                echo "=== TRIGGER INFO ==="
                echo "Build Source Branch: $(Build.SourceBranch)"
                echo "Build Reason: $(Build.Reason)"

          - task: AzureCLI@2
            displayName: "Login to Azure Container Registry"
            inputs:
              azureSubscription: "$(AZURE_SERVICE_CONNECTION)"
              scriptType: "bash"
              scriptLocation: "inlineScript"
              inlineScript: |
                echo "Logging in to Azure Container Registry: $(registryName).azurecr.io"
                az acr login --name "$(registryName)"

          - task: Bash@3
            displayName: "Determine Semantic Version (GitVersion CLI for Build)"
            inputs:
              targetType: inline
              script: |
                set -e
                if [ -n "$(GitVersion.FullSemVer)" ]; then
                  echo "GitVersion variables already present from previous stage/job: $(GitVersion.FullSemVer)"; exit 0; fi
                echo "Ensuring full git history (unshallow + tags) for GitVersion (build stage)..."
                git fetch --prune --unshallow --tags || git fetch --prune --tags || true
                echo "Commit count: $(git rev-list --count HEAD 2>/dev/null || echo '?')"
                git --no-pager log --oneline -n 5 || true
                echo "Installing GitVersion CLI (build stage)..."
                dotnet tool install --global GitVersion.Tool --version 5.* || { echo "Failed to install GitVersion.Tool"; exit 1; }
                export PATH="$PATH:$HOME/.dotnet/tools"
                RAW=$(dotnet-gitversion /config GitVersion.yml /output json 2>&1 || true)
                echo "Raw GitVersion output (first 40 lines):"; echo "$RAW" | head -40
                if ! echo "$RAW" | grep -q '"FullSemVer"'; then
                  echo "GitVersion failed or missing JSON; using placeholder version"; FULL="0.0.0-local";
                else
                  if ! command -v jq >/dev/null 2>&1; then sudo apt-get update -y && sudo apt-get install -y jq; fi
                  FULL=$(echo "$RAW" | jq -r '.FullSemVer // empty')
                  [ -n "$FULL" ] || FULL="0.0.0-local"
                fi
                echo "FullSemVer (build)=$FULL"
                echo "##vso[task.setvariable variable=GitVersion.FullSemVer]$FULL"
                echo "##vso[task.setvariable variable=FullSemVer]$FULL"

          - task: Bash@3
            displayName: "Generate Container Tags"
            inputs:
              targetType: "inline"
              script: |
                echo "=== GitVersion (if present) ==="
                if [ -n "$(GitVersion.FullSemVer)" ]; then
                  echo "FullSemVer: $(GitVersion.FullSemVer)"
                else
                  echo "GitVersion variables not set; falling back to branch/sha tags only."
                fi
                # Generate tags similar to docker/metadata-action
                REGISTRY_URL="$(registryName).azurecr.io"
                IMAGE_NAME="${REGISTRY_URL}/ai-stock-trade-app"

                # Branch-based tag
                BRANCH_NAME=$(echo "$(Build.SourceBranchName)" | sed 's/[^a-zA-Z0-9._-]/-/g')
                BRANCH_TAG="${IMAGE_NAME}:${BRANCH_NAME}"

                # SHA-based tag
                SHORT_SHA=$(echo "$(Build.SourceVersion)" | cut -c1-7)
                SHA_TAG="${IMAGE_NAME}:sha-${SHORT_SHA}"

                # Latest tag for main/master branch
                VERSION_TAG=""
                if [ -n "$(GitVersion.FullSemVer)" ]; then
                  VERSION_TAG="${IMAGE_NAME}:$(GitVersion.FullSemVer)"
                fi
                if [[ "$(Build.SourceBranchName)" == "main" || "$(Build.SourceBranchName)" == "master" ]]; then
                  LATEST_TAG="${IMAGE_NAME}:latest"
                  if [ -n "$VERSION_TAG" ]; then
                    TAGS="${BRANCH_TAG},${SHA_TAG},${VERSION_TAG},${LATEST_TAG}"
                  else
                    TAGS="${BRANCH_TAG},${SHA_TAG},${LATEST_TAG}"
                  fi
                else
                  if [ -n "$VERSION_TAG" ]; then
                    TAGS="${BRANCH_TAG},${SHA_TAG},${VERSION_TAG}"
                  else
                    TAGS="${BRANCH_TAG},${SHA_TAG}"
                  fi
                fi

                echo "Generated tags: ${TAGS}"
                echo "##vso[task.setvariable variable=containerTags]${TAGS}"
                DEPLOY_TAG="${SHA_TAG}"
                if [ -n "$VERSION_TAG" ]; then
                  echo "Semantic version tag available: $VERSION_TAG (will be used for deployment)"
                  DEPLOY_TAG="$VERSION_TAG"
                else
                  echo "No semantic version tag available; using sha tag for deployment"
                fi
                echo "Selected deploy tag: ${DEPLOY_TAG}"
                echo "##vso[task.setvariable variable=deployTag]${DEPLOY_TAG}"

          - task: AzureCLI@2
            displayName: "Build and push Docker image"
            inputs:
              azureSubscription: "$(AZURE_SERVICE_CONNECTION)"
              scriptType: "bash"
              scriptLocation: "inlineScript"
              inlineScript: |
                echo "=== BUILDING AND PUSHING CONTAINER IMAGE ==="

                # Parse container tags into individual tags
                IFS=',' read -ra TAG_ARRAY <<< "$(containerTags)"

                # Build the image first
                echo "Building Docker image..."
                docker build -t temp-build-image ./ai-stock-trade-app

                # Tag and push each tag
                for tag in "${TAG_ARRAY[@]}"; do
                  # Remove any leading/trailing whitespace
                  clean_tag=$(echo "$tag" | xargs)
                  echo "Tagging and pushing: $clean_tag"
                  
                  # Tag the image
                  docker tag temp-build-image "$clean_tag"
                  
                  # Push using az acr
                  az acr repository show --name "$(registryName)" --repository ai-stock-trade-app || echo "Repository doesn't exist yet, will be created on first push"
                  docker push "$clean_tag"
                done

                echo "All tags pushed successfully"
                echo "Deploy tag will be: $(deployTag)"

          - task: Bash@3
            displayName: "Extract and set container image for deployment"
            inputs:
              targetType: "inline"
              script: |
                set -e  # Exit on any error
                echo "=== SETTING DEPLOYMENT IMAGE ==="

                DEPLOY_IMAGE="$(deployTag)"
                echo "Final deployment image: '${DEPLOY_IMAGE}'"

                # Check if DEPLOY_IMAGE is empty
                if [ -z "${DEPLOY_IMAGE}" ]; then
                  echo "ERROR: DEPLOY_IMAGE is empty after processing!"
                  exit 1
                fi

                # Write to artifact file for reliable transfer
                echo "=== CREATING ARTIFACT ==="
                mkdir -p $(Pipeline.Workspace)/build-outputs
                echo "${DEPLOY_IMAGE}" > $(Pipeline.Workspace)/build-outputs/container-image.txt
                echo "hello-from-build-stage" > $(Pipeline.Workspace)/build-outputs/test-output.txt

                echo "Artifact files created:"
                ls -la $(Pipeline.Workspace)/build-outputs/
                echo "Container image file contents:"
                cat $(Pipeline.Workspace)/build-outputs/container-image.txt

                echo "##vso[task.setvariable variable=containerImage;isOutput=true]${DEPLOY_IMAGE}"

          - task: PublishPipelineArtifact@1
            displayName: "Upload build outputs as artifact"
            inputs:
              targetPath: "$(Pipeline.Workspace)/build-outputs"
              artifactName: "build-outputs"

  - stage: DeployDev
    displayName: "Deploy to Development"
    dependsOn: Build
    condition: |
      and(
        succeeded(),
        or(
          eq(variables['Build.SourceBranch'], 'refs/heads/develop'),
          and(
            eq(variables['Build.Reason'], 'Manual'),
            eq('${{ parameters.environment }}', 'dev')
          )
        )
      )
    jobs:
      - deployment: DeployDevJob
        displayName: "Deploy to Development"
        environment: ${{ format('development-{0}', parameters.instanceNumber) }}
        variables:
          - name: instanceNum
            value: ${{ format('{0}', parameters.instanceNumber) }}
        strategy:
          runOnce:
            deploy:
              steps:
                - checkout: self
                  displayName: "Checkout code"

                - task: DownloadPipelineArtifact@2
                  displayName: "Download build outputs"
                  inputs:
                    artifactName: "build-outputs"
                    downloadPath: "$(Pipeline.Workspace)/build-outputs"

                - task: Bash@3
                  displayName: "Load container image from artifact"
                  inputs:
                    targetType: "inline"
                    script: |
                      echo "=== LOADING CONTAINER IMAGE FROM ARTIFACT ==="
                      if [ -f "$(Pipeline.Workspace)/build-outputs/container-image.txt" ]; then
                        CONTAINER_IMAGE=$(cat $(Pipeline.Workspace)/build-outputs/container-image.txt)
                        echo "Container image from artifact: '${CONTAINER_IMAGE}'"
                        echo "##vso[task.setvariable variable=containerImage]${CONTAINER_IMAGE}"
                      else
                        echo "ERROR: container-image.txt not found in artifacts!"
                        ls -la $(Pipeline.Workspace)/build-outputs/
                        exit 1
                      fi
                - task: Bash@3
                  displayName: "Derive appVersion parameter (Dev)"
                  inputs:
                    targetType: "inline"
                    script: |
                      IMG="$(containerImage)"
                      TAG="${IMG##*:}"
                      if echo "$TAG" | grep -Eq '^[0-9]+\.[0-9]+\.[0-9]+'; then
                        echo "Semantic version detected in image tag: $TAG"
                        echo "##vso[task.setvariable variable=appVersion]$TAG"
                      else
                        echo "Image tag $TAG is not semantic version; leaving appVersion empty"
                      fi

                - task: AzureResourceManagerTemplateDeployment@3
                  displayName: "Deploy Bicep template"
                  inputs:
                    deploymentScope: "Resource Group"
                    azureResourceManagerConnection: "$(AZURE_SERVICE_CONNECTION)"
                    subscriptionId: "$(AZURE_SUBSCRIPTION_ID)"
                    action: "Create Or Update Resource Group"
                    resourceGroupName: "rg-aistock-dev-$(instanceNum)"
                    location: "Canada Central"
                    templateLocation: "Linked artifact"
                    csmFile: "./ai-stock-trade-app/infrastructure/main.bicep"
                    csmParametersFile: "./ai-stock-trade-app/infrastructure/parameters.dev.json"
                    overrideParameters: "-instanceNumber $(instanceNum) -containerImage $(containerImage) -alphaVantageApiKey $(ALPHA_VANTAGE_API_KEY) -twelveDataApiKey $(TWELVE_DATA_API_KEY) -sqlAdminPassword $(SQL_ADMIN_PASSWORD) -appVersion $(appVersion)"
                    deploymentMode: "Incremental"

                - task: AzureCLI@2
                  displayName: "Verify SQL Admin matches Web App Managed Identity (Dev)"
                  inputs:
                    azureSubscription: "$(AZURE_SERVICE_CONNECTION)"
                    scriptType: bash
                    scriptLocation: inlineScript
                    inlineScript: |
                      set -e
                      RG_NAME="rg-aistock-dev-$(instanceNum)"
                      WEBAPP_NAME="app-aistock-dev-$(instanceNum)"
                      SQL_SERVER_NAME="sql-aistock-dev-$(instanceNum)"
                      echo "[VERIFY-DEV] Checking SQL AD admin vs web app MI..."
                      MI_PRINCIPAL_ID=$(az webapp identity show --name "$WEBAPP_NAME" --resource-group "$RG_NAME" --query principalId -o tsv 2>/dev/null || echo "")
                      if [ -z "$MI_PRINCIPAL_ID" ] || [ "$MI_PRINCIPAL_ID" = "null" ]; then echo "[VERIFY-DEV][ERROR] Web app MI principalId not found"; exit 1; fi
                      ADMIN_LOGIN=$(az sql server ad-admin list --server "$SQL_SERVER_NAME" --resource-group "$RG_NAME" --query "[0].login" -o tsv 2>/dev/null || echo "")
                      ADMIN_SID=$(az sql server ad-admin list --server "$SQL_SERVER_NAME" --resource-group "$RG_NAME" --query "[0].sid" -o tsv 2>/dev/null || echo "")
                      echo "[VERIFY-DEV] Web App MI: $MI_PRINCIPAL_ID"; echo "[VERIFY-DEV] Admin login: $ADMIN_LOGIN"; echo "[VERIFY-DEV] Admin sid: $ADMIN_SID"
                      if [ -z "$ADMIN_SID" ] || [ "$ADMIN_SID" = "null" ]; then echo "[VERIFY-DEV][ERROR] No SQL AD admin configured (expected MI)"; exit 1; fi
                      if [ "$ADMIN_SID" != "$MI_PRINCIPAL_ID" ]; then
                        echo "[VERIFY-DEV][ERROR] SQL AD admin sid does not match MI (expected=$MI_PRINCIPAL_ID, found=$ADMIN_SID login=$ADMIN_LOGIN)";
                        echo "Remediation: Run infra pipeline or execute: az sql server ad-admin delete --server $SQL_SERVER_NAME --resource-group $RG_NAME && az sql server ad-admin create --server $SQL_SERVER_NAME --resource-group $RG_NAME --display-name $WEBAPP_NAME --object-id $MI_PRINCIPAL_ID"; exit 1; fi
                      echo "[VERIFY-DEV] ✅ SQL admin matches web app MI."

                - task: AzureCLI@2
                  displayName: "Update Web App Container"
                  inputs:
                    azureSubscription: "$(AZURE_SERVICE_CONNECTION)"
                    scriptType: "bash"
                    scriptLocation: "inlineScript"
                    inlineScript: |
                      WEBAPP_NAME="app-aistock-dev-$(instanceNum)"
                      RG_NAME="rg-aistock-dev-$(instanceNum)"

                      # Get registry information from the same resource group
                      REGISTRY_NAME=$(az acr list --resource-group "${RG_NAME}" --query '[0].name' --output tsv)
                      REGISTRY_USERNAME=$(az acr credential show --name "${REGISTRY_NAME}" --query 'username' --output tsv)
                      REGISTRY_PASSWORD=$(az acr credential show --name "${REGISTRY_NAME}" --query 'passwords[0].value' --output tsv)

                      echo "Container Image: $(containerImage)"
                      echo "Web App Name: ${WEBAPP_NAME}"
                      echo "Resource Group: ${RG_NAME}"
                      echo "Registry Name: ${REGISTRY_NAME}"

                      if [ -z "$(containerImage)" ]; then
                        echo "ERROR: Container image is empty!"
                        exit 1
                      fi

                      az webapp config container set \
                        --name "${WEBAPP_NAME}" \
                        --resource-group "${RG_NAME}" \
                        --container-image-name "$(containerImage)" \
                        --container-registry-url "https://${REGISTRY_NAME}.azurecr.io" \
                        --container-registry-user "${REGISTRY_USERNAME}" \
                        --container-registry-password "${REGISTRY_PASSWORD}"

                - task: Bash@3
                  displayName: "Run Health Check"
                  inputs:
                    targetType: "inline"
                    script: |
                      WEBAPP_NAME="app-aistock-dev-$(instanceNum)"
                      HEALTH_URL="https://${WEBAPP_NAME}.azurewebsites.net/health"
                      echo "Waiting for deployment to be ready..."
                      echo "Health check URL: ${HEALTH_URL}"
                      sleep 30
                      curl -f "${HEALTH_URL}" || exit 1
                      echo "Health check passed!"

  - stage: DeployProd
    displayName: "Deploy to Production"
    dependsOn:
      - Build
      - DeployDev
    condition: |
      and(
        succeeded(),
        in(dependencies.Build.result, 'Succeeded'),
        in(dependencies.DeployDev.result, 'Succeeded', 'Skipped'),
        or(
          eq(variables['Build.SourceBranch'], 'refs/heads/main'),
          and(
            eq(variables['Build.Reason'], 'Manual'),
            eq('${{ parameters.environment }}', 'prod')
          )
        )
      )
    jobs:
      - deployment: DeployProdJob
        displayName: "Deploy to Production"
        environment: ${{ format('production-{0}', parameters.instanceNumber) }}
        variables:
          - name: instanceNum
            value: ${{ format('{0}', parameters.instanceNumber) }}
        strategy:
          runOnce:
            deploy:
              steps:
                - checkout: self
                  displayName: "Checkout code"

                - task: DownloadPipelineArtifact@2
                  displayName: "Download build outputs"
                  inputs:
                    artifactName: "build-outputs"
                    downloadPath: "$(Pipeline.Workspace)/build-outputs"

                - task: Bash@3
                  displayName: "Load container image from artifact"
                  inputs:
                    targetType: "inline"
                    script: |
                      echo "=== LOADING CONTAINER IMAGE FROM ARTIFACT ==="
                      if [ -f "$(Pipeline.Workspace)/build-outputs/container-image.txt" ]; then
                        CONTAINER_IMAGE=$(cat $(Pipeline.Workspace)/build-outputs/container-image.txt)
                        echo "Container image from artifact: '${CONTAINER_IMAGE}'"
                        echo "##vso[task.setvariable variable=containerImage]${CONTAINER_IMAGE}"
                      else
                        echo "ERROR: container-image.txt not found in artifacts!"
                        ls -la $(Pipeline.Workspace)/build-outputs/
                        exit 1
                      fi

                - task: Bash@3
                  displayName: "Debug Variables"
                  inputs:
                    targetType: "inline"
                    script: |
                      echo "=== DEPLOYMENT DEBUG INFO ==="
                      echo "Stage name: DeployProd"
                      echo "Build Source Branch: $(Build.SourceBranch)"
                      echo "Build Reason: $(Build.Reason)"
                      echo "Environment parameter: ${{ parameters.environment }}"
                      echo "Instance Number: $(instanceNum)"
                      echo "Resource Group: rg-aistock-prod-$(instanceNum)"
                      echo "Web App Name: app-aistock-prod-$(instanceNum)"
                      echo "Container image from artifact: $(containerImage)"

                - task: AzureCLI@2
                  displayName: "Get Azure AD information for SQL Admin"
                  inputs:
                    azureSubscription: "$(AZURE_SERVICE_CONNECTION)"
                    scriptType: "bash"
                    scriptLocation: "inlineScript"
                    inlineScript: |
                      echo "Getting Azure AD information for SQL Server administration..."

                      # Get the service principal information from the service connection
                      # The service connection provides authentication context
                      echo "Retrieving service principal information from connection context..."

                      # Get service principal details using Azure CLI context
                      SP_INFO=$(az account show)
                      TENANT_ID=$(echo "$SP_INFO" | jq -r '.tenantId')

                      # For Azure DevOps, we'll use a predefined service principal name or get it from variables
                      # This should be configured in your Azure DevOps variables
                      if [ -n "$(AZURE_CLIENT_ID)" ]; then
                        CLIENT_ID="$(AZURE_CLIENT_ID)"
                        echo "Using client ID from variable: $CLIENT_ID"
                        
                        SP_DETAILS=$(az ad sp show --id "$CLIENT_ID")
                        SP_OBJECT_ID=$(echo "$SP_DETAILS" | jq -r '.id')
                        SP_DISPLAY_NAME=$(echo "$SP_DETAILS" | jq -r '.displayName')
                      else
                        echo "AZURE_CLIENT_ID variable not set. Using account context..."
                        # Fallback: try to get service principal from current context
                        SUBSCRIPTION_INFO=$(az account show)
                        SP_OBJECT_ID=$(echo "$SUBSCRIPTION_INFO" | jq -r '.user.name')
                        SP_DISPLAY_NAME="Azure DevOps Service Principal"
                      fi

                      echo "Service principal object ID: $SP_OBJECT_ID"
                      echo "Service principal display name: $SP_DISPLAY_NAME"

                      echo "##vso[task.setvariable variable=azureAdAdminObjectId]$SP_OBJECT_ID"
                      echo "##vso[task.setvariable variable=azureAdAdminLogin]$SP_DISPLAY_NAME"

                - task: Bash@3
                  displayName: "Derive Azure AD auth enable flag"
                  inputs:
                    targetType: "inline"
                    script: |
                      echo "Evaluating whether to enable Azure AD only auth..."
                      # Use Azure DevOps variable syntax: $VARIABLE (already set earlier)
                      if [ -n "$azureAdAdminObjectId" ] && [ -n "$azureAdAdminLogin" ]; then
                        echo "Azure AD admin details present. Enabling AAD only auth."
                        echo "##vso[task.setvariable variable=enableAdOnlyAuthFlag]true"
                      else
                        echo "Azure AD admin details missing (objectId='$azureAdAdminObjectId', login='$azureAdAdminLogin'). Disabling AAD only auth for this deployment."
                        echo "##vso[task.setvariable variable=enableAdOnlyAuthFlag]false"
                      fi
                      echo "enableAdOnlyAuthFlag=$enableAdOnlyAuthFlag"

                - task: Bash@3
                  displayName: "Derive appVersion parameter (Prod)"
                  inputs:
                    targetType: "inline"
                    script: |
                      IMG="$(containerImage)"
                      TAG="${IMG##*:}"
                      if echo "$TAG" | grep -Eq '^[0-9]+\.[0-9]+\.[0-9]+'; then
                        echo "Semantic version detected in image tag: $TAG"
                        echo "##vso[task.setvariable variable=appVersion]$TAG"
                      else
                        echo "Image tag $TAG is not semantic version; leaving appVersion empty"
                      fi
                - task: AzureResourceManagerTemplateDeployment@3
                  displayName: "Deploy Bicep template (no SQL admin override)"
                  inputs:
                    deploymentScope: "Resource Group"
                    azureResourceManagerConnection: "$(AZURE_SERVICE_CONNECTION)"
                    subscriptionId: "$(AZURE_SUBSCRIPTION_ID)"
                    action: "Create Or Update Resource Group"
                    resourceGroupName: "rg-aistock-prod-$(instanceNum)"
                    location: "Canada Central"
                    templateLocation: "Linked artifact"
                    csmFile: "./ai-stock-trade-app/infrastructure/main.bicep"
                    csmParametersFile: "./ai-stock-trade-app/infrastructure/parameters.prod.json"
                    # Use containerImage variable if provided; prefer GitVersion FullSemVer tag if available
                    # containerImage variable expected to be ai-stock-trade-app:<tag>
                    overrideParameters: "-instanceNumber $(instanceNum) -containerImage $(containerImage) -sqlAdminPassword $(SQL_ADMIN_PASSWORD) -enableAzureAdOnlyAuth $(enableAdOnlyAuthFlag) -azureAdAdminObjectId $(azureAdAdminObjectId) -azureAdAdminLogin '$(azureAdAdminLogin)' -appVersion $(appVersion)"
                    deploymentMode: "Incremental"

                - task: AzureCLI@2
                  displayName: "Verify SQL Admin matches Web App Managed Identity (Prod)"
                  inputs:
                    azureSubscription: "$(AZURE_SERVICE_CONNECTION)"
                    scriptType: bash
                    scriptLocation: inlineScript
                    inlineScript: |
                      set -e
                      RG_NAME="rg-aistock-prod-$(instanceNum)"
                      WEBAPP_NAME="app-aistock-prod-$(instanceNum)"
                      SQL_SERVER_NAME="sql-aistock-prod-$(instanceNum)"
                      echo "[VERIFY] Checking SQL AD admin vs web app MI..."
                      MI_PRINCIPAL_ID=$(az webapp identity show --name "$WEBAPP_NAME" --resource-group "$RG_NAME" --query principalId -o tsv 2>/dev/null || echo "")
                      if [ -z "$MI_PRINCIPAL_ID" ] || [ "$MI_PRINCIPAL_ID" = "null" ]; then echo "[VERIFY][ERROR] Web app MI principalId not found"; exit 1; fi
                      ADMIN_LOGIN=$(az sql server ad-admin list --server "$SQL_SERVER_NAME" --resource-group "$RG_NAME" --query "[0].login" -o tsv 2>/dev/null || echo "")
                      ADMIN_SID=$(az sql server ad-admin list --server "$SQL_SERVER_NAME" --resource-group "$RG_NAME" --query "[0].sid" -o tsv 2>/dev/null || echo "")
                      echo "[VERIFY] Web App MI: $MI_PRINCIPAL_ID"; echo "[VERIFY] Admin login: $ADMIN_LOGIN"; echo "[VERIFY] Admin sid: $ADMIN_SID"
                      if [ -z "$ADMIN_SID" ] || [ "$ADMIN_SID" = "null" ]; then echo "[VERIFY][ERROR] No SQL AD admin configured (expected MI)"; exit 1; fi
                      if [ "$ADMIN_SID" != "$MI_PRINCIPAL_ID" ]; then
                        echo "[VERIFY][ERROR] SQL AD admin sid does not match MI (expected=$MI_PRINCIPAL_ID, found=$ADMIN_SID login=$ADMIN_LOGIN)";
                        echo "Remediation: Run infra pipeline or execute: az sql server ad-admin delete --server $SQL_SERVER_NAME --resource-group $RG_NAME && az sql server ad-admin create --server $SQL_SERVER_NAME --resource-group $RG_NAME --display-name $WEBAPP_NAME --object-id $MI_PRINCIPAL_ID"; exit 1; fi
                      echo "[VERIFY] ✅ SQL admin matches web app MI."

                # Removed re-assignment of SQL admin here; infra pipeline owns that responsibility.

                - task: AzureCLI@2
                  displayName: "Setup Web App SQL Database Access (Azure AD)"
                  inputs:
                    azureSubscription: "$(AZURE_SERVICE_CONNECTION)"
                    scriptType: "bash"
                    scriptLocation: "inlineScript"
                    inlineScript: |
                      # Do NOT 'set -e' globally; we handle retries manually
                      INSTANCE_NUM="$(instanceNum)"
                      RG_NAME="rg-aistock-prod-$(instanceNum)"
                      WEBAPP_NAME="app-aistock-prod-$(instanceNum)"
                      SQL_SERVER_NAME="sql-aistock-prod-$(instanceNum)"
                      DATABASE_NAME="sqldb-aistock-prod-$(instanceNum)"
                      ENABLE_AAD_ONLY="$(enableAdOnlyAuthFlag)"
                      echo "[INFO] === Managed identity SQL database access setup ==="
                      echo "[INFO] ENABLE_AAD_ONLY=${ENABLE_AAD_ONLY}"
                      if [ "${ENABLE_AAD_ONLY}" != "true" ]; then echo "[INFO] AAD-only auth disabled; skipping."; exit 0; fi
                      echo "[INFO] Ensuring web app managed identity enabled..."
                      MANAGED_IDENTITY=$(az webapp identity show --name "${WEBAPP_NAME}" --resource-group "${RG_NAME}" --query principalId -o tsv 2>/dev/null || echo "")
                      if [ -z "$MANAGED_IDENTITY" ] || [ "$MANAGED_IDENTITY" = "null" ]; then
                        az webapp identity assign --name "${WEBAPP_NAME}" --resource-group "${RG_NAME}" >/dev/null
                        sleep 8
                        MANAGED_IDENTITY=$(az webapp identity show --name "${WEBAPP_NAME}" --resource-group "${RG_NAME}" --query principalId -o tsv)
                      fi
                      echo "[INFO] Managed identity principalId: $MANAGED_IDENTITY"
                      SQL_SERVER_FQDN="${SQL_SERVER_NAME}.database.windows.net"
                      echo "[INFO] Waiting for database '${DATABASE_NAME}' to be online..."
                      for i in $(seq 1 18); do
                        ACCESS_TOKEN_TMP=$(az account get-access-token --resource https://database.windows.net/ --query accessToken -o tsv 2>/dev/null || echo "")
                        if [ -n "$ACCESS_TOKEN_TMP" ]; then
                          export SQLCMDACCESSTOKEN="$ACCESS_TOKEN_TMP"
                          if /opt/mssql-tools/bin/sqlcmd -S "$SQL_SERVER_FQDN" -d master -C -l 15 -h -1 -Q "SET NOCOUNT ON; SELECT state_desc FROM sys.databases WHERE name='${DATABASE_NAME}';" | grep -qi 'ONLINE'; then
                            echo "[INFO] Database is ONLINE (attempt $i)"; break
                          fi
                        fi
                        echo "[INFO] Database not online yet (attempt $i/18); sleeping 10s..."; sleep 10
                      done
                      echo "[INFO] Checking configured Azure AD admin on SQL server..."
                      ADMIN_CHECK_ATTEMPTS=12
                      ADMIN_SEEN=0
                      for i in $(seq 1 $ADMIN_CHECK_ATTEMPTS); do
                        ADMIN_LOGIN=$(az sql server ad-admin list --server "$SQL_SERVER_NAME" --resource-group "$RG_NAME" --query "[0].login" -o tsv 2>/dev/null || echo "")
                        if [ -n "$ADMIN_LOGIN" ] && [ "$ADMIN_LOGIN" != "null" ]; then
                          echo "[INFO] Azure AD admin detected: $ADMIN_LOGIN (attempt $i)"; ADMIN_SEEN=1; break
                        fi
                        echo "[INFO] Azure AD admin not yet visible (attempt $i/$ADMIN_CHECK_ATTEMPTS); waiting 10s..."
                        sleep 10
                      done
                      if [ "$ADMIN_SEEN" != "1" ]; then
                        echo "[WARN] Azure AD admin not visible after waiting. User creation may fail; continuing anyway."
                      fi
                      echo "[INFO] Installing sqlcmd tooling..."
                      curl -s https://packages.microsoft.com/keys/microsoft.asc | sudo apt-key add - >/dev/null
                      curl -s https://packages.microsoft.com/config/ubuntu/20.04/prod.list | sudo tee /etc/apt/sources.list.d/msprod.list >/dev/null
                      sudo apt-get update -y >/dev/null
                      sudo apt-get install -y mssql-tools unixodbc-dev >/dev/null
                      if ! timeout 5 bash -c "</dev/tcp/${SQL_SERVER_NAME}.database.windows.net/1433" 2>/dev/null; then echo "[ERROR] Port 1433 unreachable"; exit 1; fi
                      SQL_SCRIPT=$'USE [${DATABASE_NAME}];\nIF NOT EXISTS (SELECT 1 FROM sys.database_principals WHERE name='"'${WEBAPP_NAME}'"') BEGIN PRINT 'Creating user ${WEBAPP_NAME}'; CREATE USER [${WEBAPP_NAME}] FROM EXTERNAL PROVIDER; END;\nDECLARE @roles TABLE(r sysname); INSERT INTO @roles VALUES(\'db_datareader\'),(\'db_datawriter\'),(\'db_ddladmin\');\nDECLARE c CURSOR LOCAL FAST_FORWARD FOR SELECT r FROM @roles; OPEN c; DECLARE @r sysname; FETCH NEXT FROM c INTO @r;\nWHILE @@FETCH_STATUS=0 BEGIN IF IS_ROLEMEMBER(@r,\'${WEBAPP_NAME}\')=1 PRINT @r+\' already assigned\'; ELSE EXEC(\'ALTER ROLE \' +QUOTENAME(@r)+ ' ADD MEMBER [${WEBAPP_NAME}]\'); FETCH NEXT FROM c INTO @r; END CLOSE c; DEALLOCATE c;\nSELECT dp.name AS principal, r.name AS role_name FROM sys.database_principals dp JOIN sys.database_role_members rm ON dp.principal_id=rm.member_principal_id JOIN sys.database_principals r ON rm.role_principal_id=r.principal_id WHERE dp.name=\'${WEBAPP_NAME}\';'
                      printf '%s\n' "$SQL_SCRIPT" > setup_managed_identity.sql

                      echo "[INFO] Waiting for successful token-based connectivity..."
                      LOGIN_OK=0
                      for i in $(seq 1 12); do
                        ACCESS_TOKEN=$(az account get-access-token --resource https://database.windows.net/ --query accessToken -o tsv 2>/dev/null || echo "")
                        if [ -z "$ACCESS_TOKEN" ]; then echo "[INFO] (attempt $i) token not acquired, retrying in 10s"; sleep 10; continue; fi
                        export SQLCMDACCESSTOKEN="$ACCESS_TOKEN"
                        if /opt/mssql-tools/bin/sqlcmd -S "$SQL_SERVER_FQDN" -d master -C -l 15 -Q "SELECT 1" >/dev/null 2>&1; then
                          echo "[INFO] Token login succeeded on attempt $i"; LOGIN_OK=1; break
                        else
                          echo "[INFO] Token login failed (attempt $i); waiting 10s..."; sleep 10
                        fi
                      done
                      if [ "$LOGIN_OK" != "1" ]; then
                        echo "[WARN] Could not establish token login after retries. Skipping user creation to avoid hard failure."
                        exit 0
                      fi

                      echo "[INFO] Executing user/role script with retries..."
                      CREATE_OK=0
                      for i in $(seq 1 5); do
                        # Refresh token before each attempt (tokens ~ 1h but safe)
                        ACCESS_TOKEN=$(az account get-access-token --resource https://database.windows.net/ --query accessToken -o tsv 2>/dev/null || echo "")
                        [ -n "$ACCESS_TOKEN" ] && export SQLCMDACCESSTOKEN="$ACCESS_TOKEN"
                        if /opt/mssql-tools/bin/sqlcmd -S "$SQL_SERVER_FQDN" -d "$DATABASE_NAME" -C -l 60 -i setup_managed_identity.sql; then
                          echo "[INFO] User/role script succeeded (attempt $i)"; CREATE_OK=1; break
                        else
                          echo "[WARN] User/role script failed (attempt $i); sleeping 15s before retry"; sleep 15
                        fi
                      done
                      if [ "$CREATE_OK" != "1" ]; then
                        echo "[WARN] Exhausted retries creating/verifying managed identity user. Manual intervention may be required."
                        exit 0
                      fi

                      echo "[INFO] Running identity test query..."
                      echo "SELECT SUSER_SNAME() AS suser, CURRENT_USER AS current_user, DB_NAME() AS dbname;" > test_connection.sql
                      /opt/mssql-tools/bin/sqlcmd -S "$SQL_SERVER_FQDN" -d "$DATABASE_NAME" -C -l 15 -i test_connection.sql || echo "[WARN] Identity test query failed"
                      echo "[INFO] Verifying presence of managed identity user principal..."
                      VERIFY_SQL=$'SET NOCOUNT ON; SELECT name,type_desc,create_date FROM sys.database_principals WHERE name='"'${WEBAPP_NAME}'"';'
                      VERIFY_OUTPUT=$(/opt/mssql-tools/bin/sqlcmd -S "$SQL_SERVER_FQDN" -d "$DATABASE_NAME" -C -l 30 -h -1 -Q "$VERIFY_SQL" 2>/dev/null || echo "")
                      if echo "$VERIFY_OUTPUT" | grep -qi "${WEBAPP_NAME}"; then
                        echo "[INFO] Managed identity user exists in database."
                      else
                        echo "[ERROR] Managed identity user ${WEBAPP_NAME} NOT FOUND after creation attempts."; exit 1
                      fi
                      echo "[INFO] Listing role memberships for managed identity (if any)..."
                      ROLE_SQL=$'SET NOCOUNT ON; SELECT r.name AS role_name FROM sys.database_principals dp JOIN sys.database_role_members rm ON dp.principal_id=rm.member_principal_id JOIN sys.database_principals r ON rm.role_principal_id=r.principal_id WHERE dp.name='"'${WEBAPP_NAME}'"';'
                      /opt/mssql-tools/bin/sqlcmd -S "$SQL_SERVER_FQDN" -d "$DATABASE_NAME" -C -l 30 -Q "$ROLE_SQL" || echo "[WARN] Role listing query failed"
                      echo "[INFO] Managed identity SQL setup complete"

                - task: DotNetCoreCLI@2
                  displayName: "Setup .NET for migrations"
                  inputs:
                    command: "custom"
                    custom: "tool"
                    arguments: "install --global dotnet-ef"

                - task: AzureCLI@2
                  displayName: "Run database migrations"
                  inputs:
                    azureSubscription: "$(AZURE_SERVICE_CONNECTION)"
                    scriptType: "bash"
                    scriptLocation: "inlineScript"
                    inlineScript: |
                      INSTANCE_NUM="$(instanceNum)"
                      RG_NAME="rg-aistock-prod-$(instanceNum)"

                      echo "🗄️ Checking database migration options..."
                      echo "Resource Group: ${RG_NAME}"

                      # Try to get connection string from Key Vault, but don't fail if access is denied
                      KEY_VAULT_NAME="kv-aistock-prod-$(instanceNum)"
                      echo "Attempting to retrieve connection string from Key Vault: ${KEY_VAULT_NAME}"

                      CONNECTION_STRING=$(az keyvault secret show --vault-name "${KEY_VAULT_NAME}" --name "SqlConnectionString" --query "value" --output tsv 2>/dev/null || echo "")

                      if [ -z "${CONNECTION_STRING}" ]; then
                        echo "ℹ️ Could not retrieve connection string from Key Vault."
                        echo "This is expected for first-time deployments or when pipeline doesn't have Key Vault access."
                        echo ""
                        echo "🚀 Database migrations will run automatically on first app startup."
                        echo "The application is configured to:"
                        echo "  1. Use Azure AD managed identity authentication"
                        echo "  2. Run Entity Framework migrations automatically"
                        echo "  3. Create necessary database schema"
                        echo ""
                        echo "✅ Skipping manual migration - letting app handle it during startup"
                      else
                        echo "✅ Retrieved connection string from Key Vault"
                        echo "Connection string type: $(echo "${CONNECTION_STRING}" | grep -o 'Authentication=[^;]*' || echo 'SQL Authentication')"
                        
                        if echo "${CONNECTION_STRING}" | grep -q "Authentication=Active Directory Default"; then
                          echo "🔐 Using Azure AD authentication for migrations"
                        else
                          echo "🔑 Using SQL authentication for migrations"
                        fi
                        
                        echo "Running database migrations manually..."
                        cd ai-stock-trade-app
                        export ConnectionStrings__DefaultConnection="${CONNECTION_STRING}"
                        
                        # Run with verbose output
                        echo "Starting Entity Framework migration..."
                        dotnet ef database update --verbose
                        
                        if [ $? -eq 0 ]; then
                          echo "✅ Database migrations completed successfully"
                        else
                          echo "⚠️ Migration failed, but this may be handled during app startup"
                        fi
                      fi

                - task: AzureCLI@2
                  displayName: "Update Web App Container"
                  inputs:
                    azureSubscription: "$(AZURE_SERVICE_CONNECTION)"
                    scriptType: "bash"
                    scriptLocation: "inlineScript"
                    inlineScript: |
                      WEBAPP_NAME="app-aistock-prod-$(instanceNum)"
                      RG_NAME="rg-aistock-prod-$(instanceNum)"

                      # Get registry information from DEV resource group (shared registry)
                      DEV_RG_NAME="rg-aistock-dev-$(instanceNum)"
                      REGISTRY_NAME=$(az acr list --resource-group "${DEV_RG_NAME}" --query '[0].name' --output tsv)
                      REGISTRY_USERNAME=$(az acr credential show --name "${REGISTRY_NAME}" --query 'username' --output tsv)
                      REGISTRY_PASSWORD=$(az acr credential show --name "${REGISTRY_NAME}" --query 'passwords[0].value' --output tsv)

                      echo "Container Image: $(containerImage)"
                      echo "Web App Name: ${WEBAPP_NAME}"
                      echo "Prod Resource Group: ${RG_NAME}"
                      echo "Dev Registry Resource Group: ${DEV_RG_NAME}"
                      echo "Shared Registry Name: ${REGISTRY_NAME}"

                      if [ -z "$(containerImage)" ]; then
                        echo "ERROR: Container image is empty!"
                        exit 1
                      fi

                      az webapp config container set \
                        --name "${WEBAPP_NAME}" \
                        --resource-group "${RG_NAME}" \
                        --container-image-name "$(containerImage)" \
                        --container-registry-url "https://${REGISTRY_NAME}.azurecr.io" \
                        --container-registry-user "${REGISTRY_USERNAME}" \
                        --container-registry-password "${REGISTRY_PASSWORD}"

                - task: AzureCLI@2
                  displayName: "Run Health Check"
                  inputs:
                    azureSubscription: "$(AZURE_SERVICE_CONNECTION)"
                    scriptType: "bash"
                    scriptLocation: "inlineScript"
                    inlineScript: |
                      echo "[DIAG] Dumping resolved connection string authentication mode before health checks (shared script)..."
                      WEBAPP_NAME="app-aistock-prod-$(instanceNum)"
                      RG_NAME="rg-aistock-prod-$(instanceNum)"
                      bash ./scripts/sql-conn-auth-dump.sh "$RG_NAME" "$WEBAPP_NAME" || echo "[DIAG] Script execution failed (non-fatal)"
                      WEBAPP_NAME="app-aistock-prod-$(instanceNum)"
                      HEALTH_URL="https://${WEBAPP_NAME}.azurewebsites.net/health"
                      BASE_URL="https://${WEBAPP_NAME}.azurewebsites.net"

                      echo "🏥 Starting comprehensive health check..."
                      echo "Base URL: ${BASE_URL}"
                      echo "Health URL: ${HEALTH_URL}"

                      # Wait for initial deployment
                      echo "Waiting for deployment to be ready..."
                      sleep 60

                      # Check if the site is accessible at all
                      echo "Testing basic site accessibility..."
                      for i in {1..5}; do
                        if curl -f -s "${BASE_URL}" >/dev/null 2>&1; then
                          echo "✅ Site is accessible (attempt $i)"
                          break
                        else
                          echo "⏳ Site not ready yet (attempt $i/5)..."
                          sleep 30
                        fi
                      done

                      # Check health endpoint specifically
                      echo "Testing health endpoint..."
                      for i in {1..10}; do
                        echo "Health check attempt $i/10..."
                        
                        # Get detailed response
                        HTTP_CODE=$(curl -s -o /tmp/health_response.txt -w "%{http_code}" "${HEALTH_URL}")
                        RESPONSE_BODY=$(cat /tmp/health_response.txt 2>/dev/null || echo "No response body")
                        
                        echo "HTTP Status: ${HTTP_CODE}"
                        echo "Response: ${RESPONSE_BODY}"
                        
                        if [ "${HTTP_CODE}" = "200" ]; then
                          echo "✅ Health check passed!"
                          echo "Deployment successful and application is healthy."
                          exit 0
                        elif [ "${HTTP_CODE}" = "503" ] || [ "${HTTP_CODE}" = "500" ]; then
                          echo "⚠️ Application error detected (HTTP ${HTTP_CODE})"
                          echo "This might be a database connectivity issue."
                          
                          # Try to get more detailed logs
                          echo "Attempting to get application logs..."
                          az webapp log tail --name "${WEBAPP_NAME}" --resource-group "rg-aistock-prod-$(instanceNum)" --timeout 30 || echo "Could not retrieve logs"
                          
                          if [ $i -eq 10 ]; then
                            echo "❌ Health check failed after 10 attempts"
                            echo "Last response (HTTP ${HTTP_CODE}): ${RESPONSE_BODY}"
                            echo ""
                            echo "🔍 Troubleshooting steps:"
                            echo "1. Check Azure portal for app service logs"
                            echo "2. Verify managed identity SQL user was created"
                            echo "3. Check Key Vault access permissions"
                            echo "4. Verify SQL Server firewall allows Azure services"
                            exit 1
                          fi
                        else
                          echo "⏳ Unexpected response (HTTP ${HTTP_CODE}), retrying..."
                        fi
                        
                        sleep 30
                      done

                      echo "❌ Health check failed - no successful response received"
                      exit 1

  - stage: SecurityScan
    displayName: "Security Scan"
    dependsOn: Build
    condition: |
      and(
        succeeded(),
        eq(variables['Build.Reason'], 'PullRequest')
      )
    jobs:
      - job: SecurityScanJob
        displayName: "Security Scan"
        steps:
          - checkout: self
            displayName: "Checkout code"

          - task: DownloadPipelineArtifact@2
            displayName: "Download build outputs"
            inputs:
              artifactName: "build-outputs"
              downloadPath: "$(Pipeline.Workspace)/build-outputs"

          - task: Bash@3
            displayName: "Load container image from artifact"
            inputs:
              targetType: "inline"
              script: |
                if [ -f "$(Pipeline.Workspace)/build-outputs/container-image.txt" ]; then
                  CONTAINER_IMAGE=$(cat $(Pipeline.Workspace)/build-outputs/container-image.txt)
                  echo "Container image from artifact: '${CONTAINER_IMAGE}'"
                  echo "##vso[task.setvariable variable=containerImage]${CONTAINER_IMAGE}"
                else
                  echo "ERROR: container-image.txt not found in artifacts!"
                  exit 1
                fi

          # Note: For Trivy scanning in Azure DevOps, you would need to install Trivy
          # or use a marketplace extension. This is a placeholder for the security scan.
          - task: Bash@3
            displayName: "Run Security Scan (Placeholder)"
            inputs:
              targetType: "inline"
              script: |
                echo "=== SECURITY SCAN ==="
                echo "Container image to scan: $(containerImage)"
                echo "In a real implementation, this would run Trivy or similar security scanner"
                echo "Results would be published to Azure DevOps security dashboard"
