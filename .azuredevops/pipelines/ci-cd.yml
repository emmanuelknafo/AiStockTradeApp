# Azure DevOps CI/CD Pipeline
# Converted from GitHub Actions workflow

trigger:
  branches:
    include:
      - main
      - develop
  paths:
    exclude:
      - "**.md"
      - "**/README.md"
      - "docs/**"
      - "*.txt"
      - ".gitignore"
      - ".vscode/**"
      - ".vs/**"
      #- '.azuredevops/**'
      - ".github/**"
      - "AGENTS.md"
      - "LICENSE"

pr:
  branches:
    include:
      - main
  paths:
    exclude:
      - "**.md"
      - "**/README.md"
      - "docs/**"
      - "*.txt"
      - ".gitignore"
      - ".vscode/**"
      - ".vs/**"
      #- '.azuredevops/**'
      - ".github/**"
      - "AGENTS.md"
      - "LICENSE"
resources:
  pipelines:
    - pipeline: infrastructurePipeline
      source: emmanuelknafo.AiStockTradeApp.infrastructure
      trigger:
        branches:
          include:
            - main
            - develop
        stages: []

# trigger: none  # CI temporarily disabled

# pr: none  # PR validation temporarily disabled

parameters:
  - name: environment
    displayName: "Environment to deploy to"
    type: string
    default: "dev"
    values:
      - dev
      - prod

  - name: instanceNumber
    displayName: "Instance number for resource differentiation"
    type: string
    default: "003"

variables:
  - group: "AiStockTradeApp" # Variable group for shared variables
  - name: AZURE_SERVICE_CONNECTION
    value: "svc_CSA_sub" # Replace with your Azure service connection name
  - name: AZURE_SUBSCRIPTION_ID
    value: "64c3d212-40ed-4c6d-a825-6adfbdf25dad" # Replace with your Azure subscription ID
  - name: AZURE_WEBAPP_PACKAGE_PATH
    value: "."
  - name: DOTNET_VERSION
    value: "9.0.x"
  - name: vmImageName
    value: "ubuntu-latest"

pool:
  vmImage: $(vmImageName)

stages:
  - stage: Test
    displayName: "Test Application"
    jobs:
      - job: TestJob
        displayName: "Test Application"
        steps:
          - checkout: self
            displayName: "Checkout code"
            fetchDepth: 0 # full history for GitVersion
            persistCredentials: true
            clean: true
          - task: Bash@3
            displayName: "Docker pre-clean (global)"
            inputs:
              targetType: inline
              script: |
                docker ps -aq | xargs -r docker rm -f || true
                docker image prune -af || true

          - task: Bash@3
            displayName: "Debug git state (pre-version)"
            inputs:
              targetType: inline
              script: |
                set -e
                echo "GitVersion.yml present? $( [ -f GitVersion.yml ] && echo yes || echo no )"
                echo "HEAD commit: $(git rev-parse --short=12 HEAD)"
                echo "Commit count: $(git rev-list --count HEAD)"
                echo "Recent commits:"; git --no-pager log --oneline -n 5 || true
                echo "Existing tags (tail):"; git tag -l | tail -10 || true

          - task: UseDotNet@2
            displayName: "Setup .NET"
            inputs:
              packageType: "sdk"
              version: $(DOTNET_VERSION)

          - task: Bash@3
            displayName: "Determine Semantic Version (GitVersion CLI Fallback)"
            inputs:
              targetType: inline
              script: |
                set -e
                echo "Ensuring full git history (unshallow + tags) for GitVersion..."
                git fetch --prune --unshallow --tags || git fetch --prune --tags || true
                echo "Commit count: $(git rev-list --count HEAD 2>/dev/null || echo '?')"
                git --no-pager log --oneline -n 5 || true
                echo "Installing GitVersion CLI as global dotnet tool..."
                dotnet tool install --global GitVersion.Tool --version 5.* || { echo "Failed to install GitVersion.Tool"; exit 1; }
                export PATH="$PATH:$HOME/.dotnet/tools"
                echo "Running GitVersion..."
                RAW=$(dotnet-gitversion /config GitVersion.yml /output json 2>&1 || true)
                echo "Raw GitVersion output (first 60 lines):"; echo "$RAW" | head -60
                if ! echo "$RAW" | grep -q '"FullSemVer"'; then
                  echo "GitVersion did not return JSON with FullSemVer. Using placeholder version.";
                  FULL="0.0.0-local"; ASM="0.0.0"; INFO="0.0.0-local";
                else
                  if ! command -v jq >/dev/null 2>&1; then sudo apt-get update -y && sudo apt-get install -y jq; fi
                  FULL=$(echo "$RAW" | jq -r '.FullSemVer // empty')
                  ASM=$(echo "$RAW" | jq -r '.AssemblySemVer // empty')
                  INFO=$(echo "$RAW" | jq -r '.InformationalVersion // empty')
                  [ -n "$FULL" ] || FULL="0.0.0-local"
                  [ -n "$ASM" ] || ASM="0.0.0"
                  [ -n "$INFO" ] || INFO="$FULL"
                fi
                echo "Computed FullSemVer=$FULL"
                echo "##vso[task.setvariable variable=GitVersion.FullSemVer]$FULL"
                echo "##vso[task.setvariable variable=GitVersion.AssemblySemVer]$ASM"
                echo "##vso[task.setvariable variable=GitVersion.InformationalVersion]$INFO"
                echo "##vso[task.setvariable variable=FullSemVer]$FULL"
                echo "##vso[task.setvariable variable=AssemblySemVer]$ASM"
                echo "##vso[task.setvariable variable=InformationalVersion]$INFO"
                echo "GitVersion fallback step complete"

          - task: DotNetCoreCLI@2
            displayName: "Install Entity Framework tools"
            inputs:
              command: "custom"
              custom: "tool"
              arguments: "install --global dotnet-ef"

          - task: DotNetCoreCLI@2
            displayName: "Restore dependencies"
            inputs:
              command: "restore"
              projects: "AiStockTradeApp.sln"

          - task: DotNetCoreCLI@2
            displayName: "Build application"
            inputs:
              command: "build"
              projects: "AiStockTradeApp.sln"
              arguments: "--no-restore --configuration Release"

          # SQL Server container not required for unit tests; using in-memory DB

          # Removed EF Core database update: migrations will run at application startup in deployed environment

          - task: DotNetCoreCLI@2
            displayName: "Run tests"
            inputs:
              command: "test"
              projects: "AiStockTradeApp.Tests/AiStockTradeApp.Tests.csproj"
              arguments: '--no-build --configuration Release --verbosity normal --settings ./test.runsettings --logger "trx;LogFileName=unit-tests.trx" --results-directory "$(Agent.TempDirectory)"'
              publishTestResults: false
            env:
              ASPNETCORE_ENVIRONMENT: "Development"
              USE_INMEMORY_DB: "true"
              ConnectionStrings__DefaultConnection: "Server=localhost;Database=StockTrackerTest;User Id=sa;Password=YourStrong@Passw0rd;TrustServerCertificate=true;Encrypt=false"
              VSTEST_RESULTS_DIRECTORY: "$(Agent.TempDirectory)"

          - task: Bash@3
            displayName: "Diagnostics: List TestResults artifacts"
            inputs:
              targetType: inline
              script: |
                echo "Listing TestResults directories..."
                find $(System.DefaultWorkingDirectory) -type d -name TestResults | head -50
                echo "Listing TRX files..."
                find $(System.DefaultWorkingDirectory) -type f -name '*.trx' | head -80
                echo "Agent temp TRX files..."
                find $(Agent.TempDirectory) -type f -name '*.trx' 2>/dev/null | head -40 || true
                echo "Listing coverage candidates (xml/json)..."
                find $(System.DefaultWorkingDirectory) -type f \( -name 'coverage.cobertura.xml' -o -name 'coverage.opencover.xml' -o -name 'coverage.xml' -o -name 'coverage.json' \) | head -80
                echo "Agent temp coverage candidates..."
                find $(Agent.TempDirectory) -type f \( -name 'coverage.cobertura.xml' -o -name 'coverage.opencover.xml' -o -name 'coverage.xml' -o -name 'coverage.json' \) 2>/dev/null | head -40 || true
                echo "Disk usage for test project directories:"; du -sh */*Tests 2>/dev/null || true

          - task: Bash@3
            displayName: "Fallback: Copy TRX from workspace TestResults to Agent.TempDirectory"
            condition: always()
            inputs:
              targetType: inline
              script: |
                set -e
                SRC_DIR="$(System.DefaultWorkingDirectory)/TestResults"
                DEST_DIR="$(Agent.TempDirectory)"
                if [ -d "$SRC_DIR" ]; then
                  FOUND=$(find "$SRC_DIR" -type f -name '*.trx' | wc -l)
                  if [ "$FOUND" -gt 0 ]; then
                    echo "Found $FOUND TRX in $SRC_DIR. Copying to $DEST_DIR..."
                    find "$SRC_DIR" -type f -name '*.trx' -exec cp {} "$DEST_DIR/" \;
                  else
                    echo "No TRX in $SRC_DIR"
                  fi
                else
                  echo "No workspace TestResults directory present"
                fi

          # Removed TRX collection step; publish directly from Agent.TempDirectory to retain attachments referenced in TRX

          - task: Bash@3
            displayName: "Locate coverage file"
            inputs:
              targetType: inline
              script: |
                set -e
                echo "Searching for coverage files (cobertura/opencover)..."
                FOUND=$(find $(System.DefaultWorkingDirectory) -type f \( -name 'coverage.cobertura.xml' -o -name 'coverage.opencover.xml' -o -name 'coverage.xml' \) | head -1 || true)
                if [ -z "$FOUND" ]; then
                  echo "Not found in workspace; checking Agent.TempDirectory..."
                  FOUND=$(find $(Agent.TempDirectory) -type f \( -name 'coverage.cobertura.xml' -o -name 'coverage.opencover.xml' -o -name 'coverage.xml' \) 2>/dev/null | head -1 || true)
                fi
                if [ -z "$FOUND" ]; then
                  echo "No coverage file found (will skip publish)."; exit 0; fi
                echo "Found coverage file: $FOUND";
                # Copy to workspace so later tasks can read reliably
                mkdir -p $(System.DefaultWorkingDirectory)/Coverage
                cp "$FOUND" $(System.DefaultWorkingDirectory)/Coverage/coverage.cobertura.xml || true
                echo "Coverage copied to $(System.DefaultWorkingDirectory)/Coverage/coverage.cobertura.xml"
                echo "##vso[task.setvariable variable=CoverageFile]$(System.DefaultWorkingDirectory)/Coverage/coverage.cobertura.xml";

          - task: PublishTestResults@2
            displayName: "Publish Unit Test Results"
            condition: always()
            inputs:
              testResultsFormat: "VSTest"
              testResultsFiles: "*.trx"
              searchFolder: "$(Agent.TempDirectory)"
              mergeTestResults: true
              testRunTitle: "Unit Tests_$(Build.BuildId)"

          - task: Bash@3
            displayName: "Collect Unit TRX for artifact"
            condition: always()
            inputs:
              targetType: inline
              script: |
                set -e
                DEST="$(Pipeline.Workspace)/test-results/unit"
                mkdir -p "$DEST"
                echo "Collecting TRX from $(Agent.TempDirectory) to $DEST"
                find "$(Agent.TempDirectory)" -type f -name '*.trx' -print -exec cp {} "$DEST/" \; 2>/dev/null || true

          - task: PublishPipelineArtifact@1
            displayName: "Upload Unit Test TRX"
            condition: always()
            inputs:
              targetPath: "$(Pipeline.Workspace)/test-results/unit"
              artifactName: "unit-test-results"

          - task: Bash@3
            displayName: "Generate HTML coverage report"
            condition: and(succeeded(), ne(variables.CoverageFile, ''))
            inputs:
              targetType: inline
              script: |
                set -e
                echo "Installing reportgenerator tool..."
                dotnet tool install --global dotnet-reportgenerator-globaltool --version 5.* || true
                export PATH="$PATH:$HOME/.dotnet/tools"
                OUT_DIR="$(System.DefaultWorkingDirectory)/CodeCoverageReport"
                mkdir -p "$OUT_DIR"
                echo "Running reportgenerator..."
                reportgenerator -reports:"$(CoverageFile)" -targetdir:"$OUT_DIR" -reporttypes:HtmlSummary;HtmlInline_AzurePipelines || echo "Report generation failed (continuing)"
                echo "Report directory contents:"; ls -la "$OUT_DIR" || true
                # Expose directory path
                echo "##vso[task.setvariable variable=CoverageReportDir]$OUT_DIR"

          - task: PublishCodeCoverageResults@2
            displayName: "Publish code coverage"
            condition: and(succeeded(), ne(variables.CoverageFile, ''))
            inputs:
              codeCoverageTool: Cobertura
              summaryFileLocation: "$(CoverageFile)"
              reportDirectory: "$(CoverageReportDir)"
              failIfCoverageEmpty: true
              # additionalCodeCoverageFiles can be added if multiple assemblies produce separate files

      - job: UITestJob
        displayName: "UI Tests with Playwright"
        dependsOn: TestJob
        condition: succeeded()
        steps:
          - checkout: self
            displayName: "Checkout code"
            fetchDepth: 0
            persistCredentials: true
            clean: true
          - task: Bash@3
            displayName: "Docker pre-clean (global)"
            inputs:
              targetType: inline
              script: |
                docker ps -aq | xargs -r docker rm -f || true
                docker image prune -af || true

          - task: UseDotNet@2
            displayName: "Setup .NET"
            inputs:
              packageType: "sdk"
              version: $(DOTNET_VERSION)

          - task: DotNetCoreCLI@2
            displayName: "Restore dependencies"
            inputs:
              command: "restore"
              projects: "AiStockTradeApp.sln"

          - task: DotNetCoreCLI@2
            displayName: "Build application"
            inputs:
              command: "build"
              projects: "AiStockTradeApp.sln"
              arguments: "--no-restore --configuration Release /p:Version=$(FullSemVer) /p:FileVersion=$(AssemblySemVer) /p:InformationalVersion=$(InformationalVersion) /p:AssemblyVersion=$(AssemblySemVer)"

          - task: DotNetCoreCLI@2
            displayName: "Install Entity Framework tools"
            inputs:
              command: "custom"
              custom: "tool"
              arguments: "install --global dotnet-ef"

          # SQL Server container not required for UI tests; using in-memory DB

          # Removed EF Core database update for UI tests: app handles migrations on startup (post-deployment)

          - task: NodeTool@0
            displayName: "Setup Node.js"
            inputs:
              versionSpec: "18.x"

          - script: |
              echo "Installing Playwright via npm (JS driver used by .NET binding)..."
              cd AiStockTradeApp.UITests
              npm ci || npm install
              npx playwright install --with-deps chromium
              npx playwright --version
              echo "Listing browser cache..."
              ls -R ~/.cache/ms-playwright || true
            displayName: "Install Playwright browsers"

          - script: |
              # Start application in background
              echo "Starting application in background..."
              cd AiStockTradeApp
              nohup dotnet run --no-build --configuration Release --no-launch-profile > app.log 2>&1 &
              APP_PID=$!
              echo "Started application with PID: $APP_PID"
              echo $APP_PID > app.pid

              # Wait for application to be ready
              echo "Waiting for application to start..."
              timeout=120
              while [ $timeout -gt 0 ]; do
                if curl -f http://localhost:5000 >/dev/null 2>&1; then
                  echo "Application is ready!"
                  break
                fi
                echo "Waiting for application... ($timeout seconds remaining)"
                sleep 2
                timeout=$((timeout-2))
              done

              if [ $timeout -le 0 ]; then
                echo "Application failed to start within timeout"
                echo "Application logs:"
                cat app.log
                exit 1
              fi
            displayName: "Start application in background"
            env:
              ASPNETCORE_ENVIRONMENT: "Development"
              ASPNETCORE_URLS: "http://localhost:5000"
              USE_INMEMORY_DB: "true"

          - script: |
              echo "Waiting for application to start..."
              timeout=60
              while [ $timeout -gt 0 ]; do
                if curl -f http://localhost:5000 >/dev/null 2>&1; then
                  echo "Application is ready!"
                  break
                fi
                echo "Waiting for application... ($timeout seconds remaining)"
                sleep 2
                timeout=$((timeout-2))
              done

              if [ $timeout -le 0 ]; then
                echo "Application failed to start within timeout"
                exit 1
              fi
            displayName: "Wait for application to be ready"

          - script: |
              echo "=== Pre-test debugging ==="
              echo "Checking if UITests project built correctly..."
              ls -la AiStockTradeApp.UITests/bin/Release/net9.0/ || echo "Build output directory not found"

              echo "Checking for required assemblies..."
              ls -la AiStockTradeApp.UITests/bin/Release/net9.0/*Playwright* || echo "Playwright assemblies not found"
              ls -la AiStockTradeApp.UITests/bin/Release/net9.0/*NUnit* || echo "NUnit assemblies not found"

              echo "Checking test.runsettings file..."
              cat test.runsettings || echo "test.runsettings not found"

              echo "Environment variables:"
              echo "PLAYWRIGHT_BASE_URL: $PLAYWRIGHT_BASE_URL"
              echo "ASPNETCORE_ENVIRONMENT: $ASPNETCORE_ENVIRONMENT"
              echo "DISPLAY: $DISPLAY"
              echo "CI: $CI"
              echo "AZURE_PIPELINES: $AZURE_PIPELINES"

              echo "Testing application accessibility..."
              curl -v http://localhost:5000 || echo "Application not responding"

              echo "Skipping X11 display probe (not required for headless Chromium)"

              echo "Checking Playwright installation (npx)..."
              (cd AiStockTradeApp.UITests && npx playwright --version) || echo "Playwright CLI not available"

              echo "Checking if Playwright browsers are installed..."
              ls -la /ms/playwright/ || echo "Playwright browser cache not found"
              find ~/.cache/ms-playwright -name "chromium*" -type d | head -5 || echo "Chromium browser not found"

              echo "Testing simple browser launch..."
              echo "Testing simple browser launch via dotnet playwright (dry run using codegen list)..."
              (cd AiStockTradeApp.UITests && npx playwright install chromium) || true
              # Quick launch validation using a minimal script
                echo "Installing dotnet-script for inline launch probe..."
                dotnet tool install --global dotnet-script || true
                export PATH="$PATH:$HOME/.dotnet/tools"
              cat > mini-browser-test.csx <<'CSX'
              #r "nuget: Microsoft.Playwright"
              using Microsoft.Playwright;
              var pw = await Playwright.CreateAsync();
              var browser = await pw.Chromium.LaunchAsync(new() { Headless = true, Args = new[]{"--no-sandbox","--disable-setuid-sandbox","--disable-dev-shm-usage"} });
              var ctx = await browser.NewContextAsync();
              var page = await ctx.NewPageAsync();
              await page.GotoAsync("https://example.com");
              Console.WriteLine("Browser navigation OK: " + await page.TitleAsync());
              await browser.CloseAsync();
              CSX
              dotnet script mini-browser-test.csx || echo "Mini browser test failed (will let tests attempt)."
            displayName: "Pre-test debugging"
            env:
              ASPNETCORE_ENVIRONMENT: "Development"
              PLAYWRIGHT_BASE_URL: "http://localhost:5000"
              DISPLAY: ":99.0"
              CI: "true"
              AZURE_PIPELINES: "true"
              USE_INMEMORY_DB: "true" # Use EF in-memory provider for faster UI tests

          - script: |
              echo "Listing all tests in UITests project..."
              dotnet test AiStockTradeApp.UITests --list-tests --verbosity normal
            displayName: "List UI Tests to be executed"

          - task: DotNetCoreCLI@2
            displayName: "Run Playwright UI Tests"
            inputs:
              command: "test"
              projects: "AiStockTradeApp.UITests/AiStockTradeApp.UITests.csproj"
              arguments: '--no-build --configuration Release --verbosity diagnostic --logger "trx;LogFileName=ui-test-results.trx" --settings ./test.runsettings --logger "console;verbosity=diagnostic" --results-directory "$(Agent.TempDirectory)"'
              publishTestResults: false
            env:
              ASPNETCORE_ENVIRONMENT: "Development"
              PLAYWRIGHT_BASE_URL: "http://localhost:5000"
              ConnectionStrings__DefaultConnection: "Server=localhost;Database=StockTrackerTestUI;User Id=sa;Password=YourStrong@Passw0rd;TrustServerCertificate=true;Encrypt=false"
              DISPLAY: ":99.0"
              PLAYWRIGHT_LAUNCH_OPTIONS: '{"headless":true,"args":["--no-sandbox","--disable-setuid-sandbox","--disable-dev-shm-usage","--disable-gpu","--no-first-run","--no-default-browser-check","--disable-background-timer-throttling","--disable-backgrounding-occluded-windows","--disable-renderer-backgrounding"]}'
              PWDEBUG: "0"
              DEBUG: "pw:api"
              CI: "true"
              AZURE_PIPELINES: "true"
              NODE_PATH: "$(System.DefaultWorkingDirectory)/AiStockTradeApp.UITests/node_modules"
              USE_INMEMORY_DB: "true" # In-memory DB accelerates UI tests
              VSTEST_RESULTS_DIRECTORY: "$(Agent.TempDirectory)"
            condition: succeededOrFailed()
            timeoutInMinutes: 25

          - task: Bash@3
            displayName: "Diagnostics: List UI TRX in Agent.TempDirectory"
            inputs:
              targetType: inline
              script: |
                echo "Agent temp TRX files (UI):"
                find $(Agent.TempDirectory) -type f -name '*.trx' 2>/dev/null | head -40 || true
            condition: always()

          - task: Bash@3
            displayName: "Fallback: Copy UI TRX from workspace TestResults to Agent.TempDirectory"
            condition: always()
            inputs:
              targetType: inline
              script: |
                set -e
                SRC_DIR="$(System.DefaultWorkingDirectory)/TestResults"
                DEST_DIR="$(Agent.TempDirectory)"
                if [ -d "$SRC_DIR" ]; then
                  FOUND=$(find "$SRC_DIR" -type f -name '*ui-test-results.trx' | wc -l)
                  if [ "$FOUND" -gt 0 ]; then
                    echo "Found $FOUND UI TRX in $SRC_DIR. Copying to $DEST_DIR..."
                    find "$SRC_DIR" -type f -name '*ui-test-results.trx' -exec cp {} "$DEST_DIR/" \;
                  else
                    echo "No UI TRX in $SRC_DIR"
                  fi
                else
                  echo "No workspace TestResults directory present"
                fi

          - task: PublishTestResults@2
            displayName: "Publish UI Test Results"
            inputs:
              testResultsFormat: "VSTest"
              testResultsFiles: "*.trx"
              searchFolder: "$(Agent.TempDirectory)"
              testRunTitle: "Playwright UI Tests_$(Build.BuildId)"
              mergeTestResults: true
            condition: succeededOrFailed()

          - task: Bash@3
            displayName: "Collect UI TRX for artifact"
            condition: always()
            inputs:
              targetType: inline
              script: |
                set -e
                DEST="$(Pipeline.Workspace)/test-results/ui"
                mkdir -p "$DEST"
                echo "Collecting TRX from $(Agent.TempDirectory) to $DEST"
                find "$(Agent.TempDirectory)" -type f -name '*ui-test-results.trx' -print -exec cp {} "$DEST/" \; 2>/dev/null || true

          - task: PublishPipelineArtifact@1
            displayName: "Upload UI Test TRX"
            condition: always()
            inputs:
              targetPath: "$(Pipeline.Workspace)/test-results/ui"
              artifactName: "ui-test-results"

          - script: |
              echo "Capturing application logs for debugging..."
              if [ -f "AiStockTradeApp/app.log" ]; then
                echo "=== Application Logs ==="
                cat AiStockTradeApp/app.log
                echo "=== End Application Logs ==="
              else
                echo "No application log file found"
              fi
            displayName: "Debug: Show application logs"
            condition: failed()

          - script: |
              echo "Stopping application..."
              if [ -f "AiStockTradeApp/app.pid" ]; then
                APP_PID=$(cat AiStockTradeApp/app.pid)
                echo "Stopping application with PID: $APP_PID"
                kill $APP_PID || true
                sleep 5
              fi
              # Cleanup any remaining dotnet processes
              pkill -f "dotnet.*AiStockTradeApp" || true
            displayName: "Stop application"
            condition: always()

          # No SQL container used; cleanup not required

  - stage: Build
    displayName: "Build and Push Container"
    dependsOn: Test
    condition: succeeded()
    jobs:
      - job: BuildJob
        displayName: "Build and Push Container (UI + API)"
        variables:
          - name: containerImage
            value: ""
          - name: containerImageApi
            value: ""
          - name: registryName
            value: ""
          - name: resourceGroup
            value: ""
          - name: instanceNum
            value: ""

        steps:
          - checkout: self
            displayName: "Checkout code"
            fetchDepth: 0
            persistCredentials: true
            clean: true
          - task: Bash@3
            displayName: "Docker pre-clean (global)"
            inputs:
              targetType: inline
              script: |
                docker ps -aq | xargs -r docker rm -f || true
                docker image prune -af || true

          - task: AzureCLI@2
            displayName: "Get Container Registry Information"
            inputs:
              azureSubscription: "$(AZURE_SERVICE_CONNECTION)"
              scriptType: "bash"
              scriptLocation: "inlineScript"
              inlineScript: |
                # Always use dev environment container registry (shared across all environments)
                if [[ "$(Build.Reason)" == "Manual" ]]; then
                  INSTANCE_NUM="${{ parameters.instanceNumber }}"
                  echo "Manual trigger detected - Instance: ${INSTANCE_NUM}"
                else
                  INSTANCE_NUM="003"
                  echo "Branch push detected - Using default instance: ${INSTANCE_NUM}"
                fi

                # Always target dev resource group for container registry
                ENV="dev"
                RG_NAME="rg-aistock-${ENV}-${INSTANCE_NUM}"

                echo "=== BUILD ENVIRONMENT INFO ==="
                echo "Container Registry Environment: ${ENV} (shared registry)"
                echo "Instance Number: ${INSTANCE_NUM}"
                echo "Registry Resource Group: ${RG_NAME}"
                echo "Build Source Branch: $(Build.SourceBranch)"
                echo "Build Reason: $(Build.Reason)"

                # Get container registry name from dev resource group
                REGISTRY_NAME=$(az acr list --resource-group "${RG_NAME}" --query '[0].name' --output tsv)

                if [ -z "${REGISTRY_NAME}" ] || [ "${REGISTRY_NAME}" == "null" ]; then
                  echo "ERROR: No container registry found in resource group ${RG_NAME}"
                  echo "Available resource groups:"
                  az group list --query '[].name' --output table
                  echo "This might mean the dev infrastructure hasn't been deployed yet for instance ${INSTANCE_NUM}"
                  echo "Please deploy dev environment first to create the shared container registry."
                  exit 1
                fi

                echo "Found shared registry: ${REGISTRY_NAME}"
                echo "##vso[task.setvariable variable=registryName]${REGISTRY_NAME}"
                echo "##vso[task.setvariable variable=resourceGroup]${RG_NAME}"
                echo "##vso[task.setvariable variable=instanceNum]${INSTANCE_NUM}"

          - task: AzureCLI@2
            displayName: "Get Container Registry Credentials"
            inputs:
              azureSubscription: "$(AZURE_SERVICE_CONNECTION)"
              scriptType: "bash"
              scriptLocation: "inlineScript"
              inlineScript: |
                # Get admin credentials
                REGISTRY_USERNAME=$(az acr credential show --name "$(registryName)" --query 'username' --output tsv)
                REGISTRY_PASSWORD=$(az acr credential show --name "$(registryName)" --query 'passwords[0].value' --output tsv)

                echo "Registry Username: ${REGISTRY_USERNAME}"
                echo "Password length: ${#REGISTRY_PASSWORD}"

                echo "##vso[task.setvariable variable=registryUsername;issecret=true]${REGISTRY_USERNAME}"
                echo "##vso[task.setvariable variable=registryPassword;issecret=true]${REGISTRY_PASSWORD}"

          - task: Bash@3
            displayName: "Debug Registry Information"
            inputs:
              targetType: "inline"
              script: |
                echo "=== REGISTRY DEBUG INFO ==="
                echo "Instance Number: $(instanceNum)"
                echo "Registry name: $(registryName)"
                echo "Resource group: $(resourceGroup)"
                echo "Registry URL: $(registryName).azurecr.io"
                echo "=== TRIGGER INFO ==="
                echo "Build Source Branch: $(Build.SourceBranch)"
                echo "Build Reason: $(Build.Reason)"

          - task: AzureCLI@2
            displayName: "Login to Azure Container Registry"
            inputs:
              azureSubscription: "$(AZURE_SERVICE_CONNECTION)"
              scriptType: "bash"
              scriptLocation: "inlineScript"
              inlineScript: |
                echo "Logging in to Azure Container Registry: $(registryName).azurecr.io"
                az acr login --name "$(registryName)"

          - task: Bash@3
            displayName: "Determine Semantic Version (GitVersion CLI for Build)"
            inputs:
              targetType: inline
              script: |
                set -e
                if [ -n "$(GitVersion.FullSemVer)" ]; then
                  echo "GitVersion variables already present from previous stage/job: $(GitVersion.FullSemVer)"; exit 0; fi
                echo "Ensuring full git history & tags (safety fetch)..."
                git fetch --prune --tags --force || true
                echo "Commit count: $(git rev-list --count HEAD 2>/dev/null || echo '?')"
                git --no-pager log --oneline -n 5 || true
                echo "Installing GitVersion CLI (build stage)..."
                dotnet tool install --global GitVersion.Tool --version 5.* || { echo "Failed to install GitVersion.Tool"; exit 1; }
                export PATH="$PATH:$HOME/.dotnet/tools"
                RAW=$(dotnet-gitversion /config GitVersion.yml /output json 2>&1 || true)
                echo "Raw GitVersion output (first 40 lines):"; echo "$RAW" | head -40
                if ! echo "$RAW" | grep -q '"FullSemVer"'; then
                  echo "GitVersion failed or missing JSON; using placeholder version"; FULL="0.0.0-local";
                else
                  if ! command -v jq >/dev/null 2>&1; then sudo apt-get update -y && sudo apt-get install -y jq; fi
                  FULL=$(echo "$RAW" | jq -r '.FullSemVer // empty')
                  [ -n "$FULL" ] || FULL="0.0.0-local"
                fi
                echo "FullSemVer (build)=$FULL"
                echo "##vso[task.setvariable variable=GitVersion.FullSemVer]$FULL"
                echo "##vso[task.setvariable variable=FullSemVer]$FULL"

          - task: Bash@3
            displayName: "Show resolved semantic version (post GitVersion)"
            inputs:
              targetType: inline
              script: |
                echo "Resolved GitVersion.FullSemVer='$(GitVersion.FullSemVer)'"
                if [ "$(GitVersion.FullSemVer)" = "0.0.0-local" ] || [ -z "$(GitVersion.FullSemVer)" ]; then
                  echo "WARNING: Semantic version is placeholder. Investigate GitVersion output above. Tag push will skip.";
                fi

          - task: Bash@3
            displayName: "Generate Container Tags"
            inputs:
              targetType: "inline"
              script: |
                echo "=== GitVersion (if present) ==="
                if [ -n "$(GitVersion.FullSemVer)" ]; then
                  echo "FullSemVer: $(GitVersion.FullSemVer)"
                else
                  echo "GitVersion variables not set; falling back to branch/sha tags only."
                fi
                # Generate tags similar to docker/metadata-action
                REGISTRY_URL="$(registryName).azurecr.io"
                IMAGE_NAME_UI="${REGISTRY_URL}/aistocktradeapp"
                IMAGE_NAME_API="${REGISTRY_URL}/aistocktradeapp-api"

                # Branch-based tag
                BRANCH_NAME=$(echo "$(Build.SourceBranchName)" | sed 's/[^a-zA-Z0-9._-]/-/g')
                BRANCH_TAG_UI="${IMAGE_NAME_UI}:${BRANCH_NAME}"
                BRANCH_TAG_API="${IMAGE_NAME_API}:${BRANCH_NAME}"

                # SHA-based tag
                SHORT_SHA=$(echo "$(Build.SourceVersion)" | cut -c1-7)
                SHA_TAG_UI="${IMAGE_NAME_UI}:sha-${SHORT_SHA}"
                SHA_TAG_API="${IMAGE_NAME_API}:sha-${SHORT_SHA}"

                # Latest tag for main/master branch
                VERSION_TAG_UI=""; VERSION_TAG_API=""
                if [ -n "$(GitVersion.FullSemVer)" ]; then
                  VERSION_TAG_UI="${IMAGE_NAME_UI}:$(GitVersion.FullSemVer)"
                  VERSION_TAG_API="${IMAGE_NAME_API}:$(GitVersion.FullSemVer)"
                fi
                if [[ "$(Build.SourceBranchName)" == "main" || "$(Build.SourceBranchName)" == "master" ]]; then
                  LATEST_TAG_UI="${IMAGE_NAME_UI}:latest"; LATEST_TAG_API="${IMAGE_NAME_API}:latest"
                  if [ -n "$VERSION_TAG_UI" ]; then
                    TAGS_UI="${BRANCH_TAG_UI},${SHA_TAG_UI},${VERSION_TAG_UI},${LATEST_TAG_UI}"
                    TAGS_API="${BRANCH_TAG_API},${SHA_TAG_API},${VERSION_TAG_API},${LATEST_TAG_API}"
                  else
                    TAGS_UI="${BRANCH_TAG_UI},${SHA_TAG_UI},${LATEST_TAG_UI}"
                    TAGS_API="${BRANCH_TAG_API},${SHA_TAG_API},${LATEST_TAG_API}"
                  fi
                else
                  if [ -n "$VERSION_TAG_UI" ]; then
                    TAGS_UI="${BRANCH_TAG_UI},${SHA_TAG_UI},${VERSION_TAG_UI}"
                    TAGS_API="${BRANCH_TAG_API},${SHA_TAG_API},${VERSION_TAG_API}"
                  else
                    TAGS_UI="${BRANCH_TAG_UI},${SHA_TAG_UI}"
                    TAGS_API="${BRANCH_TAG_API},${SHA_TAG_API}"
                  fi
                fi

                echo "Generated UI tags: ${TAGS_UI}"
                echo "Generated API tags: ${TAGS_API}"
                echo "##vso[task.setvariable variable=containerTagsUI]${TAGS_UI}"
                echo "##vso[task.setvariable variable=containerTagsAPI]${TAGS_API}"

                DEPLOY_TAG_UI="${SHA_TAG_UI}"; DEPLOY_TAG_API="${SHA_TAG_API}"
                if [ -n "$VERSION_TAG_UI" ]; then DEPLOY_TAG_UI="$VERSION_TAG_UI"; fi
                if [ -n "$VERSION_TAG_API" ]; then DEPLOY_TAG_API="$VERSION_TAG_API"; fi
                echo "Selected UI deploy tag: ${DEPLOY_TAG_UI}"
                echo "Selected API deploy tag: ${DEPLOY_TAG_API}"
                echo "##vso[task.setvariable variable=deployTagUI]${DEPLOY_TAG_UI}"
                echo "##vso[task.setvariable variable=deployTagAPI]${DEPLOY_TAG_API}"

          - task: AzureCLI@2
            displayName: "Build and push Docker images (UI + API)"
            inputs:
              azureSubscription: "$(AZURE_SERVICE_CONNECTION)"
              scriptType: "bash"
              scriptLocation: "inlineScript"
              inlineScript: |
                echo "=== BUILDING AND PUSHING CONTAINER IMAGE ==="

                # Parse container tags into individual arrays
                IFS=',' read -ra TAG_ARRAY_UI <<< "$(containerTagsUI)"
                IFS=',' read -ra TAG_ARRAY_API <<< "$(containerTagsAPI)"

                # Build UI image
                echo "Building UI Docker image..."
                if [ -n "$(GitVersion.FullSemVer)" ] && [ "$(GitVersion.FullSemVer)" != "0.0.0-local" ]; then
                  docker build --build-arg APP_VERSION=$(GitVersion.FullSemVer) -f ./AiStockTradeApp/Dockerfile -t temp-build-image-ui .
                else
                  docker build -f ./AiStockTradeApp/Dockerfile -t temp-build-image-ui .
                fi

                # Build API image
                echo "Building API Docker image..."
                if [ -n "$(GitVersion.FullSemVer)" ] && [ "$(GitVersion.FullSemVer)" != "0.0.0-local" ]; then
                  docker build --build-arg APP_VERSION=$(GitVersion.FullSemVer) -f ./AiStockTradeApp.Api/Dockerfile -t temp-build-image-api .
                else
                  docker build -f ./AiStockTradeApp.Api/Dockerfile -t temp-build-image-api .
                fi

                # Push UI tags
                for tag in "${TAG_ARRAY_UI[@]}"; do
                  clean_tag=$(echo "$tag" | xargs)
                  echo "Tagging and pushing UI: $clean_tag"
                  docker tag temp-build-image-ui "$clean_tag"
                  az acr repository show --name "$(registryName)" --repository aistocktradeapp || echo "Repository will be created"
                  docker push "$clean_tag"
                done

                # Push API tags
                for tag in "${TAG_ARRAY_API[@]}"; do
                  clean_tag=$(echo "$tag" | xargs)
                  echo "Tagging and pushing API: $clean_tag"
                  docker tag temp-build-image-api "$clean_tag"
                  az acr repository show --name "$(registryName)" --repository aistocktradeapp-api || echo "Repository will be created"
                  docker push "$clean_tag"
                done

                echo "All UI and API tags pushed successfully"
                echo "UI Deploy tag: $(deployTagUI)"
                echo "API Deploy tag: $(deployTagAPI)"

          - task: Bash@3
            displayName: "Create and push git semantic tag"
            condition: or(eq(variables['Build.SourceBranch'], 'refs/heads/main'), eq(variables['Build.SourceBranch'], 'refs/heads/develop'))
            inputs:
              targetType: inline
              script: |
                set -e
                VERSION="$(GitVersion.FullSemVer)"
                if [ -z "$VERSION" ] || [ "$VERSION" = "0.0.0-local" ]; then
                  echo "No valid semantic version available; skipping git tag."; exit 0; fi
                if [[ "$VERSION" != v* ]]; then VERSION="v$VERSION"; fi
                git config user.name "ci-bot"
                git config user.email "ci-bot@users.noreply.local"
                # Ensure tags are current before creating new one
                echo "Preparing to create tag $VERSION on commit $(Build.SourceVersion)"
                git fetch --tags --prune || true
                if git rev-parse -q --verify "refs/tags/$VERSION" >/dev/null; then
                  echo "Tag $VERSION already exists; skipping."; exit 0; fi
                git tag -a "$VERSION" -m "Release $VERSION (Azure DevOps CI)" $(Build.SourceVersion)
                # Use OAuth token if available
                if [ -n "$SYSTEM_ACCESSTOKEN" ]; then
                  git -c http.extraheader="AUTHORIZATION: bearer $SYSTEM_ACCESSTOKEN" push origin "$VERSION" || {
                    echo "Tag push failed even with token"; exit 1; }
                else
                  git push origin "$VERSION" || echo "Push failed (no SYSTEM_ACCESSTOKEN)"
                fi
                echo "Tag operation complete"
            env:
              SYSTEM_ACCESSTOKEN: $(System.AccessToken)

          - task: Bash@3
            displayName: "Extract and set container image for deployment"
            inputs:
              targetType: "inline"
              script: |
                set -e  # Exit on any error
                echo "=== SETTING DEPLOYMENT IMAGE ==="

                DEPLOY_IMAGE="$(deployTagUI)"
                echo "Final deployment image: '${DEPLOY_IMAGE}'"

                # Check if DEPLOY_IMAGE is empty
                if [ -z "${DEPLOY_IMAGE}" ]; then
                  echo "ERROR: DEPLOY_IMAGE is empty after processing!"
                  exit 1
                fi

                # Write to artifact file for reliable transfer
                echo "=== CREATING ARTIFACT ==="
                mkdir -p $(Pipeline.Workspace)/build-outputs
                echo "${DEPLOY_IMAGE}" > $(Pipeline.Workspace)/build-outputs/container-image.txt
                echo "hello-from-build-stage" > $(Pipeline.Workspace)/build-outputs/test-output.txt

                echo "Artifact files created:"
                ls -la $(Pipeline.Workspace)/build-outputs/
                echo "Container image file contents:"
                cat $(Pipeline.Workspace)/build-outputs/container-image.txt

                echo "##vso[task.setvariable variable=containerImage;isOutput=true]${DEPLOY_IMAGE}"

          - task: Bash@3
            displayName: "Extract and set API container image for deployment"
            inputs:
              targetType: "inline"
              script: |
                set -e
                echo "=== SETTING API DEPLOYMENT IMAGE ==="
                DEPLOY_IMAGE_API="$(deployTagAPI)"
                echo "API deployment image: '${DEPLOY_IMAGE_API}'"
                if [ -z "${DEPLOY_IMAGE_API}" ]; then echo "ERROR: API DEPLOY_IMAGE empty"; exit 1; fi
                mkdir -p $(Pipeline.Workspace)/build-outputs
                echo "${DEPLOY_IMAGE_API}" > $(Pipeline.Workspace)/build-outputs/container-image-api.txt
                echo "##vso[task.setvariable variable=containerImageApi;isOutput=true]${DEPLOY_IMAGE_API}"

          - task: PublishPipelineArtifact@1
            displayName: "Upload build outputs as artifact"
            inputs:
              targetPath: "$(Pipeline.Workspace)/build-outputs"
              artifactName: "build-outputs"

  - stage: DeployDev
    displayName: "Deploy to Development"
    dependsOn: Build
    condition: |
      and(
        succeeded(),
        or(
          eq(variables['Build.SourceBranch'], 'refs/heads/develop'),
          eq(variables['Build.SourceBranch'], 'refs/heads/main'),
          and(
            eq(variables['Build.Reason'], 'Manual'),
            eq('${{ parameters.environment }}', 'dev')
          )
        )
      )
    jobs:
      - deployment: DeployDevJob
        displayName: "Deploy to Development"
        environment: ${{ format('development-{0}', parameters.instanceNumber) }}
        variables:
          - name: instanceNum
            value: ${{ format('{0}', parameters.instanceNumber) }}
        strategy:
          runOnce:
            deploy:
              steps:
                - checkout: self
                  displayName: "Checkout code"
                  fetchDepth: 0
                  persistCredentials: true
                  clean: true

                - task: DownloadPipelineArtifact@2
                  displayName: "Download build outputs"
                  inputs:
                    artifactName: "build-outputs"
                    downloadPath: "$(Pipeline.Workspace)/build-outputs"

                - task: Bash@3
                  displayName: "Load container image from artifact"
                  inputs:
                    targetType: "inline"
                    script: |
                      echo "=== LOADING CONTAINER IMAGE FROM ARTIFACT ==="
                      if [ -f "$(Pipeline.Workspace)/build-outputs/container-image.txt" ]; then
                        CONTAINER_IMAGE=$(cat $(Pipeline.Workspace)/build-outputs/container-image.txt)
                        echo "Container image from artifact: '${CONTAINER_IMAGE}'"
                        echo "##vso[task.setvariable variable=containerImage]${CONTAINER_IMAGE}"
                      else
                        echo "ERROR: container-image.txt not found in artifacts!"
                        ls -la $(Pipeline.Workspace)/build-outputs/
                        exit 1
                      fi
                - task: Bash@3
                  displayName: "Load API container image from artifact"
                  inputs:
                    targetType: "inline"
                    script: |
                      echo "=== LOADING API CONTAINER IMAGE FROM ARTIFACT ==="
                      if [ -f "$(Pipeline.Workspace)/build-outputs/container-image-api.txt" ]; then
                        CONTAINER_IMAGE=$(cat $(Pipeline.Workspace)/build-outputs/container-image-api.txt)
                        echo "API container image from artifact: '${CONTAINER_IMAGE}'"
                        echo "##vso[task.setvariable variable=containerImageApi]${CONTAINER_IMAGE}"
                      else
                        echo "ERROR: container-image-api.txt not found in artifacts!"
                        ls -la $(Pipeline.Workspace)/build-outputs/
                        exit 1
                      fi
                - task: Bash@3
                  displayName: "Derive appVersion parameter (Dev)"
                  inputs:
                    targetType: "inline"
                    script: |
                      IMG="$(containerImage)"
                      TAG="${IMG##*:}"
                      if echo "$TAG" | grep -Eq '^[0-9]+\.[0-9]+\.[0-9]+'; then
                        echo "Semantic version detected in image tag: $TAG"
                        echo "##vso[task.setvariable variable=appVersion]$TAG"
                      else
                        echo "Image tag $TAG is not semantic version; leaving appVersion empty"
                      fi

                - task: AzureResourceManagerTemplateDeployment@3
                  displayName: "Deploy Bicep template"
                  inputs:
                    deploymentScope: "Resource Group"
                    azureResourceManagerConnection: "$(AZURE_SERVICE_CONNECTION)"
                    subscriptionId: "$(AZURE_SUBSCRIPTION_ID)"
                    action: "Create Or Update Resource Group"
                    resourceGroupName: "rg-aistock-dev-$(instanceNum)"
                    location: "Canada Central"
                    templateLocation: "Linked artifact"
                    csmFile: "./infrastructure/main.bicep"
                    csmParametersFile: "./infrastructure/parameters.dev.json"
                    overrideParameters: "-instanceNumber $(instanceNum) -containerImage $(containerImage) -containerImageApi $(containerImageApi) -alphaVantageApiKey $(ALPHA_VANTAGE_API_KEY) -twelveDataApiKey $(TWELVE_DATA_API_KEY) -appVersion $(appVersion) -enableAzureAdOnlyAuth true -enablePrivateSql true -enablePrivateKeyVault true -manageNetworking false"
                    deploymentMode: "Incremental"

                - task: AzureCLI@2
                  displayName: "Ensure SQL AD admin matches Web App Managed Identity (Dev)"
                  inputs:
                    azureSubscription: "$(AZURE_SERVICE_CONNECTION)"
                    scriptType: bash
                    scriptLocation: inlineScript
                    inlineScript: |
                      set -e
                      RG_NAME="rg-aistock-dev-$(instanceNum)"
                      WEBAPP_NAME="app-aistock-dev-$(instanceNum)"
                      SQL_SERVER_NAME="sql-aistock-dev-$(instanceNum)"
                      echo "[DEV] Ensuring SQL AD admin is set to Web App MI..."
                      MI_PRINCIPAL_ID=$(az webapp identity show --name "$WEBAPP_NAME" --resource-group "$RG_NAME" --query principalId -o tsv 2>/dev/null || echo "")
                      if [ -z "$MI_PRINCIPAL_ID" ] || [ "$MI_PRINCIPAL_ID" = "null" ]; then echo "[DEV][ERROR] Web app MI principalId not found"; exit 1; fi
                      CURR_LOGIN=$(az sql server ad-admin list --server "$SQL_SERVER_NAME" --resource-group "$RG_NAME" --query "[0].login" -o tsv 2>/dev/null || echo "")
                      CURR_SID=$(az sql server ad-admin list --server "$SQL_SERVER_NAME" --resource-group "$RG_NAME" --query "[0].sid" -o tsv 2>/dev/null || echo "")
                      echo "[DEV] Web App MI: $MI_PRINCIPAL_ID"; echo "[DEV] Current admin login: $CURR_LOGIN"; echo "[DEV] Current admin sid: $CURR_SID"
                      if [ "$CURR_SID" != "$MI_PRINCIPAL_ID" ]; then
                        echo "[DEV] Mismatch detected; updating SQL AD admin to MI..."
                        az sql server ad-admin delete --server "$SQL_SERVER_NAME" --resource-group "$RG_NAME" || true
                        az sql server ad-admin create --server "$SQL_SERVER_NAME" --resource-group "$RG_NAME" --display-name "$WEBAPP_NAME" --object-id "$MI_PRINCIPAL_ID"
                      else
                        echo "[DEV] Already correct; no change needed."
                      fi
                      # Re-verify
                      NEW_SID=$(az sql server ad-admin list --server "$SQL_SERVER_NAME" --resource-group "$RG_NAME" --query "[0].sid" -o tsv 2>/dev/null || echo "")
                      if [ "$NEW_SID" != "$MI_PRINCIPAL_ID" ]; then
                        echo "[DEV][ERROR] Re-verify failed: SQL AD admin still not MI (expected=$MI_PRINCIPAL_ID, found=$NEW_SID)"; exit 1
                      fi
                      echo "[DEV] ✅ SQL AD admin set to Web App MI."

                - task: AzureCLI@2
                  displayName: "Update Web App Container"
                  inputs:
                    azureSubscription: "$(AZURE_SERVICE_CONNECTION)"
                    scriptType: "bash"
                    scriptLocation: "inlineScript"
                    inlineScript: |
                      WEBAPP_NAME="app-aistock-dev-$(instanceNum)"
                      RG_NAME="rg-aistock-dev-$(instanceNum)"

                      # Get registry information from the same resource group
                      REGISTRY_NAME=$(az acr list --resource-group "${RG_NAME}" --query '[0].name' --output tsv)
                      REGISTRY_USERNAME=$(az acr credential show --name "${REGISTRY_NAME}" --query 'username' --output tsv)
                      REGISTRY_PASSWORD=$(az acr credential show --name "${REGISTRY_NAME}" --query 'passwords[0].value' --output tsv)

                      echo "Container Image: $(containerImage)"
                      echo "Web App Name: ${WEBAPP_NAME}"
                      echo "Resource Group: ${RG_NAME}"
                      echo "Registry Name: ${REGISTRY_NAME}"

                      if [ -z "$(containerImage)" ]; then
                        echo "ERROR: Container image is empty!"
                        exit 1
                      fi

                      az webapp config container set \
                        --name "${WEBAPP_NAME}" \
                        --resource-group "${RG_NAME}" \
                        --container-image-name "$(containerImage)" \
                        --container-registry-url "https://${REGISTRY_NAME}.azurecr.io" \
                        --container-registry-user "${REGISTRY_USERNAME}" \
                        --container-registry-password "${REGISTRY_PASSWORD}"

                - task: AzureCLI@2
                  displayName: "Update API Web App Container"
                  inputs:
                    azureSubscription: "$(AZURE_SERVICE_CONNECTION)"
                    scriptType: "bash"
                    scriptLocation: "inlineScript"
                    inlineScript: |
                      WEBAPP_NAME="api-aistock-dev-$(instanceNum)"
                      RG_NAME="rg-aistock-dev-$(instanceNum)"

                      REGISTRY_NAME=$(az acr list --resource-group "${RG_NAME}" --query '[0].name' --output tsv)
                      REGISTRY_USERNAME=$(az acr credential show --name "${REGISTRY_NAME}" --query 'username' --output tsv)
                      REGISTRY_PASSWORD=$(az acr credential show --name "${REGISTRY_NAME}" --query 'passwords[0].value' --output tsv)

                      echo "API Container Image: $(containerImageApi)"
                      echo "API Web App Name: ${WEBAPP_NAME}"
                      echo "Resource Group: ${RG_NAME}"
                      echo "Registry Name: ${REGISTRY_NAME}"

                      if [ -z "$(containerImageApi)" ]; then echo "ERROR: API container image is empty!"; exit 1; fi

                      az webapp config container set \
                        --name "${WEBAPP_NAME}" \
                        --resource-group "${RG_NAME}" \
                        --container-image-name "$(containerImageApi)" \
                        --container-registry-url "https://${REGISTRY_NAME}.azurecr.io" \
                        --container-registry-user "${REGISTRY_USERNAME}" \
                        --container-registry-password "${REGISTRY_PASSWORD}"

                - task: Bash@3
                  displayName: "Run Health Check"
                  inputs:
                    targetType: "inline"
                    script: |
                      WEBAPP_NAME="app-aistock-dev-$(instanceNum)"
                      HEALTH_URL="https://${WEBAPP_NAME}.azurewebsites.net/health"
                      echo "Waiting for deployment to be ready..."
                      echo "Health check URL: ${HEALTH_URL}"
                      sleep 30
                      curl -f "${HEALTH_URL}" || exit 1
                      echo "Health check passed!"

                - task: Bash@3
                  displayName: "Run API Health Check"
                  inputs:
                    targetType: "inline"
                    script: |
                      WEBAPP_NAME="api-aistock-dev-$(instanceNum)"
                      HEALTH_URL="https://${WEBAPP_NAME}.azurewebsites.net/health"
                      echo "Waiting for API deployment to be ready..."
                      echo "API Health check URL: ${HEALTH_URL}"
                      sleep 30
                      curl -f "${HEALTH_URL}" || exit 1
                      echo "API Health check passed!"

  - stage: DeployProd
    displayName: "Deploy to Production"
    dependsOn:
      - Build
      - DeployDev
    condition: |
      and(
        succeeded(),
        in(dependencies.Build.result, 'Succeeded'),
        in(dependencies.DeployDev.result, 'Succeeded', 'Skipped'),
        or(
          eq(variables['Build.SourceBranch'], 'refs/heads/main'),
          and(
            eq(variables['Build.Reason'], 'Manual'),
            eq('${{ parameters.environment }}', 'prod')
          )
        )
      )
    jobs:
      - deployment: DeployProdJob
        displayName: "Deploy to Production"
        environment: ${{ format('production-{0}', parameters.instanceNumber) }}
        variables:
          - name: instanceNum
            value: ${{ format('{0}', parameters.instanceNumber) }}
        strategy:
          runOnce:
            deploy:
              steps:
                - checkout: self
                  displayName: "Checkout code"
                  fetchDepth: 0
                  persistCredentials: true
                  clean: true

                - task: DownloadPipelineArtifact@2
                  displayName: "Download build outputs"
                  inputs:
                    artifactName: "build-outputs"
                    downloadPath: "$(Pipeline.Workspace)/build-outputs"

                - task: Bash@3
                  displayName: "Load container image from artifact"
                  inputs:
                    targetType: "inline"
                    script: |
                      echo "=== LOADING CONTAINER IMAGE FROM ARTIFACT ==="
                      if [ -f "$(Pipeline.Workspace)/build-outputs/container-image.txt" ]; then
                        CONTAINER_IMAGE=$(cat $(Pipeline.Workspace)/build-outputs/container-image.txt)
                        echo "Container image from artifact: '${CONTAINER_IMAGE}'"
                        echo "##vso[task.setvariable variable=containerImage]${CONTAINER_IMAGE}"
                      else
                        echo "ERROR: container-image.txt not found in artifacts!"
                        ls -la $(Pipeline.Workspace)/build-outputs/
                        exit 1
                      fi
                - task: Bash@3
                  displayName: "Load API container image from artifact"
                  inputs:
                    targetType: "inline"
                    script: |
                      echo "=== LOADING API CONTAINER IMAGE FROM ARTIFACT ==="
                      if [ -f "$(Pipeline.Workspace)/build-outputs/container-image-api.txt" ]; then
                        CONTAINER_IMAGE=$(cat $(Pipeline.Workspace)/build-outputs/container-image-api.txt)
                        echo "API container image from artifact: '${CONTAINER_IMAGE}'"
                        echo "##vso[task.setvariable variable=containerImageApi]${CONTAINER_IMAGE}"
                      else
                        echo "ERROR: container-image-api.txt not found in artifacts!"
                        ls -la $(Pipeline.Workspace)/build-outputs/
                        exit 1
                      fi

                - task: Bash@3
                  displayName: "Debug Variables"
                  inputs:
                    targetType: "inline"
                    script: |
                      echo "=== DEPLOYMENT DEBUG INFO ==="
                      echo "Stage name: DeployProd"
                      echo "Build Source Branch: $(Build.SourceBranch)"
                      echo "Build Reason: $(Build.Reason)"
                      echo "Environment parameter: ${{ parameters.environment }}"
                      echo "Instance Number: $(instanceNum)"
                      echo "Resource Group: rg-aistock-prod-$(instanceNum)"
                      echo "Web App Name: app-aistock-prod-$(instanceNum)"
                      echo "Container image from artifact: $(containerImage)"

                - task: AzureCLI@2
                  displayName: "Get Azure AD information for SQL Admin"
                  inputs:
                    azureSubscription: "$(AZURE_SERVICE_CONNECTION)"
                    scriptType: "bash"
                    scriptLocation: "inlineScript"
                    inlineScript: |
                      echo "Getting Azure AD information for SQL Server administration..."

                      # Get the service principal information from the service connection
                      # The service connection provides authentication context
                      echo "Retrieving service principal information from connection context..."

                      # Get service principal details using Azure CLI context
                      SP_INFO=$(az account show)
                      TENANT_ID=$(echo "$SP_INFO" | jq -r '.tenantId')

                      # For Azure DevOps, we'll use a predefined service principal name or get it from variables
                      # This should be configured in your Azure DevOps variables
                      if [ -n "$(AZURE_CLIENT_ID)" ]; then
                        CLIENT_ID="$(AZURE_CLIENT_ID)"
                        echo "Using client ID from variable: $CLIENT_ID"
                        
                        SP_DETAILS=$(az ad sp show --id "$CLIENT_ID")
                        SP_OBJECT_ID=$(echo "$SP_DETAILS" | jq -r '.id')
                        SP_DISPLAY_NAME=$(echo "$SP_DETAILS" | jq -r '.displayName')
                      else
                        echo "AZURE_CLIENT_ID variable not set. Using account context..."
                        # Fallback: try to get service principal from current context
                        SUBSCRIPTION_INFO=$(az account show)
                        SP_OBJECT_ID=$(echo "$SUBSCRIPTION_INFO" | jq -r '.user.name')
                        SP_DISPLAY_NAME="Azure DevOps Service Principal"
                      fi

                      echo "Service principal object ID: $SP_OBJECT_ID"
                      echo "Service principal display name: $SP_DISPLAY_NAME"

                      echo "##vso[task.setvariable variable=azureAdAdminObjectId]$SP_OBJECT_ID"
                      echo "##vso[task.setvariable variable=azureAdAdminLogin]$SP_DISPLAY_NAME"

                - task: Bash@3
                  displayName: "Derive Azure AD auth enable flag"
                  inputs:
                    targetType: "inline"
                    script: |
                      echo "Evaluating whether to enable Azure AD only auth..."
                      # Use Azure DevOps variable syntax: $VARIABLE (already set earlier)
                      if [ -n "$azureAdAdminObjectId" ] && [ -n "$azureAdAdminLogin" ]; then
                        echo "Azure AD admin details present. Enabling AAD only auth."
                        echo "##vso[task.setvariable variable=enableAdOnlyAuthFlag]true"
                      else
                        echo "Azure AD admin details missing (objectId='$azureAdAdminObjectId', login='$azureAdAdminLogin'). Disabling AAD only auth for this deployment."
                        echo "##vso[task.setvariable variable=enableAdOnlyAuthFlag]false"
                      fi
                      echo "enableAdOnlyAuthFlag=$enableAdOnlyAuthFlag"

                - task: Bash@3
                  displayName: "Derive appVersion parameter (Prod)"
                  inputs:
                    targetType: "inline"
                    script: |
                      IMG="$(containerImage)"
                      TAG="${IMG##*:}"
                      if echo "$TAG" | grep -Eq '^[0-9]+\.[0-9]+\.[0-9]+'; then
                        echo "Semantic version detected in image tag: $TAG"
                        echo "##vso[task.setvariable variable=appVersion]$TAG"
                      else
                        echo "Image tag $TAG is not semantic version; leaving appVersion empty"
                      fi
                - task: AzureResourceManagerTemplateDeployment@3
                  displayName: "Deploy Bicep template (no SQL admin override)"
                  inputs:
                    deploymentScope: "Resource Group"
                    azureResourceManagerConnection: "$(AZURE_SERVICE_CONNECTION)"
                    subscriptionId: "$(AZURE_SUBSCRIPTION_ID)"
                    action: "Create Or Update Resource Group"
                    resourceGroupName: "rg-aistock-prod-$(instanceNum)"
                    location: "Canada Central"
                    templateLocation: "Linked artifact"
                    csmFile: "./infrastructure/main.bicep"
                    csmParametersFile: "./infrastructure/parameters.prod.json"
                    # Use containerImage variable if provided; prefer GitVersion FullSemVer tag if available
                    # containerImage variable expected to be AiStockTradeApp:<tag>
                    overrideParameters: "-instanceNumber $(instanceNum) -containerImage $(containerImage) -containerImageApi $(containerImageApi) -enableAzureAdOnlyAuth true -enablePrivateSql true -enablePrivateKeyVault true -manageNetworking false -azureAdAdminObjectId $(azureAdAdminObjectId) -azureAdAdminLogin '$(azureAdAdminLogin)' -appVersion $(appVersion)"
                    deploymentMode: "Incremental"

                - task: AzureCLI@2
                  displayName: "Ensure SQL AD admin matches Web App Managed Identity (Prod)"
                  inputs:
                    azureSubscription: "$(AZURE_SERVICE_CONNECTION)"
                    scriptType: bash
                    scriptLocation: inlineScript
                    inlineScript: |
                      set -e
                      RG_NAME="rg-aistock-prod-$(instanceNum)"
                      WEBAPP_NAME="app-aistock-prod-$(instanceNum)"
                      SQL_SERVER_NAME="sql-aistock-prod-$(instanceNum)"
                      echo "[PROD] Ensuring SQL AD admin is set to Web App MI..."
                      MI_PRINCIPAL_ID=$(az webapp identity show --name "$WEBAPP_NAME" --resource-group "$RG_NAME" --query principalId -o tsv 2>/dev/null || echo "")
                      if [ -z "$MI_PRINCIPAL_ID" ] || [ "$MI_PRINCIPAL_ID" = "null" ]; then echo "[PROD][ERROR] Web app MI principalId not found"; exit 1; fi
                      CURR_LOGIN=$(az sql server ad-admin list --server "$SQL_SERVER_NAME" --resource-group "$RG_NAME" --query "[0].login" -o tsv 2>/dev/null || echo "")
                      CURR_SID=$(az sql server ad-admin list --server "$SQL_SERVER_NAME" --resource-group "$RG_NAME" --query "[0].sid" -o tsv 2>/dev/null || echo "")
                      echo "[PROD] Web App MI: $MI_PRINCIPAL_ID"; echo "[PROD] Current admin login: $CURR_LOGIN"; echo "[PROD] Current admin sid: $CURR_SID"
                      if [ "$CURR_SID" != "$MI_PRINCIPAL_ID" ]; then
                        echo "[PROD] Mismatch detected; updating SQL AD admin to MI..."
                        az sql server ad-admin delete --server "$SQL_SERVER_NAME" --resource-group "$RG_NAME" || true
                        az sql server ad-admin create --server "$SQL_SERVER_NAME" --resource-group "$RG_NAME" --display-name "$WEBAPP_NAME" --object-id "$MI_PRINCIPAL_ID"
                      else
                        echo "[PROD] Already correct; no change needed."
                      fi
                      # Re-verify
                      NEW_SID=$(az sql server ad-admin list --server "$SQL_SERVER_NAME" --resource-group "$RG_NAME" --query "[0].sid" -o tsv 2>/dev/null || echo "")
                      if [ "$NEW_SID" != "$MI_PRINCIPAL_ID" ]; then
                        echo "[PROD][ERROR] Re-verify failed: SQL AD admin still not MI (expected=$MI_PRINCIPAL_ID, found=$NEW_SID)"; exit 1
                      fi
                      echo "[PROD] ✅ SQL AD admin set to Web App MI."

                # Removed re-assignment of SQL admin here; infra pipeline owns that responsibility.

                - task: AzureCLI@2
                  displayName: "Setup Web App SQL Database Access (Azure AD)"
                  inputs:
                    azureSubscription: "$(AZURE_SERVICE_CONNECTION)"
                    scriptType: "bash"
                    scriptLocation: "inlineScript"
                    inlineScript: |
                      # Do NOT 'set -e' globally; we handle retries manually
                      INSTANCE_NUM="$(instanceNum)"
                      RG_NAME="rg-aistock-prod-$(instanceNum)"
                      WEBAPP_NAME="app-aistock-prod-$(instanceNum)"
                      SQL_SERVER_NAME="sql-aistock-prod-$(instanceNum)"
                      DATABASE_NAME="sqldb-aistock-prod-$(instanceNum)"
                      ENABLE_AAD_ONLY="$(enableAdOnlyAuthFlag)"
                      echo "[INFO] === Managed identity SQL database access setup ==="
                      echo "[INFO] ENABLE_AAD_ONLY=${ENABLE_AAD_ONLY}"
                      if [ "${ENABLE_AAD_ONLY}" != "true" ]; then echo "[INFO] AAD-only auth disabled; skipping."; exit 0; fi
                      echo "[INFO] Ensuring web app managed identity enabled..."
                      MANAGED_IDENTITY=$(az webapp identity show --name "${WEBAPP_NAME}" --resource-group "${RG_NAME}" --query principalId -o tsv 2>/dev/null || echo "")
                      if [ -z "$MANAGED_IDENTITY" ] || [ "$MANAGED_IDENTITY" = "null" ]; then
                        az webapp identity assign --name "${WEBAPP_NAME}" --resource-group "${RG_NAME}" >/dev/null
                        sleep 8
                        MANAGED_IDENTITY=$(az webapp identity show --name "${WEBAPP_NAME}" --resource-group "${RG_NAME}" --query principalId -o tsv)
                      fi
                      echo "[INFO] Managed identity principalId: $MANAGED_IDENTITY"
                      SQL_SERVER_FQDN="${SQL_SERVER_NAME}.database.windows.net"
                      echo "[INFO] Waiting for database '${DATABASE_NAME}' to be online..."
                      for i in $(seq 1 18); do
                        ACCESS_TOKEN_TMP=$(az account get-access-token --resource https://database.windows.net/ --query accessToken -o tsv 2>/dev/null || echo "")
                        if [ -n "$ACCESS_TOKEN_TMP" ]; then
                          export SQLCMDACCESSTOKEN="$ACCESS_TOKEN_TMP"
                          if /opt/mssql-tools/bin/sqlcmd -S "$SQL_SERVER_FQDN" -d master -C -l 15 -h -1 -Q "SET NOCOUNT ON; SELECT state_desc FROM sys.databases WHERE name='${DATABASE_NAME}';" | grep -qi 'ONLINE'; then
                            echo "[INFO] Database is ONLINE (attempt $i)"; break
                          fi
                        fi
                        echo "[INFO] Database not online yet (attempt $i/18); sleeping 10s..."; sleep 10
                      done
                      echo "[INFO] Checking configured Azure AD admin on SQL server..."
                      ADMIN_CHECK_ATTEMPTS=12
                      ADMIN_SEEN=0
                      for i in $(seq 1 $ADMIN_CHECK_ATTEMPTS); do
                        ADMIN_LOGIN=$(az sql server ad-admin list --server "$SQL_SERVER_NAME" --resource-group "$RG_NAME" --query "[0].login" -o tsv 2>/dev/null || echo "")
                        if [ -n "$ADMIN_LOGIN" ] && [ "$ADMIN_LOGIN" != "null" ]; then
                          echo "[INFO] Azure AD admin detected: $ADMIN_LOGIN (attempt $i)"; ADMIN_SEEN=1; break
                        fi
                        echo "[INFO] Azure AD admin not yet visible (attempt $i/$ADMIN_CHECK_ATTEMPTS); waiting 10s..."
                        sleep 10
                      done
                      if [ "$ADMIN_SEEN" != "1" ]; then
                        echo "[WARN] Azure AD admin not visible after waiting. User creation may fail; continuing anyway."
                      fi
                      echo "[INFO] Installing sqlcmd tooling..."
                      curl -s https://packages.microsoft.com/keys/microsoft.asc | sudo apt-key add - >/dev/null
                      curl -s https://packages.microsoft.com/config/ubuntu/20.04/prod.list | sudo tee /etc/apt/sources.list.d/msprod.list >/dev/null
                      sudo apt-get update -y >/dev/null
                      sudo apt-get install -y mssql-tools unixodbc-dev >/dev/null
                      if ! timeout 5 bash -c "</dev/tcp/${SQL_SERVER_NAME}.database.windows.net/1433" 2>/dev/null; then echo "[ERROR] Port 1433 unreachable"; exit 1; fi
                      SQL_SCRIPT=$'USE [${DATABASE_NAME}];\nIF NOT EXISTS (SELECT 1 FROM sys.database_principals WHERE name='"'${WEBAPP_NAME}'"') BEGIN PRINT 'Creating user ${WEBAPP_NAME}'; CREATE USER [${WEBAPP_NAME}] FROM EXTERNAL PROVIDER; END;\nDECLARE @roles TABLE(r sysname); INSERT INTO @roles VALUES(\'db_datareader\'),(\'db_datawriter\'),(\'db_ddladmin\');\nDECLARE c CURSOR LOCAL FAST_FORWARD FOR SELECT r FROM @roles; OPEN c; DECLARE @r sysname; FETCH NEXT FROM c INTO @r;\nWHILE @@FETCH_STATUS=0 BEGIN IF IS_ROLEMEMBER(@r,\'${WEBAPP_NAME}\')=1 PRINT @r+\' already assigned\'; ELSE EXEC(\'ALTER ROLE \' +QUOTENAME(@r)+ ' ADD MEMBER [${WEBAPP_NAME}]\'); FETCH NEXT FROM c INTO @r; END CLOSE c; DEALLOCATE c;\nSELECT dp.name AS principal, r.name AS role_name FROM sys.database_principals dp JOIN sys.database_role_members rm ON dp.principal_id=rm.member_principal_id JOIN sys.database_principals r ON rm.role_principal_id=r.principal_id WHERE dp.name=\'${WEBAPP_NAME}\';'
                      printf '%s\n' "$SQL_SCRIPT" > setup_managed_identity.sql

                      echo "[INFO] Waiting for successful token-based connectivity..."
                      LOGIN_OK=0
                      for i in $(seq 1 12); do
                        ACCESS_TOKEN=$(az account get-access-token --resource https://database.windows.net/ --query accessToken -o tsv 2>/dev/null || echo "")
                        if [ -z "$ACCESS_TOKEN" ]; then echo "[INFO] (attempt $i) token not acquired, retrying in 10s"; sleep 10; continue; fi
                        export SQLCMDACCESSTOKEN="$ACCESS_TOKEN"
                        if /opt/mssql-tools/bin/sqlcmd -S "$SQL_SERVER_FQDN" -d master -C -l 15 -Q "SELECT 1" >/dev/null 2>&1; then
                          echo "[INFO] Token login succeeded on attempt $i"; LOGIN_OK=1; break
                        else
                          echo "[INFO] Token login failed (attempt $i); waiting 10s..."; sleep 10
                        fi
                      done
                      if [ "$LOGIN_OK" != "1" ]; then
                        echo "[WARN] Could not establish token login after retries. Skipping user creation to avoid hard failure."
                        exit 0
                      fi

                      echo "[INFO] Executing user/role script with retries..."
                      CREATE_OK=0
                      for i in $(seq 1 5); do
                        # Refresh token before each attempt (tokens ~ 1h but safe)
                        ACCESS_TOKEN=$(az account get-access-token --resource https://database.windows.net/ --query accessToken -o tsv 2>/dev/null || echo "")
                        [ -n "$ACCESS_TOKEN" ] && export SQLCMDACCESSTOKEN="$ACCESS_TOKEN"
                        if /opt/mssql-tools/bin/sqlcmd -S "$SQL_SERVER_FQDN" -d "$DATABASE_NAME" -C -l 60 -i setup_managed_identity.sql; then
                          echo "[INFO] User/role script succeeded (attempt $i)"; CREATE_OK=1; break
                        else
                          echo "[WARN] User/role script failed (attempt $i); sleeping 15s before retry"; sleep 15
                        fi
                      done
                      if [ "$CREATE_OK" != "1" ]; then
                        echo "[WARN] Exhausted retries creating/verifying managed identity user. Manual intervention may be required."
                        exit 0
                      fi

                      echo "[INFO] Running identity test query..."
                      echo "SELECT SUSER_SNAME() AS suser, CURRENT_USER AS current_user, DB_NAME() AS dbname;" > test_connection.sql
                      /opt/mssql-tools/bin/sqlcmd -S "$SQL_SERVER_FQDN" -d "$DATABASE_NAME" -C -l 15 -i test_connection.sql || echo "[WARN] Identity test query failed"
                      echo "[INFO] Verifying presence of managed identity user principal..."
                      VERIFY_SQL=$'SET NOCOUNT ON; SELECT name,type_desc,create_date FROM sys.database_principals WHERE name='"'${WEBAPP_NAME}'"';'
                      VERIFY_OUTPUT=$(/opt/mssql-tools/bin/sqlcmd -S "$SQL_SERVER_FQDN" -d "$DATABASE_NAME" -C -l 30 -h -1 -Q "$VERIFY_SQL" 2>/dev/null || echo "")
                      if echo "$VERIFY_OUTPUT" | grep -qi "${WEBAPP_NAME}"; then
                        echo "[INFO] Managed identity user exists in database."
                      else
                        echo "[ERROR] Managed identity user ${WEBAPP_NAME} NOT FOUND after creation attempts."; exit 1
                      fi
                      echo "[INFO] Listing role memberships for managed identity (if any)..."
                      ROLE_SQL=$'SET NOCOUNT ON; SELECT r.name AS role_name FROM sys.database_principals dp JOIN sys.database_role_members rm ON dp.principal_id=rm.member_principal_id JOIN sys.database_principals r ON rm.role_principal_id=r.principal_id WHERE dp.name='"'${WEBAPP_NAME}'"';'
                      /opt/mssql-tools/bin/sqlcmd -S "$SQL_SERVER_FQDN" -d "$DATABASE_NAME" -C -l 30 -Q "$ROLE_SQL" || echo "[WARN] Role listing query failed"
                      echo "[INFO] Managed identity SQL setup complete"

                - task: DotNetCoreCLI@2
                  displayName: "Setup .NET for migrations"
                  inputs:
                    command: "custom"
                    custom: "tool"
                    arguments: "install --global dotnet-ef"

                - task: AzureCLI@2
                  displayName: "Run database migrations"
                  inputs:
                    azureSubscription: "$(AZURE_SERVICE_CONNECTION)"
                    scriptType: "bash"
                    scriptLocation: "inlineScript"
                    inlineScript: |
                      INSTANCE_NUM="$(instanceNum)"
                      RG_NAME="rg-aistock-prod-$(instanceNum)"

                      echo "🗄️ Checking database migration options..."
                      echo "Resource Group: ${RG_NAME}"

                      # Try to get connection string from Key Vault, but don't fail if access is denied
                      KEY_VAULT_NAME="kv-aistock-prod-$(instanceNum)"
                      echo "Attempting to retrieve connection string from Key Vault: ${KEY_VAULT_NAME}"

                      CONNECTION_STRING=$(az keyvault secret show --vault-name "${KEY_VAULT_NAME}" --name "SqlConnectionString" --query "value" --output tsv 2>/dev/null || echo "")

                      if [ -z "${CONNECTION_STRING}" ]; then
                        echo "ℹ️ Could not retrieve connection string from Key Vault."
                        echo "This is expected for first-time deployments or when pipeline doesn't have Key Vault access."
                        echo ""
                        echo "🚀 Database migrations will run automatically on first app startup."
                        echo "The application is configured to:"
                        echo "  1. Use Azure AD managed identity authentication"
                        echo "  2. Run Entity Framework migrations automatically"
                        echo "  3. Create necessary database schema"
                        echo ""
                        echo "✅ Skipping manual migration - letting app handle it during startup"
                      else
                        echo "✅ Retrieved connection string from Key Vault"
                        echo "Connection string type: $(echo "${CONNECTION_STRING}" | grep -o 'Authentication=[^;]*' || echo 'SQL Authentication')"
                        
                        if echo "${CONNECTION_STRING}" | grep -q "Authentication=Active Directory Default"; then
                          echo "🔐 Using Azure AD authentication for migrations"
                        else
                          echo "🔑 Using SQL authentication for migrations"
                        fi
                        
                        echo "Running database migrations manually..."
                        cd AiStockTradeApp
                        export ConnectionStrings__DefaultConnection="${CONNECTION_STRING}"
                        
                        # Run with verbose output
                        echo "Starting Entity Framework migration..."
                        dotnet ef database update --verbose
                        
                        if [ $? -eq 0 ]; then
                          echo "✅ Database migrations completed successfully"
                        else
                          echo "⚠️ Migration failed, but this may be handled during app startup"
                        fi
                      fi

                - task: AzureCLI@2
                  displayName: "Update Web App Container"
                  inputs:
                    azureSubscription: "$(AZURE_SERVICE_CONNECTION)"
                    scriptType: "bash"
                    scriptLocation: "inlineScript"
                    inlineScript: |
                      WEBAPP_NAME="app-aistock-prod-$(instanceNum)"
                      RG_NAME="rg-aistock-prod-$(instanceNum)"

                      # Get registry information from DEV resource group (shared registry)
                      DEV_RG_NAME="rg-aistock-dev-$(instanceNum)"
                      REGISTRY_NAME=$(az acr list --resource-group "${DEV_RG_NAME}" --query '[0].name' --output tsv)
                      REGISTRY_USERNAME=$(az acr credential show --name "${REGISTRY_NAME}" --query 'username' --output tsv)
                      REGISTRY_PASSWORD=$(az acr credential show --name "${REGISTRY_NAME}" --query 'passwords[0].value' --output tsv)

                      echo "Container Image: $(containerImage)"
                      echo "Web App Name: ${WEBAPP_NAME}"
                      echo "Prod Resource Group: ${RG_NAME}"
                      echo "Dev Registry Resource Group: ${DEV_RG_NAME}"
                      echo "Shared Registry Name: ${REGISTRY_NAME}"

                      if [ -z "$(containerImage)" ]; then
                        echo "ERROR: Container image is empty!"
                        exit 1
                      fi

                      az webapp config container set \
                        --name "${WEBAPP_NAME}" \
                        --resource-group "${RG_NAME}" \
                        --container-image-name "$(containerImage)" \
                        --container-registry-url "https://${REGISTRY_NAME}.azurecr.io" \
                        --container-registry-user "${REGISTRY_USERNAME}" \
                        --container-registry-password "${REGISTRY_PASSWORD}"

                - task: AzureCLI@2
                  displayName: "Update API Web App Container"
                  inputs:
                    azureSubscription: "$(AZURE_SERVICE_CONNECTION)"
                    scriptType: "bash"
                    scriptLocation: "inlineScript"
                    inlineScript: |
                      WEBAPP_NAME="api-aistock-prod-$(instanceNum)"
                      RG_NAME="rg-aistock-prod-$(instanceNum)"

                      # Get registry information from DEV resource group (shared registry)
                      DEV_RG_NAME="rg-aistock-dev-$(instanceNum)"
                      REGISTRY_NAME=$(az acr list --resource-group "${DEV_RG_NAME}" --query '[0].name' --output tsv)
                      REGISTRY_USERNAME=$(az acr credential show --name "${REGISTRY_NAME}" --query 'username' --output tsv)
                      REGISTRY_PASSWORD=$(az acr credential show --name "${REGISTRY_NAME}" --query 'passwords[0].value' --output tsv)

                      echo "API Container Image: $(containerImageApi)"
                      echo "API Web App Name: ${WEBAPP_NAME}"
                      echo "Prod Resource Group: ${RG_NAME}"
                      echo "Dev Registry Resource Group: ${DEV_RG_NAME}"
                      echo "Shared Registry Name: ${REGISTRY_NAME}"

                      if [ -z "$(containerImageApi)" ]; then echo "ERROR: API container image is empty!"; exit 1; fi

                      az webapp config container set \
                        --name "${WEBAPP_NAME}" \
                        --resource-group "${RG_NAME}" \
                        --container-image-name "$(containerImageApi)" \
                        --container-registry-url "https://${REGISTRY_NAME}.azurecr.io" \
                        --container-registry-user "${REGISTRY_USERNAME}" \
                        --container-registry-password "${REGISTRY_PASSWORD}"

                - task: AzureCLI@2
                  displayName: "Run Health Check"
                  inputs:
                    azureSubscription: "$(AZURE_SERVICE_CONNECTION)"
                    scriptType: "bash"
                    scriptLocation: "inlineScript"
                    inlineScript: |
                      echo "[DIAG] Dumping resolved connection string authentication mode before health checks (shared script)..."
                      WEBAPP_NAME="app-aistock-prod-$(instanceNum)"
                      RG_NAME="rg-aistock-prod-$(instanceNum)"
                      bash ./scripts/sql-conn-auth-dump.sh "$RG_NAME" "$WEBAPP_NAME" || echo "[DIAG] Script execution failed (non-fatal)"
                      WEBAPP_NAME="app-aistock-prod-$(instanceNum)"
                      HEALTH_URL="https://${WEBAPP_NAME}.azurewebsites.net/health"
                      BASE_URL="https://${WEBAPP_NAME}.azurewebsites.net"

                      echo "🏥 Starting comprehensive health check..."
                      echo "Base URL: ${BASE_URL}"
                      echo "Health URL: ${HEALTH_URL}"

                      # Wait for initial deployment
                      echo "Waiting for deployment to be ready..."
                      sleep 60

                      # Check if the site is accessible at all
                      echo "Testing basic site accessibility..."
                      for i in {1..5}; do
                        if curl -f -s "${BASE_URL}" >/dev/null 2>&1; then
                          echo "✅ Site is accessible (attempt $i)"
                          break
                        else
                          echo "⏳ Site not ready yet (attempt $i/5)..."
                          sleep 30
                        fi
                      done

                      # Check health endpoint specifically
                      echo "Testing health endpoint..."
                      for i in {1..10}; do
                        echo "Health check attempt $i/10..."
                        
                        # Get detailed response
                        HTTP_CODE=$(curl -s -o /tmp/health_response.txt -w "%{http_code}" "${HEALTH_URL}")
                        RESPONSE_BODY=$(cat /tmp/health_response.txt 2>/dev/null || echo "No response body")
                        
                        echo "HTTP Status: ${HTTP_CODE}"
                        echo "Response: ${RESPONSE_BODY}"
                        
                        if [ "${HTTP_CODE}" = "200" ]; then
                          echo "✅ Health check passed!"
                          echo "Deployment successful and application is healthy."
                          exit 0
                        elif [ "${HTTP_CODE}" = "503" ] || [ "${HTTP_CODE}" = "500" ]; then
                          echo "⚠️ Application error detected (HTTP ${HTTP_CODE})"
                          echo "This might be a database connectivity issue."
                          
                          # Try to get more detailed logs
                          echo "Attempting to get application logs..."
                          az webapp log tail --name "${WEBAPP_NAME}" --resource-group "rg-aistock-prod-$(instanceNum)" --timeout 30 || echo "Could not retrieve logs"
                          
                          if [ $i -eq 10 ]; then
                            echo "❌ Health check failed after 10 attempts"
                            echo "Last response (HTTP ${HTTP_CODE}): ${RESPONSE_BODY}"
                            echo ""
                            echo "🔍 Troubleshooting steps:"
                            echo "1. Check Azure portal for app service logs"
                            echo "2. Verify managed identity SQL user was created"
                            echo "3. Check Key Vault access permissions"
                            echo "4. Verify SQL Server firewall allows Azure services"
                            exit 1
                          fi
                        else
                          echo "⏳ Unexpected response (HTTP ${HTTP_CODE}), retrying..."
                        fi
                        
                        sleep 30
                      done

                      echo "❌ Health check failed - no successful response received"
                      exit 1

                - task: Bash@3
                  displayName: "Run API Health Check"
                  inputs:
                    targetType: "inline"
                    script: |
                      echo "[DIAG] Dumping resolved connection string authentication mode before API health checks (shared script)..."
                      WEBAPP_NAME="api-aistock-prod-$(instanceNum)"
                      RG_NAME="rg-aistock-prod-$(instanceNum)"
                      bash ./scripts/sql-conn-auth-dump.sh "$RG_NAME" "$WEBAPP_NAME" || echo "[DIAG] Script execution failed (non-fatal)"
                      HEALTH_URL="https://${WEBAPP_NAME}.azurewebsites.net/health"
                      BASE_URL="https://${WEBAPP_NAME}.azurewebsites.net"
                      echo "🏥 Starting API health check..."
                      echo "Base URL: ${BASE_URL}"
                      echo "Health URL: ${HEALTH_URL}"
                      sleep 60
                      for i in {1..10}; do
                        echo "API Health check attempt $i/10..."
                        HTTP_CODE=$(curl -s -o /tmp/health_api_response.txt -w "%{http_code}" "${HEALTH_URL}")
                        RESPONSE_BODY=$(cat /tmp/health_api_response.txt 2>/dev/null || echo "No response body")
                        echo "HTTP Status: ${HTTP_CODE}"; echo "Response: ${RESPONSE_BODY}"
                        if [ "${HTTP_CODE}" = "200" ]; then
                          echo "✅ API Health check passed!"; exit 0
                        fi
                        sleep 30
                      done
                      echo "❌ API Health check failed"; exit 1

  - stage: SecurityScan
    displayName: "Security Scan"
    dependsOn: Build
    condition: |
      and(
        succeeded(),
        eq(variables['Build.Reason'], 'PullRequest')
      )
    jobs:
      - job: SecurityScanJob
        displayName: "Security Scan"
        steps:
          - checkout: self
            displayName: "Checkout code"
            fetchDepth: 0
            persistCredentials: true
            clean: true

          - task: DownloadPipelineArtifact@2
            displayName: "Download build outputs"
            inputs:
              artifactName: "build-outputs"
              downloadPath: "$(Pipeline.Workspace)/build-outputs"

          - task: Bash@3
            displayName: "Load container image from artifact"
            inputs:
              targetType: "inline"
              script: |
                if [ -f "$(Pipeline.Workspace)/build-outputs/container-image.txt" ]; then
                  CONTAINER_IMAGE=$(cat $(Pipeline.Workspace)/build-outputs/container-image.txt)
                  echo "Container image from artifact: '${CONTAINER_IMAGE}'"
                  echo "##vso[task.setvariable variable=containerImage]${CONTAINER_IMAGE}"
                else
                  echo "ERROR: container-image.txt not found in artifacts!"
                  exit 1
                fi

          # Note: For Trivy scanning in Azure DevOps, you would need to install Trivy
          # or use a marketplace extension. This is a placeholder for the security scan.
          - task: Bash@3
            displayName: "Run Security Scan (Placeholder)"
            inputs:
              targetType: "inline"
              script: |
                echo "=== SECURITY SCAN ==="
                echo "Container image to scan: $(containerImage)"
                echo "In a real implementation, this would run Trivy or similar security scanner"
                echo "Results would be published to Azure DevOps security dashboard"
