# Azure DevOps CI/CD Pipeline
# Converted from GitHub Actions workflow

trigger:
  branches:
    include:
      - main
      - develop
  paths:
    exclude:
      - "**.md"
      - "**/README.md"
      - "docs/**"
      - "*.txt"
      - ".gitignore"
      - ".vscode/**"
      - ".vs/**"
      #- '.azuredevops/**'
      - ".github/**"
      - "AGENTS.md"
      - "LICENSE"

pr:
  branches:
    include:
      - main
  paths:
    exclude:
      - "**.md"
      - "**/README.md"
      - "docs/**"
      - "*.txt"
      - ".gitignore"
      - ".vscode/**"
      - ".vs/**"
      #- '.azuredevops/**'
      - ".github/**"
      - "AGENTS.md"
      - "LICENSE"

parameters:
  - name: environment
    displayName: "Environment to deploy to"
    type: string
    default: "dev"
    values:
      - dev
      - prod

  - name: instanceNumber
    displayName: "Instance number for resource differentiation"
    type: string
    default: "003"

variables:
  - group: "ai-stock-trade-app" # Variable group for shared variables
  - name: AZURE_SERVICE_CONNECTION
    value: "svc_CSA_sub" # Replace with your Azure service connection name
  - name: AZURE_SUBSCRIPTION_ID
    value: "64c3d212-40ed-4c6d-a825-6adfbdf25dad" # Replace with your Azure subscription ID
  - name: AZURE_WEBAPP_PACKAGE_PATH
    value: "."
  - name: DOTNET_VERSION
    value: "9.0.x"
  - name: vmImageName
    value: "ubuntu-latest"

pool:
  vmImage: $(vmImageName)

stages:
  - stage: Test
    displayName: "Test Application"
    jobs:
      - job: TestJob
        displayName: "Test Application"
        steps:
          - checkout: self
            displayName: "Checkout code"

          - task: UseDotNet@2
            displayName: "Setup .NET"
            inputs:
              packageType: "sdk"
              version: $(DOTNET_VERSION)

          - task: DotNetCoreCLI@2
            displayName: "Restore dependencies"
            inputs:
              command: "restore"
              projects: "**/*.csproj"

          - task: DotNetCoreCLI@2
            displayName: "Build application"
            inputs:
              command: "build"
              projects: "**/*.csproj"
              arguments: "--no-restore --configuration Release"

          - task: DotNetCoreCLI@2
            displayName: "Run tests"
            inputs:
              command: "test"
              projects: "**/*.csproj"
              arguments: '--no-build --configuration Release --verbosity normal --filter "FullyQualifiedName!~UITests"'

      - job: UITestJob
        displayName: "UI Tests with Playwright"
        dependsOn: TestJob
        condition: succeeded()
        steps:
          - checkout: self
            displayName: "Checkout code"

          - task: UseDotNet@2
            displayName: "Setup .NET"
            inputs:
              packageType: "sdk"
              version: $(DOTNET_VERSION)

          - task: DotNetCoreCLI@2
            displayName: "Restore dependencies"
            inputs:
              command: "restore"
              projects: "**/*.csproj"

          - task: DotNetCoreCLI@2
            displayName: "Build application"
            inputs:
              command: "build"
              projects: "**/*.csproj"
              arguments: "--no-restore --configuration Release"

          - task: DotNetCoreCLI@2
            displayName: "Install Entity Framework tools"
            inputs:
              command: "custom"
              custom: "tool"
              arguments: "install --global dotnet-ef"

          - script: |
              # Start SQL Server container for testing
              echo "Starting SQL Server container..."
              docker run -e "ACCEPT_EULA=Y" -e "SA_PASSWORD=YourStrong@Passw0rd" \
                -e "MSSQL_PID=Express" \
                -p 1433:1433 --name sqlserver-ui-test \
                -d mcr.microsoft.com/mssql/server:2022-latest
              
              # Wait for SQL Server to start - give it more time
              echo "Waiting for SQL Server to initialize..."
              sleep 60
              
              # Check if container is running and port is available
              echo "Checking SQL Server status..."
              timeout=90
              while [ $timeout -gt 0 ]; do
                # Check if container is running
                if ! docker ps --filter "name=sqlserver-ui-test" --filter "status=running" | grep -q sqlserver-ui-test; then
                  echo "Container is not running. Checking logs..."
                  docker logs sqlserver-ui-test
                  exit 1
                fi
                
                # Check if port 1433 is responding
                if nc -z localhost 1433 2>/dev/null; then
                  echo "SQL Server port 1433 is responding!"
                  # Give it a bit more time to fully initialize
                  sleep 10
                  echo "SQL Server is ready!"
                  break
                fi
                
                echo "Waiting for SQL Server port 1433... ($timeout seconds remaining)"
                sleep 5
                timeout=$((timeout-5))
              done
              
              if [ $timeout -le 0 ]; then
                echo "SQL Server failed to start within timeout"
                echo "Container status:"
                docker ps -a --filter "name=sqlserver-ui-test"
                echo "Container logs:"
                docker logs sqlserver-ui-test
                exit 1
              fi
            displayName: "Setup SQL Server for UI testing"

          - script: |
              # Run database migrations with retry logic
              echo "Running database migrations..."
              
              export ConnectionStrings__DefaultConnection="Server=localhost;Database=StockTrackerTestUI;User Id=sa;Password=YourStrong@Passw0rd;TrustServerCertificate=true;Encrypt=false"
              
              # Retry migration up to 3 times
              retry_count=0
              max_retries=3
              
              while [ $retry_count -lt $max_retries ]; do
                echo "Migration attempt $((retry_count + 1)) of $max_retries..."
                
                if dotnet ef database update --project ai-stock-trade-app/ai-stock-trade-app.csproj --verbose; then
                  echo "Database migration completed successfully!"
                  break
                fi
                
                retry_count=$((retry_count + 1))
                if [ $retry_count -lt $max_retries ]; then
                  echo "Migration failed, waiting 10 seconds before retry..."
                  sleep 10
                else
                  echo "Migration failed after $max_retries attempts"
                  exit 1
                fi
              done
            displayName: "Run database migrations for UI testing"
            env:
              ConnectionStrings__DefaultConnection: "Server=localhost;Database=StockTrackerTestUI;User Id=sa;Password=YourStrong@Passw0rd;TrustServerCertificate=true;Encrypt=false"

          - task: NodeTool@0
            displayName: "Setup Node.js"
            inputs:
              versionSpec: "18.x"

          - script: |
              npx playwright install
              npx playwright install-deps
            displayName: "Install Playwright browsers"

          - script: |
              # Start application in background
              echo "Starting application in background..."
              cd ai-stock-trade-app
              nohup dotnet run --no-build --configuration Release --no-launch-profile > app.log 2>&1 &
              APP_PID=$!
              echo "Started application with PID: $APP_PID"
              echo $APP_PID > app.pid
              
              # Wait for application to be ready
              echo "Waiting for application to start..."
              timeout=120
              while [ $timeout -gt 0 ]; do
                if curl -f http://localhost:5000 >/dev/null 2>&1; then
                  echo "Application is ready!"
                  break
                fi
                echo "Waiting for application... ($timeout seconds remaining)"
                sleep 2
                timeout=$((timeout-2))
              done
              
              if [ $timeout -le 0 ]; then
                echo "Application failed to start within timeout"
                echo "Application logs:"
                cat app.log
                exit 1
              fi
            displayName: "Start application in background"
            env:
              ASPNETCORE_ENVIRONMENT: "Development"
              ASPNETCORE_URLS: "http://localhost:5000"
              ConnectionStrings__DefaultConnection: "Server=localhost;Database=StockTrackerTestUI;User Id=sa;Password=YourStrong@Passw0rd;TrustServerCertificate=true;Encrypt=false"

          - script: |
              echo "Waiting for application to start..."
              timeout=60
              while [ $timeout -gt 0 ]; do
                if curl -f http://localhost:5000 >/dev/null 2>&1; then
                  echo "Application is ready!"
                  break
                fi
                echo "Waiting for application... ($timeout seconds remaining)"
                sleep 2
                timeout=$((timeout-2))
              done
              
              if [ $timeout -le 0 ]; then
                echo "Application failed to start within timeout"
                exit 1
              fi
            displayName: "Wait for application to be ready"

          - task: DotNetCoreCLI@2
            displayName: "Run Playwright UI Tests"
            inputs:
              command: "test"
              projects: "**/*.csproj"
              arguments: '--no-build --configuration Release --verbosity normal --filter "FullyQualifiedName~UITests" --logger "trx;LogFileName=ui-test-results.trx"'
            env:
              PLAYWRIGHT_BASE_URL: "http://localhost:5000"
              ASPNETCORE_ENVIRONMENT: "Development"
            condition: succeededOrFailed()

          - task: PublishTestResults@2
            displayName: "Publish UI Test Results"
            inputs:
              testResultsFormat: "VSTest"
              testResultsFiles: "**/*ui-test-results.trx"
              testRunTitle: "Playwright UI Tests"
              mergeTestResults: true
            condition: succeededOrFailed()

          - script: |
              echo "Stopping application..."
              if [ -f "ai-stock-trade-app/app.pid" ]; then
                APP_PID=$(cat ai-stock-trade-app/app.pid)
                echo "Stopping application with PID: $APP_PID"
                kill $APP_PID || true
                sleep 5
              fi
              # Cleanup any remaining dotnet processes
              pkill -f "dotnet.*ai-stock-trade-app" || true
            displayName: "Stop application"
            condition: always()

          - script: |
              echo "Cleaning up SQL Server container..."
              docker stop sqlserver-ui-test || true
              docker rm sqlserver-ui-test || true
            displayName: "Cleanup SQL Server"
            condition: always()

  - stage: Build
    displayName: "Build and Push Container"
    dependsOn: Test
    condition: succeeded()
    jobs:
      - job: BuildJob
        displayName: "Build and Push Container"
        variables:
          - name: containerImage
            value: ""
          - name: registryName
            value: ""
          - name: resourceGroup
            value: ""
          - name: instanceNum
            value: ""

        steps:
          - checkout: self
            displayName: "Checkout code"

          - task: AzureCLI@2
            displayName: "Get Container Registry Information"
            inputs:
              azureSubscription: "$(AZURE_SERVICE_CONNECTION)"
              scriptType: "bash"
              scriptLocation: "inlineScript"
              inlineScript: |
                # Always use dev environment container registry (shared across all environments)
                if [[ "$(Build.Reason)" == "Manual" ]]; then
                  INSTANCE_NUM="${{ parameters.instanceNumber }}"
                  echo "Manual trigger detected - Instance: ${INSTANCE_NUM}"
                else
                  INSTANCE_NUM="003"
                  echo "Branch push detected - Using default instance: ${INSTANCE_NUM}"
                fi

                # Always target dev resource group for container registry
                ENV="dev"
                RG_NAME="rg-aistock-${ENV}-${INSTANCE_NUM}"

                echo "=== BUILD ENVIRONMENT INFO ==="
                echo "Container Registry Environment: ${ENV} (shared registry)"
                echo "Instance Number: ${INSTANCE_NUM}"
                echo "Registry Resource Group: ${RG_NAME}"
                echo "Build Source Branch: $(Build.SourceBranch)"
                echo "Build Reason: $(Build.Reason)"

                # Get container registry name from dev resource group
                REGISTRY_NAME=$(az acr list --resource-group "${RG_NAME}" --query '[0].name' --output tsv)

                if [ -z "${REGISTRY_NAME}" ] || [ "${REGISTRY_NAME}" == "null" ]; then
                  echo "ERROR: No container registry found in resource group ${RG_NAME}"
                  echo "Available resource groups:"
                  az group list --query '[].name' --output table
                  echo "This might mean the dev infrastructure hasn't been deployed yet for instance ${INSTANCE_NUM}"
                  echo "Please deploy dev environment first to create the shared container registry."
                  exit 1
                fi

                echo "Found shared registry: ${REGISTRY_NAME}"
                echo "##vso[task.setvariable variable=registryName]${REGISTRY_NAME}"
                echo "##vso[task.setvariable variable=resourceGroup]${RG_NAME}"
                echo "##vso[task.setvariable variable=instanceNum]${INSTANCE_NUM}"

          - task: AzureCLI@2
            displayName: "Get Container Registry Credentials"
            inputs:
              azureSubscription: "$(AZURE_SERVICE_CONNECTION)"
              scriptType: "bash"
              scriptLocation: "inlineScript"
              inlineScript: |
                # Get admin credentials
                REGISTRY_USERNAME=$(az acr credential show --name "$(registryName)" --query 'username' --output tsv)
                REGISTRY_PASSWORD=$(az acr credential show --name "$(registryName)" --query 'passwords[0].value' --output tsv)

                echo "Registry Username: ${REGISTRY_USERNAME}"
                echo "Password length: ${#REGISTRY_PASSWORD}"

                echo "##vso[task.setvariable variable=registryUsername;issecret=true]${REGISTRY_USERNAME}"
                echo "##vso[task.setvariable variable=registryPassword;issecret=true]${REGISTRY_PASSWORD}"

          - task: Bash@3
            displayName: "Debug Registry Information"
            inputs:
              targetType: "inline"
              script: |
                echo "=== REGISTRY DEBUG INFO ==="
                echo "Instance Number: $(instanceNum)"
                echo "Registry name: $(registryName)"
                echo "Resource group: $(resourceGroup)"
                echo "Registry URL: $(registryName).azurecr.io"
                echo "=== TRIGGER INFO ==="
                echo "Build Source Branch: $(Build.SourceBranch)"
                echo "Build Reason: $(Build.Reason)"

          - task: AzureCLI@2
            displayName: "Login to Azure Container Registry"
            inputs:
              azureSubscription: "$(AZURE_SERVICE_CONNECTION)"
              scriptType: "bash"
              scriptLocation: "inlineScript"
              inlineScript: |
                echo "Logging in to Azure Container Registry: $(registryName).azurecr.io"
                az acr login --name "$(registryName)"

          - task: Bash@3
            displayName: "Generate Container Tags"
            inputs:
              targetType: "inline"
              script: |
                # Generate tags similar to docker/metadata-action
                REGISTRY_URL="$(registryName).azurecr.io"
                IMAGE_NAME="${REGISTRY_URL}/ai-stock-trade-app"

                # Branch-based tag
                BRANCH_NAME=$(echo "$(Build.SourceBranchName)" | sed 's/[^a-zA-Z0-9._-]/-/g')
                BRANCH_TAG="${IMAGE_NAME}:${BRANCH_NAME}"

                # SHA-based tag
                SHORT_SHA=$(echo "$(Build.SourceVersion)" | cut -c1-7)
                SHA_TAG="${IMAGE_NAME}:sha-${SHORT_SHA}"

                # Latest tag for main/master branch
                if [[ "$(Build.SourceBranchName)" == "main" || "$(Build.SourceBranchName)" == "master" ]]; then
                  LATEST_TAG="${IMAGE_NAME}:latest"
                  TAGS="${BRANCH_TAG},${SHA_TAG},${LATEST_TAG}"
                else
                  TAGS="${BRANCH_TAG},${SHA_TAG}"
                fi

                echo "Generated tags: ${TAGS}"
                echo "##vso[task.setvariable variable=containerTags]${TAGS}"
                echo "##vso[task.setvariable variable=deployTag]${SHA_TAG}"

          - task: AzureCLI@2
            displayName: "Build and push Docker image"
            inputs:
              azureSubscription: "$(AZURE_SERVICE_CONNECTION)"
              scriptType: "bash"
              scriptLocation: "inlineScript"
              inlineScript: |
                echo "=== BUILDING AND PUSHING CONTAINER IMAGE ==="

                # Parse container tags into individual tags
                IFS=',' read -ra TAG_ARRAY <<< "$(containerTags)"

                # Build the image first
                echo "Building Docker image..."
                docker build -t temp-build-image ./ai-stock-trade-app

                # Tag and push each tag
                for tag in "${TAG_ARRAY[@]}"; do
                  # Remove any leading/trailing whitespace
                  clean_tag=$(echo "$tag" | xargs)
                  echo "Tagging and pushing: $clean_tag"
                  
                  # Tag the image
                  docker tag temp-build-image "$clean_tag"
                  
                  # Push using az acr
                  az acr repository show --name "$(registryName)" --repository ai-stock-trade-app || echo "Repository doesn't exist yet, will be created on first push"
                  docker push "$clean_tag"
                done

                echo "All tags pushed successfully"
                echo "Deploy tag will be: $(deployTag)"

          - task: Bash@3
            displayName: "Extract and set container image for deployment"
            inputs:
              targetType: "inline"
              script: |
                set -e  # Exit on any error
                echo "=== SETTING DEPLOYMENT IMAGE ==="

                DEPLOY_IMAGE="$(deployTag)"
                echo "Final deployment image: '${DEPLOY_IMAGE}'"

                # Check if DEPLOY_IMAGE is empty
                if [ -z "${DEPLOY_IMAGE}" ]; then
                  echo "ERROR: DEPLOY_IMAGE is empty after processing!"
                  exit 1
                fi

                # Write to artifact file for reliable transfer
                echo "=== CREATING ARTIFACT ==="
                mkdir -p $(Pipeline.Workspace)/build-outputs
                echo "${DEPLOY_IMAGE}" > $(Pipeline.Workspace)/build-outputs/container-image.txt
                echo "hello-from-build-stage" > $(Pipeline.Workspace)/build-outputs/test-output.txt

                echo "Artifact files created:"
                ls -la $(Pipeline.Workspace)/build-outputs/
                echo "Container image file contents:"
                cat $(Pipeline.Workspace)/build-outputs/container-image.txt

                echo "##vso[task.setvariable variable=containerImage;isOutput=true]${DEPLOY_IMAGE}"

          - task: PublishPipelineArtifact@1
            displayName: "Upload build outputs as artifact"
            inputs:
              targetPath: "$(Pipeline.Workspace)/build-outputs"
              artifactName: "build-outputs"

  - stage: DeployDev
    displayName: "Deploy to Development"
    dependsOn: Build
    condition: |
      and(
        succeeded(),
        or(
          eq(variables['Build.SourceBranch'], 'refs/heads/develop'),
          and(
            eq(variables['Build.Reason'], 'Manual'),
            eq('${{ parameters.environment }}', 'dev')
          )
        )
      )
    jobs:
      - deployment: DeployDevJob
        displayName: "Deploy to Development"
        environment: ${{ format('development-{0}', parameters.instanceNumber) }}
        variables:
          - name: instanceNum
            value: ${{ format('{0}', parameters.instanceNumber) }}
        strategy:
          runOnce:
            deploy:
              steps:
                - checkout: self
                  displayName: "Checkout code"

                - task: DownloadPipelineArtifact@2
                  displayName: "Download build outputs"
                  inputs:
                    artifactName: "build-outputs"
                    downloadPath: "$(Pipeline.Workspace)/build-outputs"

                - task: Bash@3
                  displayName: "Load container image from artifact"
                  inputs:
                    targetType: "inline"
                    script: |
                      echo "=== LOADING CONTAINER IMAGE FROM ARTIFACT ==="
                      if [ -f "$(Pipeline.Workspace)/build-outputs/container-image.txt" ]; then
                        CONTAINER_IMAGE=$(cat $(Pipeline.Workspace)/build-outputs/container-image.txt)
                        echo "Container image from artifact: '${CONTAINER_IMAGE}'"
                        echo "##vso[task.setvariable variable=containerImage]${CONTAINER_IMAGE}"
                      else
                        echo "ERROR: container-image.txt not found in artifacts!"
                        ls -la $(Pipeline.Workspace)/build-outputs/
                        exit 1
                      fi

                - task: AzureResourceManagerTemplateDeployment@3
                  displayName: "Deploy Bicep template"
                  inputs:
                    deploymentScope: "Resource Group"
                    azureResourceManagerConnection: "$(AZURE_SERVICE_CONNECTION)"
                    subscriptionId: "$(AZURE_SUBSCRIPTION_ID)"
                    action: "Create Or Update Resource Group"
                    resourceGroupName: "rg-aistock-dev-$(instanceNum)"
                    location: "Canada Central"
                    templateLocation: "Linked artifact"
                    csmFile: "./ai-stock-trade-app/infrastructure/main.bicep"
                    csmParametersFile: "./ai-stock-trade-app/infrastructure/parameters.dev.json"
                    overrideParameters: "-instanceNumber $(instanceNum) -containerImage $(containerImage) -alphaVantageApiKey $(ALPHA_VANTAGE_API_KEY) -twelveDataApiKey $(TWELVE_DATA_API_KEY) -sqlAdminPassword $(SQL_ADMIN_PASSWORD)"
                    deploymentMode: "Incremental"

                - task: AzureCLI@2
                  displayName: "Update Web App Container"
                  inputs:
                    azureSubscription: "$(AZURE_SERVICE_CONNECTION)"
                    scriptType: "bash"
                    scriptLocation: "inlineScript"
                    inlineScript: |
                      WEBAPP_NAME="app-aistock-dev-$(instanceNum)"
                      RG_NAME="rg-aistock-dev-$(instanceNum)"

                      # Get registry information from the same resource group
                      REGISTRY_NAME=$(az acr list --resource-group "${RG_NAME}" --query '[0].name' --output tsv)
                      REGISTRY_USERNAME=$(az acr credential show --name "${REGISTRY_NAME}" --query 'username' --output tsv)
                      REGISTRY_PASSWORD=$(az acr credential show --name "${REGISTRY_NAME}" --query 'passwords[0].value' --output tsv)

                      echo "Container Image: $(containerImage)"
                      echo "Web App Name: ${WEBAPP_NAME}"
                      echo "Resource Group: ${RG_NAME}"
                      echo "Registry Name: ${REGISTRY_NAME}"

                      if [ -z "$(containerImage)" ]; then
                        echo "ERROR: Container image is empty!"
                        exit 1
                      fi

                      az webapp config container set \
                        --name "${WEBAPP_NAME}" \
                        --resource-group "${RG_NAME}" \
                        --container-image-name "$(containerImage)" \
                        --container-registry-url "https://${REGISTRY_NAME}.azurecr.io" \
                        --container-registry-user "${REGISTRY_USERNAME}" \
                        --container-registry-password "${REGISTRY_PASSWORD}"

                - task: Bash@3
                  displayName: "Run Health Check"
                  inputs:
                    targetType: "inline"
                    script: |
                      WEBAPP_NAME="app-aistock-dev-$(instanceNum)"
                      HEALTH_URL="https://${WEBAPP_NAME}.azurewebsites.net/health"
                      echo "Waiting for deployment to be ready..."
                      echo "Health check URL: ${HEALTH_URL}"
                      sleep 30
                      curl -f "${HEALTH_URL}" || exit 1
                      echo "Health check passed!"

  - stage: DeployProd
    displayName: "Deploy to Production"
    dependsOn:
      - Build
      - DeployDev
    condition: |
      and(
        succeeded(),
        in(dependencies.Build.result, 'Succeeded'),
        in(dependencies.DeployDev.result, 'Succeeded', 'Skipped'),
        or(
          eq(variables['Build.SourceBranch'], 'refs/heads/main'),
          and(
            eq(variables['Build.Reason'], 'Manual'),
            eq('${{ parameters.environment }}', 'prod')
          )
        )
      )
    jobs:
      - deployment: DeployProdJob
        displayName: "Deploy to Production"
        environment: ${{ format('production-{0}', parameters.instanceNumber) }}
        variables:
          - name: instanceNum
            value: ${{ format('{0}', parameters.instanceNumber) }}
        strategy:
          runOnce:
            deploy:
              steps:
                - checkout: self
                  displayName: "Checkout code"

                - task: DownloadPipelineArtifact@2
                  displayName: "Download build outputs"
                  inputs:
                    artifactName: "build-outputs"
                    downloadPath: "$(Pipeline.Workspace)/build-outputs"

                - task: Bash@3
                  displayName: "Load container image from artifact"
                  inputs:
                    targetType: "inline"
                    script: |
                      echo "=== LOADING CONTAINER IMAGE FROM ARTIFACT ==="
                      if [ -f "$(Pipeline.Workspace)/build-outputs/container-image.txt" ]; then
                        CONTAINER_IMAGE=$(cat $(Pipeline.Workspace)/build-outputs/container-image.txt)
                        echo "Container image from artifact: '${CONTAINER_IMAGE}'"
                        echo "##vso[task.setvariable variable=containerImage]${CONTAINER_IMAGE}"
                      else
                        echo "ERROR: container-image.txt not found in artifacts!"
                        ls -la $(Pipeline.Workspace)/build-outputs/
                        exit 1
                      fi

                - task: Bash@3
                  displayName: "Debug Variables"
                  inputs:
                    targetType: "inline"
                    script: |
                      echo "=== DEPLOYMENT DEBUG INFO ==="
                      echo "Stage name: DeployProd"
                      echo "Build Source Branch: $(Build.SourceBranch)"
                      echo "Build Reason: $(Build.Reason)"
                      echo "Environment parameter: ${{ parameters.environment }}"
                      echo "Instance Number: $(instanceNum)"
                      echo "Resource Group: rg-aistock-prod-$(instanceNum)"
                      echo "Web App Name: app-aistock-prod-$(instanceNum)"
                      echo "Container image from artifact: $(containerImage)"

                - task: AzureResourceManagerTemplateDeployment@3
                  displayName: "Deploy Bicep template"
                  inputs:
                    deploymentScope: "Resource Group"
                    azureResourceManagerConnection: "$(AZURE_SERVICE_CONNECTION)"
                    subscriptionId: "$(AZURE_SUBSCRIPTION_ID)"
                    action: "Create Or Update Resource Group"
                    resourceGroupName: "rg-aistock-prod-$(instanceNum)"
                    location: "Canada Central"
                    templateLocation: "Linked artifact"
                    csmFile: "./ai-stock-trade-app/infrastructure/main.bicep"
                    csmParametersFile: "./ai-stock-trade-app/infrastructure/parameters.prod.json"
                    overrideParameters: "-instanceNumber $(instanceNum) -containerImage $(containerImage) -alphaVantageApiKey $(ALPHA_VANTAGE_API_KEY) -twelveDataApiKey $(TWELVE_DATA_API_KEY) -sqlAdminPassword $(SQL_ADMIN_PASSWORD)"
                    deploymentMode: "Incremental"

                - task: AzureCLI@2
                  displayName: "Update Web App Container"
                  inputs:
                    azureSubscription: "$(AZURE_SERVICE_CONNECTION)"
                    scriptType: "bash"
                    scriptLocation: "inlineScript"
                    inlineScript: |
                      WEBAPP_NAME="app-aistock-prod-$(instanceNum)"
                      RG_NAME="rg-aistock-prod-$(instanceNum)"

                      # Get registry information from DEV resource group (shared registry)
                      DEV_RG_NAME="rg-aistock-dev-$(instanceNum)"
                      REGISTRY_NAME=$(az acr list --resource-group "${DEV_RG_NAME}" --query '[0].name' --output tsv)
                      REGISTRY_USERNAME=$(az acr credential show --name "${REGISTRY_NAME}" --query 'username' --output tsv)
                      REGISTRY_PASSWORD=$(az acr credential show --name "${REGISTRY_NAME}" --query 'passwords[0].value' --output tsv)

                      echo "Container Image: $(containerImage)"
                      echo "Web App Name: ${WEBAPP_NAME}"
                      echo "Prod Resource Group: ${RG_NAME}"
                      echo "Dev Registry Resource Group: ${DEV_RG_NAME}"
                      echo "Shared Registry Name: ${REGISTRY_NAME}"

                      if [ -z "$(containerImage)" ]; then
                        echo "ERROR: Container image is empty!"
                        exit 1
                      fi

                      az webapp config container set \
                        --name "${WEBAPP_NAME}" \
                        --resource-group "${RG_NAME}" \
                        --container-image-name "$(containerImage)" \
                        --container-registry-url "https://${REGISTRY_NAME}.azurecr.io" \
                        --container-registry-user "${REGISTRY_USERNAME}" \
                        --container-registry-password "${REGISTRY_PASSWORD}"

                - task: Bash@3
                  displayName: "Run Health Check"
                  inputs:
                    targetType: "inline"
                    script: |
                      WEBAPP_NAME="app-aistock-prod-$(instanceNum)"
                      HEALTH_URL="https://${WEBAPP_NAME}.azurewebsites.net/health"
                      echo "Waiting for deployment to be ready..."
                      echo "Health check URL: ${HEALTH_URL}"
                      sleep 30
                      curl -f "${HEALTH_URL}" || exit 1
                      echo "Health check passed!"

  - stage: SecurityScan
    displayName: "Security Scan"
    dependsOn: Build
    condition: |
      and(
        succeeded(),
        eq(variables['Build.Reason'], 'PullRequest')
      )
    jobs:
      - job: SecurityScanJob
        displayName: "Security Scan"
        steps:
          - checkout: self
            displayName: "Checkout code"

          - task: DownloadPipelineArtifact@2
            displayName: "Download build outputs"
            inputs:
              artifactName: "build-outputs"
              downloadPath: "$(Pipeline.Workspace)/build-outputs"

          - task: Bash@3
            displayName: "Load container image from artifact"
            inputs:
              targetType: "inline"
              script: |
                if [ -f "$(Pipeline.Workspace)/build-outputs/container-image.txt" ]; then
                  CONTAINER_IMAGE=$(cat $(Pipeline.Workspace)/build-outputs/container-image.txt)
                  echo "Container image from artifact: '${CONTAINER_IMAGE}'"
                  echo "##vso[task.setvariable variable=containerImage]${CONTAINER_IMAGE}"
                else
                  echo "ERROR: container-image.txt not found in artifacts!"
                  exit 1
                fi

          # Note: For Trivy scanning in Azure DevOps, you would need to install Trivy
          # or use a marketplace extension. This is a placeholder for the security scan.
          - task: Bash@3
            displayName: "Run Security Scan (Placeholder)"
            inputs:
              targetType: "inline"
              script: |
                echo "=== SECURITY SCAN ==="
                echo "Container image to scan: $(containerImage)"
                echo "In a real implementation, this would run Trivy or similar security scanner"
                echo "Results would be published to Azure DevOps security dashboard"
