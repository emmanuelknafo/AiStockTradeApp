# Azure DevOps CI/CD Pipeline
# Converted from GitHub Actions workflow

trigger:
  branches:
    include:
      - main
      - develop
  paths:
    exclude:
      - "**.md"
      - "**/README.md"
      - "docs/**"
      - "scripts/**"
      - "AiStockTradeApp/scripts/**"
      - "*.txt"
      - ".gitignore"
      - ".vscode/**"
      - ".vs/**"
      #- '.azuredevops/**'
      - ".github/**"
      - "AGENTS.md"
      - "LICENSE"
      - "data/**"
      - "AiStockTradeApp.Cli/**"
      - ".azuredevops/pipelines/cli-ci.yml"
      - ".azuredevops/pipelines/load-tests.yml"
      - ".azuredevops/pipelines/alt-load-tests.yml"
      - ".azuredevops/pipelines/alt-config.yml"
      - ".azuredevops/pipelines/infrastructure.yml"
      - "load-tests/**"
      - "infrastructure/**"

pr:
  branches:
    include:
      - main
  paths:
    exclude:
      - "**.md"
      - "**/README.md"
      - "docs/**"
      - "scripts/**"
      - "AiStockTradeApp/scripts/**"
      - "*.txt"
      - ".gitignore"
      - ".vscode/**"
      - ".vs/**"
      #- '.azuredevops/**'
      - ".github/**"
      - "AGENTS.md"
      - "LICENSE"
      - "data/**"
      - "AiStockTradeApp.Cli/**"
      - ".azuredevops/pipelines/cli-ci.yml"
      - ".azuredevops/pipelines/load-tests.yml"
      - ".azuredevops/pipelines/alt-load-tests.yml"
      - ".azuredevops/pipelines/alt-config.yml"
      - ".azuredevops/pipelines/infrastructure.yml"
      - "load-tests/**"
      - "infrastructure/**"
resources:
  pipelines:
    - pipeline: infrastructurePipeline
      source: emmanuelknafo.AiStockTradeApp.infrastructure
      trigger:
        branches:
          include:
            - main
            - develop
        stages: []

# trigger: none  # CI temporarily disabled

# pr: none  # PR validation temporarily disabled

parameters:
  - name: environment
    displayName: "Environment to deploy to"
    type: string
    default: "dev"
    values:
      - dev
      - prod

  - name: instanceNumber
    displayName: "Instance number for resource differentiation"
    type: string
    default: "003"

  - name: appServicePlanSku
    displayName: "App Service Plan SKU"
    type: string
    default: "P0v3"
    values:
      - B1
      - S1
      - P0v3
      - P1v3
      - P2v3
      - P3v3

variables:
  - group: "AiStockTradeApp" # Variable group for shared variables
  - name: AZURE_SERVICE_CONNECTION
    value: "svc_CSA_sub" # Replace with your Azure service connection name
  - name: AZURE_SUBSCRIPTION_ID
    value: "64c3d212-40ed-4c6d-a825-6adfbdf25dad" # Replace with your Azure subscription ID
  - name: AZURE_WEBAPP_PACKAGE_PATH
    value: "."
  - name: DOTNET_VERSION
    value: "9.0.x"
  - name: vmImageName
    value: "ubuntu-latest"

pool:
  vmImage: $(vmImageName)

stages:
  - stage: Test
    displayName: "Run Tests"
    jobs:
      - job: TestJob
        displayName: "Run Tests"
        steps:
          - checkout: self
            displayName: "Checkout code"
            fetchDepth: 0 # full history for GitVersion
            persistCredentials: true
            clean: true
          - task: Bash@3
            displayName: "Docker pre-clean (global)"
            inputs:
              targetType: inline
              script: |
                docker ps -aq | xargs -r docker rm -f || true
                docker image prune -af || true

          - task: Bash@3
            displayName: "Debug git state (pre-version)"
            inputs:
              targetType: inline
              script: |
                set -e
                echo "GitVersion.yml present? $( [ -f GitVersion.yml ] && echo yes || echo no )"
                echo "HEAD commit: $(git rev-parse --short=12 HEAD)"
                echo "Commit count: $(git rev-list --count HEAD)"
                echo "Recent commits:"; git --no-pager log --oneline -n 5 || true
                echo "Existing tags (tail):"; git tag -l | tail -10 || true

          - task: UseDotNet@2
            displayName: "Setup .NET"
            inputs:
              packageType: "sdk"
              version: $(DOTNET_VERSION)

          - task: Bash@3
            displayName: "Determine Semantic Version (GitVersion CLI Fallback)"
            inputs:
              targetType: inline
              script: |
                set -e
                echo "Ensuring full git history (unshallow + tags) for GitVersion..."
                git fetch --prune --unshallow --tags || git fetch --prune --tags || true
                echo "Commit count: $(git rev-list --count HEAD 2>/dev/null || echo '?')"
                git --no-pager log --oneline -n 5 || true
                echo "Installing GitVersion CLI as global dotnet tool..."
                dotnet tool install --global GitVersion.Tool --version 5.* || { echo "Failed to install GitVersion.Tool"; exit 1; }
                export PATH="$PATH:$HOME/.dotnet/tools"
                echo "Running GitVersion..."
                RAW=$(dotnet-gitversion /config GitVersion.yml /output json 2>&1 || true)
                echo "Raw GitVersion output (first 60 lines):"; echo "$RAW" | head -60
                if ! echo "$RAW" | grep -q '"FullSemVer"'; then
                  echo "GitVersion did not return JSON with FullSemVer. Using placeholder version.";
                  FULL="0.0.0-local"; ASM="0.0.0"; INFO="0.0.0-local";
                else
                  if ! command -v jq >/dev/null 2>&1; then sudo apt-get update -y && sudo apt-get install -y jq; fi
                  FULL=$(echo "$RAW" | jq -r '.FullSemVer // empty')
                  ASM=$(echo "$RAW" | jq -r '.AssemblySemVer // empty')
                  INFO=$(echo "$RAW" | jq -r '.InformationalVersion // empty')
                  [ -n "$FULL" ] || FULL="0.0.0-local"
                  [ -n "$ASM" ] || ASM="0.0.0"
                  [ -n "$INFO" ] || INFO="$FULL"
                fi
                echo "Computed FullSemVer=$FULL"
                echo "##vso[task.setvariable variable=GitVersion.FullSemVer]$FULL"
                echo "##vso[task.setvariable variable=GitVersion.AssemblySemVer]$ASM"
                echo "##vso[task.setvariable variable=GitVersion.InformationalVersion]$INFO"
                echo "##vso[task.setvariable variable=FullSemVer]$FULL"
                echo "##vso[task.setvariable variable=AssemblySemVer]$ASM"
                echo "##vso[task.setvariable variable=InformationalVersion]$INFO"
                echo "GitVersion fallback step complete"

          - task: DotNetCoreCLI@2
            displayName: "Install Entity Framework tools"
            inputs:
              command: "custom"
              custom: "tool"
              arguments: "install --global dotnet-ef"

          - task: DotNetCoreCLI@2
            displayName: "Restore dependencies"
            inputs:
              command: "restore"
              projects: "AiStockTradeApp.sln"

          - task: DotNetCoreCLI@2
            displayName: "Build application"
            inputs:
              command: "build"
              projects: "AiStockTradeApp.sln"
              arguments: "--no-restore --configuration Release"

          - task: DotNetCoreCLI@2
            displayName: "Run tests"
            inputs:
              command: "test"
              projects: "AiStockTradeApp.Tests/AiStockTradeApp.Tests.csproj"
              arguments: '--no-build --configuration Release --verbosity normal --settings ./test.runsettings --logger "trx;LogFileName=unit-tests.trx" --results-directory "$(Agent.TempDirectory)"'
              publishTestResults: false
            env:
              ASPNETCORE_ENVIRONMENT: "Development"
              USE_INMEMORY_DB: "true"
              ConnectionStrings__DefaultConnection: "Server=localhost;Database=StockTrackerTest;User Id=sa;Password=YourStrong@Passw0rd;TrustServerCertificate=true;Encrypt=false"
              VSTEST_RESULTS_DIRECTORY: "$(Agent.TempDirectory)"

          - task: Bash@3
            displayName: "Diagnostics: List TestResults artifacts"
            inputs:
              targetType: inline
              script: |
                echo "Listing TestResults directories..."
                find $(System.DefaultWorkingDirectory) -type d -name TestResults | head -50
                echo "Listing TRX files..."
                find $(System.DefaultWorkingDirectory) -type f -name '*.trx' | head -80
                echo "Agent temp TRX files..."
                find $(Agent.TempDirectory) -type f -name '*.trx' 2>/dev/null | head -40 || true
                echo "Listing coverage candidates (xml/json)..."
                find $(System.DefaultWorkingDirectory) -type f \( -name 'coverage.cobertura.xml' -o -name 'coverage.opencover.xml' -o -name 'coverage.xml' -o -name 'coverage.json' \) | head -80
                echo "Agent temp coverage candidates..."
                find $(Agent.TempDirectory) -type f \( -name 'coverage.cobertura.xml' -o -name 'coverage.opencover.xml' -o -name 'coverage.xml' -o -name 'coverage.json' \) 2>/dev/null | head -40 || true
                echo "Disk usage for test project directories:"; du -sh */*Tests 2>/dev/null || true

          - task: Bash@3
            displayName: "Fallback: Copy TRX from workspace TestResults to Agent.TempDirectory"
            condition: always()
            inputs:
              targetType: inline
              script: |
                set -e
                SRC_DIR="$(System.DefaultWorkingDirectory)/TestResults"
                DEST_DIR="$(Agent.TempDirectory)"
                if [ -d "$SRC_DIR" ]; then
                  FOUND=$(find "$SRC_DIR" -type f -name '*.trx' | wc -l)
                  if [ "$FOUND" -gt 0 ]; then
                    echo "Found $FOUND TRX in $SRC_DIR. Copying to $DEST_DIR..."
                    find "$SRC_DIR" -type f -name '*.trx' -exec cp {} "$DEST_DIR/" \;
                  else
                    echo "No TRX in $SRC_DIR"
                  fi
                else
                  echo "No workspace TestResults directory present"
                fi

          - task: Bash@3
            displayName: "Locate coverage file"
            inputs:
              targetType: inline
              script: |
                set -e
                echo "Searching for coverage files (cobertura/opencover)..."
                FOUND=$(find $(System.DefaultWorkingDirectory) -type f \( -name 'coverage.cobertura.xml' -o -name 'coverage.opencover.xml' -o -name 'coverage.xml' \) | head -1 || true)
                if [ -z "$FOUND" ]; then
                  echo "Not found in workspace; checking Agent.TempDirectory..."
                  FOUND=$(find $(Agent.TempDirectory) -type f \( -name 'coverage.cobertura.xml' -o -name 'coverage.opencover.xml' -o -name 'coverage.xml' \) 2>/dev/null | head -1 || true)
                fi
                if [ -z "$FOUND" ]; then
                  echo "No coverage file found (will skip publish)."; exit 0; fi
                echo "Found coverage file: $FOUND";
                # Copy to workspace so later tasks can read reliably
                mkdir -p $(System.DefaultWorkingDirectory)/Coverage
                cp "$FOUND" $(System.DefaultWorkingDirectory)/Coverage/coverage.cobertura.xml || true
                echo "Coverage copied to $(System.DefaultWorkingDirectory)/Coverage/coverage.cobertura.xml"
                echo "##vso[task.setvariable variable=CoverageFile]$(System.DefaultWorkingDirectory)/Coverage/coverage.cobertura.xml";

          - task: PublishTestResults@2
            displayName: "Publish Unit Test Results"
            condition: always()
            inputs:
              testResultsFormat: "VSTest"
              testResultsFiles: "*.trx"
              searchFolder: "$(Agent.TempDirectory)"
              mergeTestResults: true
              testRunTitle: "Unit Tests_$(Build.BuildId)"

          - task: Bash@3
            displayName: "Collect Unit TRX for artifact"
            condition: always()
            inputs:
              targetType: inline
              script: |
                set -e
                DEST="$(Pipeline.Workspace)/test-results/unit"
                mkdir -p "$DEST"
                echo "Collecting TRX from $(Agent.TempDirectory) to $DEST"
                find "$(Agent.TempDirectory)" -type f -name '*.trx' -print -exec cp {} "$DEST/" \; 2>/dev/null || true

          - task: PublishPipelineArtifact@1
            displayName: "Upload Unit Test TRX"
            condition: always()
            inputs:
              targetPath: "$(Pipeline.Workspace)/test-results/unit"
              artifactName: "unit-test-results"

          - task: Bash@3
            displayName: "Generate HTML coverage report"
            condition: and(succeeded(), ne(variables.CoverageFile, ''))
            inputs:
              targetType: inline
              script: |
                set -e
                echo "Installing reportgenerator tool..."
                dotnet tool install --global dotnet-reportgenerator-globaltool --version 5.* || true
                export PATH="$PATH:$HOME/.dotnet/tools"
                OUT_DIR="$(System.DefaultWorkingDirectory)/CodeCoverageReport"
                mkdir -p "$OUT_DIR"
                echo "Running reportgenerator..."
                reportgenerator -reports:"$(CoverageFile)" -targetdir:"$OUT_DIR" -reporttypes:HtmlSummary;HtmlInline_AzurePipelines || echo "Report generation failed (continuing)"
                echo "Report directory contents:"; ls -la "$OUT_DIR" || true
                # Expose directory path
                echo "##vso[task.setvariable variable=CoverageReportDir]$OUT_DIR"

          - task: PublishCodeCoverageResults@2
            displayName: "Publish code coverage"
            condition: and(succeeded(), ne(variables.CoverageFile, ''))
            inputs:
              codeCoverageTool: Cobertura
              summaryFileLocation: "$(CoverageFile)"
              reportDirectory: "$(CoverageReportDir)"
              failIfCoverageEmpty: true
              # additionalCodeCoverageFiles can be added if multiple assemblies produce separate files

      - job: UITestJob
        displayName: "UI Tests with Playwright"
        dependsOn: TestJob
        condition: succeeded()
        steps:
          - checkout: self
            displayName: "Checkout code"
            fetchDepth: 0
            persistCredentials: true
            clean: true
          - task: Bash@3
            displayName: "Docker pre-clean (global)"
            inputs:
              targetType: inline
              script: |
                docker ps -aq | xargs -r docker rm -f || true
                docker image prune -af || true

          - task: UseDotNet@2
            displayName: "Setup .NET"
            inputs:
              packageType: "sdk"
              version: $(DOTNET_VERSION)

          - task: DotNetCoreCLI@2
            displayName: "Restore dependencies"
            inputs:
              command: "restore"
              projects: "AiStockTradeApp.sln"

          - task: DotNetCoreCLI@2
            displayName: "Build application"
            inputs:
              command: "build"
              projects: "AiStockTradeApp.sln"
              arguments: "--no-restore --configuration Release"

          - task: DotNetCoreCLI@2
            displayName: "Install Entity Framework tools"
            inputs:
              command: "custom"
              custom: "tool"
              arguments: "install --global dotnet-ef"

          - task: NodeTool@0
            displayName: "Setup Node.js (for Playwright CLI checks)"
            inputs:
              versionSpec: "20.x"

          # SQL Server container not required for UI tests; using in-memory DB

          # Removed EF Core database update for UI tests: app handles migrations on startup (post-deployment)

          # Install Playwright browsers for .NET (matches Microsoft.Playwright package version)
          - script: |
              set -e
              echo "Building UITests to generate Playwright install scripts..."
              dotnet build AiStockTradeApp.UITests/AiStockTradeApp.UITests.csproj --configuration Release --no-restore

              echo "Installing Playwright browsers (with OS deps) using .NET script..."
              PLAYWRIGHT_DIR="AiStockTradeApp.UITests/bin/Release/net9.0"
              SH_SCRIPT="$PLAYWRIGHT_DIR/playwright.sh"
              PS_SCRIPT="$PLAYWRIGHT_DIR/playwright.ps1"
              echo "Node version: $(node --version 2>/dev/null || echo 'not found')"
              echo "npm version:  $(npm --version 2>/dev/null || echo 'not found')"
              echo "Determining Microsoft.Playwright package version from csproj..."
              PW_VER=$(grep -oP '(?<=<PackageReference Include="Microsoft.Playwright" Version=")[^"]+' AiStockTradeApp.UITests/AiStockTradeApp.UITests.csproj || true)
              echo "Microsoft.Playwright package version: ${PW_VER:-unknown}"
              echo "Playwright CLI version BEFORE install (generic):"; npx -y playwright --version 2>/dev/null || echo "npx playwright not available"
              if [ -n "$PW_VER" ]; then echo "Playwright CLI version BEFORE install (pinned ${PW_VER}):"; npx -y "playwright@${PW_VER}" --version 2>/dev/null || echo "npx playwright@${PW_VER} not available"; fi
              # Install only Firefox (more reliable on Linux/CI)
              if [ -f "$SH_SCRIPT" ]; then
                echo "Using bash playwright.sh script"
                bash "$SH_SCRIPT" install --with-deps firefox
              elif [ -f "$PS_SCRIPT" ]; then
                echo "Using PowerShell playwright.ps1 script"
                if ! command -v pwsh >/dev/null 2>&1; then
                  echo "pwsh not found; installing PowerShell..."
                  sudo apt-get update -y && sudo apt-get install -y powershell
                fi
                pwsh -NoLogo -NoProfile -File "$PS_SCRIPT" install --with-deps firefox
              else
                echo "No playwright install script found in $PLAYWRIGHT_DIR" >&2
                echo "Directory listing of $PLAYWRIGHT_DIR:"; ls -la "$PLAYWRIGHT_DIR" || true
                echo "Directory listing of parent:"; ls -la AiStockTradeApp.UITests/bin/Release/ || true
                exit 1
              fi
              echo "Installed browsers in:"
              # Resolve and export browsers path for subsequent tasks
              PW_PATH="$HOME/.cache/ms-playwright"
              echo "PLAYWRIGHT_BROWSERS_PATH resolved to: $PW_PATH"
              echo "##vso[task.setvariable variable=PLAYWRIGHT_BROWSERS_PATH]$PW_PATH"
              ls -R "$PW_PATH" | head -200 || true

              echo "Playwright CLI version AFTER install (generic):"; npx -y playwright --version 2>/dev/null || echo "npx playwright not available"
              if [ -n "$PW_VER" ]; then echo "Playwright CLI version AFTER install (pinned ${PW_VER}):"; npx -y "playwright@${PW_VER}" --version 2>/dev/null || echo "npx playwright@${PW_VER} not available"; fi
              echo "Verified Microsoft.Playwright package version: ${PW_VER:-unknown}"
            displayName: "Install Playwright browsers (.NET)"

          - script: |
              # Start application in background
              echo "Starting application in background..."
              cd AiStockTradeApp
              nohup dotnet run --no-build --configuration Release --no-launch-profile > app.log 2>&1 &
              APP_PID=$!
              echo "Started application with PID: $APP_PID"
              echo $APP_PID > app.pid

              # Wait for application to be ready
              echo "Waiting for application to start..."
              timeout=120
              while [ $timeout -gt 0 ]; do
                if curl -f http://localhost:5000 >/dev/null 2>&1; then
                  echo "Application is ready!"
                  break
                fi
                echo "Waiting for application... ($timeout seconds remaining)"
                sleep 2
                timeout=$((timeout-2))
              done

              if [ $timeout -le 0 ]; then
                echo "Application failed to start within timeout"
                echo "Application logs:"
                cat app.log
                exit 1
              fi
            displayName: "Start application in background"
            env:
              ASPNETCORE_ENVIRONMENT: "Development"
              ASPNETCORE_URLS: "http://localhost:5000"
              USE_INMEMORY_DB: "true"
              # Ensure UI uses the same API URL that the tests will auto-start
              PLAYWRIGHT_API_BASE_URL: "http://localhost:5256"
              StockApi__BaseUrl: "http://localhost:5256"
              StockApi__HttpBaseUrl: "http://localhost:5256"

          - script: |
              # Start API in background
              echo "Starting API in background on http://localhost:5256 ..."
              cd AiStockTradeApp.Api
              nohup dotnet run --no-build --configuration Release --no-launch-profile --urls http://localhost:5256 > api.log 2>&1 &
              API_PID=$!
              echo "Started API with PID: $API_PID"
              echo $API_PID > api.pid

              # Wait for API to be ready (health endpoint)
              echo "Waiting for API to start..."
              timeout=120
              while [ $timeout -gt 0 ]; do
                if curl -f http://localhost:5256/health >/dev/null 2>&1; then
                  echo "API is ready!"
                  break
                fi
                echo "Waiting for API... ($timeout seconds remaining)"
                sleep 2
                timeout=$((timeout-2))
              done

              if [ $timeout -le 0 ]; then
                echo "API failed to start within timeout"
                echo "API logs:"
                cat api.log || true
                exit 1
              fi
            displayName: "Start API in background"
            env:
              ASPNETCORE_ENVIRONMENT: "Development"
              ASPNETCORE_URLS: "http://localhost:5256"
              USE_INMEMORY_DB: "true"

          - script: |
              echo "Waiting for application to start..."
              timeout=60
              while [ $timeout -gt 0 ]; do
                if curl -f http://localhost:5000 >/dev/null 2>&1; then
                  echo "Application is ready!"
                  break
                fi
                echo "Waiting for application... ($timeout seconds remaining)"
                sleep 2
                timeout=$((timeout-2))
              done

              if [ $timeout -le 0 ]; then
                echo "Application failed to start within timeout"
                exit 1
              fi
            displayName: "Wait for application to be ready"

          - script: |
              echo "=== Pre-test debugging ==="
              echo "Checking if UITests project built correctly..."
              ls -la AiStockTradeApp.UITests/bin/Release/net9.0/ || echo "Build output directory not found"

              echo "Checking for required assemblies..."
              ls -la AiStockTradeApp.UITests/bin/Release/net9.0/*Playwright* || echo "Playwright assemblies not found"
              ls -la AiStockTradeApp.UITests/bin/Release/net9.0/*NUnit* || echo "NUnit assemblies not found"

              echo "Checking test.runsettings file..."
              cat test.runsettings || echo "test.runsettings not found"

              echo "Environment variables:"
              echo "PLAYWRIGHT_BASE_URL: $PLAYWRIGHT_BASE_URL"
              echo "ASPNETCORE_ENVIRONMENT: $ASPNETCORE_ENVIRONMENT"
              echo "DISPLAY: $DISPLAY"
              echo "CI: $CI"
              echo "AZURE_PIPELINES: $AZURE_PIPELINES"

              echo "Testing application accessibility..."
              curl -v http://localhost:5000 || echo "Application not responding"

              echo "Skipping X11 display probe (not required for headless browsers)"

              echo "Checking Playwright CLI versions (generic and pinned)..."
              echo "Node version: $(node --version 2>/dev/null || echo 'not found')"
              echo "npm version:  $(npm --version 2>/dev/null || echo 'not found')"
              PW_VER=$(grep -oP '(?<=<PackageReference Include="Microsoft.Playwright" Version=")[^"]+' AiStockTradeApp.UITests/AiStockTradeApp.UITests.csproj || true)
              echo "Microsoft.Playwright package version: ${PW_VER:-unknown}"
              npx -y playwright --version 2>/dev/null || echo "npx playwright not available"
              if [ -n "$PW_VER" ]; then npx -y "playwright@${PW_VER}" --version 2>/dev/null || echo "npx playwright@${PW_VER} not available"; fi
              echo "Checking installed Playwright browsers in cache..."
              for b in chromium firefox webkit; do
                echo "Listing cache entries for $b:";
                find ~/.cache/ms-playwright -maxdepth 1 -type d -name "$b*" | head -5 || true;
              done

              echo "Testing simple browser launch (Firefox)..."
              # Quick launch validation using a minimal script with Firefox
                echo "Installing dotnet-script for inline launch probe..."
                dotnet tool install --global dotnet-script || true
                export PATH="$PATH:$HOME/.dotnet/tools"
              cat > mini-browser-test.csx <<'CSX'
              #r "nuget: Microsoft.Playwright"
              using Microsoft.Playwright;
              var pw = await Playwright.CreateAsync();
              var browser = await pw.Firefox.LaunchAsync(new() { Headless = true, Args = new[]{"--no-sandbox","--disable-setuid-sandbox","--disable-dev-shm-usage"} });
              var ctx = await browser.NewContextAsync();
              var page = await ctx.NewPageAsync();
              await page.GotoAsync("https://example.com");
              Console.WriteLine("Browser navigation OK: " + await page.TitleAsync());
              await browser.CloseAsync();
              CSX
              dotnet script mini-browser-test.csx || echo "Mini browser test failed (will let tests attempt)."
            displayName: "Pre-test debugging"
            env:
              ASPNETCORE_ENVIRONMENT: "Development"
              PLAYWRIGHT_BASE_URL: "http://localhost:5000"
              DISPLAY: ":99.0"
              CI: "true"
              AZURE_PIPELINES: "true"
              PLAYWRIGHT_BROWSERS_PATH: "$(PLAYWRIGHT_BROWSERS_PATH)"
              USE_INMEMORY_DB: "true" # Use EF in-memory provider for faster UI tests
              DISABLE_UI_TEST_AUTOSTART: "1" # Pipeline is starting UI and API

          - script: |
              echo "Listing all tests in UITests project..."
              dotnet test AiStockTradeApp.UITests --list-tests --verbosity normal
            displayName: "List UI Tests to be executed"

          - task: Bash@3
            displayName: "Run Playwright UI Tests (Firefox only)"
            inputs:
              targetType: inline
              script: |
                set -e
                dotnet test AiStockTradeApp.UITests/AiStockTradeApp.UITests.csproj \
                  --no-build --configuration Release --verbosity diagnostic \
                  --logger "trx;LogFileName=ui-test-results.trx" \
                  --settings ./test.runsettings \
                  --logger "console;verbosity=diagnostic" \
                  --results-directory "$(Agent.TempDirectory)" \
                  --diag "$(Agent.TempDirectory)/vstest-diag.txt"
            env:
              ASPNETCORE_ENVIRONMENT: "Development"
              PLAYWRIGHT_BASE_URL: "http://localhost:5000"
              PLAYWRIGHT_API_BASE_URL: "http://localhost:5256"
              ConnectionStrings__DefaultConnection: "Server=localhost;Database=StockTrackerTestUI; User Id=sa;Password=YourStrong@Passw0rd;TrustServerCertificate=true;Encrypt=false"
              DISPLAY: ":99.0"
              PLAYWRIGHT_LAUNCH_OPTIONS: '{"headless":true,"args":["--no-sandbox","--disable-setuid-sandbox","--disable-dev-shm-usage","--disable-gpu","--no-first-run","--no-default-browser-check","--disable-background-timer-throttling","--disable-backgrounding-occluded-windows","--disable-renderer-backgrounding"]}'
              BROWSER: "firefox"
              PWDEBUG: "0"
              DEBUG: "pw:api"
              CI: "true"
              AZURE_PIPELINES: "true"
              PLAYWRIGHT_BROWSERS_PATH: "$(PLAYWRIGHT_BROWSERS_PATH)"
              NODE_PATH: "$(System.DefaultWorkingDirectory)/AiStockTradeApp.UITests/node_modules"
              USE_INMEMORY_DB: "true" # In-memory DB accelerates UI tests
              VSTEST_RESULTS_DIRECTORY: "$(Agent.TempDirectory)"
              DISABLE_UI_TEST_AUTOSTART: "1"
            condition: succeededOrFailed()
            timeoutInMinutes: 25

          - task: Bash@3
            displayName: "Show VSTest diagnostic log (if present)"
            condition: always()
            inputs:
              targetType: inline
              script: |
                echo "VSTest diag log (tail):"
                tail -n 400 "$(Agent.TempDirectory)/vstest-diag.txt" 2>/dev/null || echo "No diag log present"

          - task: Bash@3
            displayName: "Diagnostics: List UI TRX in Agent.TempDirectory"
            inputs:
              targetType: inline
              script: |
                echo "Agent temp TRX files (UI):"
                find $(Agent.TempDirectory) -type f -name '*.trx' 2>/dev/null | head -40 || true
            condition: always()

          - task: Bash@3
            displayName: "Fallback: Copy UI TRX from workspace TestResults to Agent.TempDirectory"
            condition: always()
            inputs:
              targetType: inline
              script: |
                set -e
                SRC_DIR="$(System.DefaultWorkingDirectory)/TestResults"
                DEST_DIR="$(Agent.TempDirectory)"
                if [ -d "$SRC_DIR" ]; then
                  FOUND=$(find "$SRC_DIR" -type f -name '*ui-test-results.trx' | wc -l)
                  if [ "$FOUND" -gt 0 ]; then
                    echo "Found $FOUND UI TRX in $SRC_DIR. Copying to $DEST_DIR..."
                    find "$SRC_DIR" -type f -name '*ui-test-results.trx' -exec cp {} "$DEST_DIR/" \;
                  else
                    echo "No UI TRX in $SRC_DIR"
                  fi
                else
                  echo "No workspace TestResults directory present"
                fi

          - task: PublishTestResults@2
            displayName: "Publish UI Test Results"
            inputs:
              testResultsFormat: "VSTest"
              testResultsFiles: "*.trx"
              searchFolder: "$(Agent.TempDirectory)"
              testRunTitle: "Playwright UI Tests_$(Build.BuildId)"
              mergeTestResults: true
            condition: succeededOrFailed()

          - task: Bash@3
            displayName: "Collect UI TRX for artifact"
            condition: always()
            inputs:
              targetType: inline
              script: |
                set -e
                DEST="$(Pipeline.Workspace)/test-results/ui"
                mkdir -p "$DEST"
                echo "Collecting TRX from $(Agent.TempDirectory) to $DEST"
                find "$(Agent.TempDirectory)" -type f -name '*ui-test-results.trx' -print -exec cp {} "$DEST/" \; 2>/dev/null || true

          - task: PublishPipelineArtifact@1
            displayName: "Upload UI Test TRX"
            condition: always()
            inputs:
              targetPath: "$(Pipeline.Workspace)/test-results/ui"
              artifactName: "ui-test-results"

          - script: |
              echo "Capturing application logs for debugging..."
              if [ -f "AiStockTradeApp/app.log" ]; then
                echo "=== Application Logs ==="
                cat AiStockTradeApp/app.log
                echo "=== End Application Logs ==="
              else
                echo "No application log file found"
              fi
            displayName: "Debug: Show application logs"
            condition: failed()

          - script: |
              echo "Stopping application..."
              if [ -f "AiStockTradeApp/app.pid" ]; then
                APP_PID=$(cat AiStockTradeApp/app.pid)
                echo "Stopping application with PID: $APP_PID"
                kill $APP_PID || true
                sleep 5
              fi
              # Cleanup any remaining dotnet processes
              pkill -f "dotnet.*AiStockTradeApp" || true
            displayName: "Stop application"
            condition: always()

          - script: |
              echo "Stopping API..."
              if [ -f "AiStockTradeApp.Api/api.pid" ]; then
                API_PID=$(cat AiStockTradeApp.Api/api.pid)
                echo "Stopping API with PID: $API_PID"
                kill $API_PID || true
                sleep 5
              fi
              # Cleanup any remaining API dotnet processes
              pkill -f "dotnet.*AiStockTradeApp.Api" || true
            displayName: "Stop API"
            condition: always()

          # No SQL container used; cleanup not required

  - stage: Build
    displayName: "Build and Push Container"
    dependsOn: Test
    condition: succeeded()
    jobs:
      - job: BuildJob
        displayName: "Build and Push Container (UI + API)"
        variables:
          - name: containerImage
            value: ""
          - name: containerImageApi
            value: ""
          - name: registryName
            value: ""
          - name: resourceGroup
            value: ""
          - name: instanceNum
            value: ""

        steps:
          - checkout: self
            displayName: "Checkout code"
            fetchDepth: 0
            persistCredentials: true
            clean: true
          - task: Bash@3
            displayName: "Docker pre-clean (global)"
            inputs:
              targetType: inline
              script: |
                docker ps -aq | xargs -r docker rm -f || true
                docker image prune -af || true

          - task: AzureCLI@2
            displayName: "Get Container Registry Information"
            inputs:
              azureSubscription: "$(AZURE_SERVICE_CONNECTION)"
              scriptType: "bash"
              scriptLocation: "inlineScript"
              inlineScript: |
                # Always use dev environment container registry (shared across all environments)
                if [[ "$(Build.Reason)" == "Manual" ]]; then
                  INSTANCE_NUM="${{ parameters.instanceNumber }}"
                  echo "Manual trigger detected - Instance: ${INSTANCE_NUM}"
                else
                  INSTANCE_NUM="003"
                  echo "Branch push detected - Using default instance: ${INSTANCE_NUM}"
                fi

                # Always target dev resource group for container registry
                ENV="dev"
                RG_NAME="rg-aistock-${ENV}-${INSTANCE_NUM}"

                echo "=== BUILD ENVIRONMENT INFO ==="
                echo "Container Registry Environment: ${ENV} (shared registry)"
                echo "Instance Number: ${INSTANCE_NUM}"
                echo "Registry Resource Group: ${RG_NAME}"
                echo "Build Source Branch: $(Build.SourceBranch)"
                echo "Build Reason: $(Build.Reason)"

                # Get container registry name from dev resource group
                REGISTRY_NAME=$(az acr list --resource-group "${RG_NAME}" --query '[0].name' --output tsv)

                if [ -z "${REGISTRY_NAME}" ] || [ "${REGISTRY_NAME}" == "null" ]; then
                  echo "ERROR: No container registry found in resource group ${RG_NAME}"
                  echo "Available resource groups:"
                  az group list --query '[].name' --output table
                  echo "This might mean the dev infrastructure hasn't been deployed yet for instance ${INSTANCE_NUM}"
                  echo "Please deploy dev environment first to create the shared container registry."
                  exit 1
                fi

                echo "Found shared registry: ${REGISTRY_NAME}"
                echo "##vso[task.setvariable variable=registryName]${REGISTRY_NAME}"
                echo "##vso[task.setvariable variable=resourceGroup]${RG_NAME}"
                echo "##vso[task.setvariable variable=instanceNum]${INSTANCE_NUM}"

          - task: AzureCLI@2
            displayName: "Get Container Registry Credentials"
            inputs:
              azureSubscription: "$(AZURE_SERVICE_CONNECTION)"
              scriptType: "bash"
              scriptLocation: "inlineScript"
              inlineScript: |
                # Get admin credentials
                REGISTRY_USERNAME=$(az acr credential show --name "$(registryName)" --query 'username' --output tsv)
                REGISTRY_PASSWORD=$(az acr credential show --name "$(registryName)" --query 'passwords[0].value' --output tsv)

                echo "Registry Username: ${REGISTRY_USERNAME}"
                echo "Password length: ${#REGISTRY_PASSWORD}"

                echo "##vso[task.setvariable variable=registryUsername;issecret=true]${REGISTRY_USERNAME}"
                echo "##vso[task.setvariable variable=registryPassword;issecret=true]${REGISTRY_PASSWORD}"

          - task: Bash@3
            displayName: "Debug Registry Information"
            inputs:
              targetType: "inline"
              script: |
                echo "=== REGISTRY DEBUG INFO ==="
                echo "Instance Number: $(instanceNum)"
                echo "Registry name: $(registryName)"
                echo "Resource group: $(resourceGroup)"
                echo "Registry URL: $(registryName).azurecr.io"
                echo "=== TRIGGER INFO ==="
                echo "Build Source Branch: $(Build.SourceBranch)"
                echo "Build Reason: $(Build.Reason)"

          - task: AzureCLI@2
            displayName: "Login to Azure Container Registry"
            inputs:
              azureSubscription: "$(AZURE_SERVICE_CONNECTION)"
              scriptType: "bash"
              scriptLocation: "inlineScript"
              inlineScript: |
                echo "Logging in to Azure Container Registry: $(registryName).azurecr.io"
                az acr login --name "$(registryName)"

          - task: Bash@3
            displayName: "Determine Semantic Version (GitVersion CLI for Build)"
            inputs:
              targetType: inline
              script: |
                set -e
                if [ -n "$(GitVersion.FullSemVer)" ]; then
                  echo "GitVersion variables already present from previous stage/job: $(GitVersion.FullSemVer)"; exit 0; fi
                echo "Ensuring full git history & tags (safety fetch)..."
                git fetch --prune --tags --force || true
                echo "Commit count: $(git rev-list --count HEAD 2>/dev/null || echo '?')"
                git --no-pager log --oneline -n 5 || true
                echo "Installing GitVersion CLI (build stage)..."
                dotnet tool install --global GitVersion.Tool --version 5.* || { echo "Failed to install GitVersion.Tool"; exit 1; }
                export PATH="$PATH:$HOME/.dotnet/tools"
                RAW=$(dotnet-gitversion /config GitVersion.yml /output json 2>&1 || true)
                echo "Raw GitVersion output (first 40 lines):"; echo "$RAW" | head -40
                if ! echo "$RAW" | grep -q '"FullSemVer"'; then
                  echo "GitVersion failed or missing JSON; using placeholder version"; FULL="0.0.0-local";
                else
                  if ! command -v jq >/dev/null 2>&1; then sudo apt-get update -y && sudo apt-get install -y jq; fi
                  FULL=$(echo "$RAW" | jq -r '.FullSemVer // empty')
                  [ -n "$FULL" ] || FULL="0.0.0-local"
                fi
                echo "FullSemVer (build)=$FULL"
                echo "##vso[task.setvariable variable=GitVersion.FullSemVer]$FULL"
                echo "##vso[task.setvariable variable=FullSemVer]$FULL"

          - task: Bash@3
            displayName: "Show resolved semantic version (post GitVersion)"
            inputs:
              targetType: inline
              script: |
                echo "Resolved GitVersion.FullSemVer='$(GitVersion.FullSemVer)'"
                if [ "$(GitVersion.FullSemVer)" = "0.0.0-local" ] || [ -z "$(GitVersion.FullSemVer)" ]; then
                  echo "WARNING: Semantic version is placeholder. Investigate GitVersion output above. Tag push will skip.";
                fi

          - task: Bash@3
            displayName: "Generate Container Tags"
            inputs:
              targetType: "inline"
              script: |
                echo "=== GitVersion (if present) ==="
                if [ -n "$(GitVersion.FullSemVer)" ]; then
                  echo "FullSemVer: $(GitVersion.FullSemVer)"
                else
                  echo "GitVersion variables not set; falling back to branch/sha tags only."
                fi
                # Generate tags similar to docker/metadata-action
                REGISTRY_URL="$(registryName).azurecr.io"
                IMAGE_NAME_UI="${REGISTRY_URL}/aistocktradeapp"
                IMAGE_NAME_API="${REGISTRY_URL}/aistocktradeapp-api"

                # Branch-based tag
                BRANCH_NAME=$(echo "$(Build.SourceBranchName)" | sed 's/[^a-zA-Z0-9._-]/-/g')
                BRANCH_TAG_UI="${IMAGE_NAME_UI}:${BRANCH_NAME}"
                BRANCH_TAG_API="${IMAGE_NAME_API}:${BRANCH_NAME}"

                # SHA-based tag
                SHORT_SHA=$(echo "$(Build.SourceVersion)" | cut -c1-7)
                SHA_TAG_UI="${IMAGE_NAME_UI}:sha-${SHORT_SHA}"
                SHA_TAG_API="${IMAGE_NAME_API}:sha-${SHORT_SHA}"

                # Latest tag for main/master branch
                VERSION_TAG_UI=""; VERSION_TAG_API=""
                if [ -n "$(GitVersion.FullSemVer)" ]; then
                  VERSION_TAG_UI="${IMAGE_NAME_UI}:$(GitVersion.FullSemVer)"
                  VERSION_TAG_API="${IMAGE_NAME_API}:$(GitVersion.FullSemVer)"
                fi
                if [[ "$(Build.SourceBranchName)" == "main" || "$(Build.SourceBranchName)" == "master" ]]; then
                  LATEST_TAG_UI="${IMAGE_NAME_UI}:latest"; LATEST_TAG_API="${IMAGE_NAME_API}:latest"
                  if [ -n "$VERSION_TAG_UI" ]; then
                    TAGS_UI="${BRANCH_TAG_UI},${SHA_TAG_UI},${VERSION_TAG_UI},${LATEST_TAG_UI}"
                    TAGS_API="${BRANCH_TAG_API},${SHA_TAG_API},${VERSION_TAG_API},${LATEST_TAG_API}"
                  else
                    TAGS_UI="${BRANCH_TAG_UI},${SHA_TAG_UI},${LATEST_TAG_UI}"
                    TAGS_API="${BRANCH_TAG_API},${SHA_TAG_API},${LATEST_TAG_API}"
                  fi
                else
                  if [ -n "$VERSION_TAG_UI" ]; then
                    TAGS_UI="${BRANCH_TAG_UI},${SHA_TAG_UI},${VERSION_TAG_UI}"
                    TAGS_API="${BRANCH_TAG_API},${SHA_TAG_API},${VERSION_TAG_API}"
                  else
                    TAGS_UI="${BRANCH_TAG_UI},${SHA_TAG_UI}"
                    TAGS_API="${BRANCH_TAG_API},${SHA_TAG_API}"
                  fi
                fi

                echo "Generated UI tags: ${TAGS_UI}"
                echo "Generated API tags: ${TAGS_API}"
                echo "##vso[task.setvariable variable=containerTagsUI]${TAGS_UI}"
                echo "##vso[task.setvariable variable=containerTagsAPI]${TAGS_API}"

                DEPLOY_TAG_UI="${SHA_TAG_UI}"; DEPLOY_TAG_API="${SHA_TAG_API}"
                if [ -n "$VERSION_TAG_UI" ]; then DEPLOY_TAG_UI="$VERSION_TAG_UI"; fi
                if [ -n "$VERSION_TAG_API" ]; then DEPLOY_TAG_API="$VERSION_TAG_API"; fi
                echo "Selected UI deploy tag: ${DEPLOY_TAG_UI}"
                echo "Selected API deploy tag: ${DEPLOY_TAG_API}"
                echo "##vso[task.setvariable variable=deployTagUI]${DEPLOY_TAG_UI}"
                echo "##vso[task.setvariable variable=deployTagAPI]${DEPLOY_TAG_API}"

          - task: AzureCLI@2
            displayName: "Build and push Docker images (UI + API)"
            continueOnError: false
            inputs:
              azureSubscription: "$(AZURE_SERVICE_CONNECTION)"
              scriptType: "bash"
              scriptLocation: "inlineScript"
              inlineScript: |
                # Fail fast on any error, unset variable, or failed pipeline in a pipe
                set -euo pipefail
                trap 'echo "[ERROR] Build script failed at line $LINENO" >&2' ERR
                echo "=== BUILDING AND PUSHING CONTAINER IMAGE ==="

                # Parse container tags into individual arrays
                IFS=',' read -ra TAG_ARRAY_UI <<< "$(containerTagsUI)"
                IFS=',' read -ra TAG_ARRAY_API <<< "$(containerTagsAPI)"

                # Build UI image
                echo "Building UI Docker image..."
                if [ -n "$(GitVersion.FullSemVer)" ] && [ "$(GitVersion.FullSemVer)" != "0.0.0-local" ]; then
                  docker build --pull --build-arg APP_VERSION=$(GitVersion.FullSemVer) -f ./AiStockTradeApp/Dockerfile -t temp-build-image-ui .
                else
                  docker build --pull -f ./AiStockTradeApp/Dockerfile -t temp-build-image-ui .
                fi
                # Verify UI image built successfully
                docker image inspect temp-build-image-ui >/dev/null 2>&1 || { echo "UI image build failed (temp-build-image-ui not found)"; exit 1; }

                # Build API image
                echo "Building API Docker image..."
                if [ -n "$(GitVersion.FullSemVer)" ] && [ "$(GitVersion.FullSemVer)" != "0.0.0-local" ]; then
                  docker build --pull --build-arg APP_VERSION=$(GitVersion.FullSemVer) -f ./AiStockTradeApp.Api/Dockerfile -t temp-build-image-api .
                else
                  docker build --pull -f ./AiStockTradeApp.Api/Dockerfile -t temp-build-image-api .
                fi
                # Verify API image built successfully
                docker image inspect temp-build-image-api >/dev/null 2>&1 || { echo "API image build failed (temp-build-image-api not found)"; exit 1; }

                # Push UI tags
                for tag in "${TAG_ARRAY_UI[@]}"; do
                  clean_tag=$(echo "$tag" | xargs)
                  echo "Tagging and pushing UI: $clean_tag"
                  docker tag temp-build-image-ui "$clean_tag"
                  az acr repository show --name "$(registryName)" --repository aistocktradeapp || echo "Repository will be created"
                  docker push "$clean_tag"
                done

                # Push API tags
                for tag in "${TAG_ARRAY_API[@]}"; do
                  clean_tag=$(echo "$tag" | xargs)
                  echo "Tagging and pushing API: $clean_tag"
                  docker tag temp-build-image-api "$clean_tag"
                  az acr repository show --name "$(registryName)" --repository aistocktradeapp-api || echo "Repository will be created"
                  docker push "$clean_tag"
                done

                echo "All UI and API tags pushed successfully"
                echo "UI Deploy tag: $(deployTagUI)"
                echo "API Deploy tag: $(deployTagAPI)"

          - task: Bash@3
            displayName: "Create and push git semantic tag"
            condition: or(eq(variables['Build.SourceBranch'], 'refs/heads/main'), eq(variables['Build.SourceBranch'], 'refs/heads/develop'))
            inputs:
              targetType: inline
              script: |
                set -e
                VERSION="$(GitVersion.FullSemVer)"
                if [ -z "$VERSION" ] || [ "$VERSION" = "0.0.0-local" ]; then
                  echo "No valid semantic version available; skipping git tag."; exit 0; fi
                if [[ "$VERSION" != v* ]]; then VERSION="v$VERSION"; fi
                git config user.name "ci-bot"
                git config user.email "ci-bot@users.noreply.local"
                # Ensure tags are current before creating new one
                echo "Preparing to create tag $VERSION on commit $(Build.SourceVersion)"

                # If this commit modified any workflow files, skip tag creation to avoid
                # GitHub App 'workflows' permission rejection when pushing the tag.
                if git diff-tree --no-commit-id --name-only -r "$(Build.SourceVersion)" | grep -E '^\.github/workflows/' >/dev/null 2>&1; then
                  echo "Detected changes to .github/workflows/* in commit $(Build.SourceVersion); skipping tag creation/push.";
                  exit 0;
                fi

                git fetch --tags --prune || true
                if git rev-parse -q --verify "refs/tags/$VERSION" >/dev/null; then
                  echo "Tag $VERSION already exists; skipping."; exit 0; fi
                git tag -a "$VERSION" -m "Release $VERSION (Azure DevOps CI)" $(Build.SourceVersion)
                # Use OAuth token if available
                if [ -n "$SYSTEM_ACCESSTOKEN" ]; then
                  git -c http.extraheader="AUTHORIZATION: bearer $SYSTEM_ACCESSTOKEN" push origin "$VERSION" || {
                    echo "Tag push failed even with token"; exit 1; }
                else
                  git push origin "$VERSION" || echo "Push failed (no SYSTEM_ACCESSTOKEN)"
                fi
                echo "Tag operation complete"
            env:
              SYSTEM_ACCESSTOKEN: $(System.AccessToken)

          - task: Bash@3
            displayName: "Extract and set container image for deployment"
            inputs:
              targetType: "inline"
              script: |
                set -e  # Exit on any error
                echo "=== SETTING DEPLOYMENT IMAGE ==="

                DEPLOY_IMAGE="$(deployTagUI)"
                echo "Final deployment image: '${DEPLOY_IMAGE}'"

                # Check if DEPLOY_IMAGE is empty
                if [ -z "${DEPLOY_IMAGE}" ]; then
                  echo "ERROR: DEPLOY_IMAGE is empty after processing!"
                  exit 1
                fi

                # Write to artifact file for reliable transfer
                echo "=== CREATING ARTIFACT ==="
                mkdir -p $(Pipeline.Workspace)/build-outputs
                echo "${DEPLOY_IMAGE}" > $(Pipeline.Workspace)/build-outputs/container-image.txt
                echo "hello-from-build-stage" > $(Pipeline.Workspace)/build-outputs/test-output.txt

                echo "Artifact files created:"
                ls -la $(Pipeline.Workspace)/build-outputs/
                echo "Container image file contents:"
                cat $(Pipeline.Workspace)/build-outputs/container-image.txt

                echo "##vso[task.setvariable variable=containerImage;isOutput=true]${DEPLOY_IMAGE}"

          - task: Bash@3
            displayName: "Extract and set API container image for deployment"
            inputs:
              targetType: "inline"
              script: |
                set -e
                echo "=== SETTING API DEPLOYMENT IMAGE ==="
                DEPLOY_IMAGE_API="$(deployTagAPI)"
                echo "API deployment image: '${DEPLOY_IMAGE_API}'"
                if [ -z "${DEPLOY_IMAGE_API}" ]; then echo "ERROR: API DEPLOY_IMAGE empty"; exit 1; fi
                mkdir -p $(Pipeline.Workspace)/build-outputs
                echo "${DEPLOY_IMAGE_API}" > $(Pipeline.Workspace)/build-outputs/container-image-api.txt
                echo "##vso[task.setvariable variable=containerImageApi;isOutput=true]${DEPLOY_IMAGE_API}"

          - task: PublishPipelineArtifact@1
            displayName: "Upload build outputs as artifact"
            inputs:
              targetPath: "$(Pipeline.Workspace)/build-outputs"
              artifactName: "build-outputs"

  - stage: DeployDev
    displayName: "Deploy to Development"
    dependsOn: Build
    condition: |
      and(
        succeeded(),
        or(
          eq(variables['Build.SourceBranch'], 'refs/heads/develop'),
          eq(variables['Build.SourceBranch'], 'refs/heads/main'),
          and(
            eq(variables['Build.Reason'], 'Manual'),
            eq('${{ parameters.environment }}', 'dev')
          )
        )
      )
    jobs:
      - deployment: DeployDevJob
        displayName: "Deploy to Development"
        environment: ${{ format('development-{0}', parameters.instanceNumber) }}
        variables:
          - name: instanceNum
            value: ${{ format('{0}', parameters.instanceNumber) }}
        strategy:
          runOnce:
            deploy:
              steps:
                - checkout: self
                  displayName: "Checkout code"
                  fetchDepth: 0
                  persistCredentials: true
                  clean: true

                - task: DownloadPipelineArtifact@2
                  displayName: "Download build outputs"
                  inputs:
                    artifactName: "build-outputs"
                    downloadPath: "$(Pipeline.Workspace)/build-outputs"

                - task: Bash@3
                  displayName: "Load container image from artifact"
                  inputs:
                    targetType: "inline"
                    script: |
                      echo "=== LOADING CONTAINER IMAGE FROM ARTIFACT ==="
                      if [ -f "$(Pipeline.Workspace)/build-outputs/container-image.txt" ]; then
                        CONTAINER_IMAGE=$(cat $(Pipeline.Workspace)/build-outputs/container-image.txt)
                        echo "Container image from artifact: '${CONTAINER_IMAGE}'"
                        echo "##vso[task.setvariable variable=containerImage]${CONTAINER_IMAGE}"
                      else
                        echo "ERROR: container-image.txt not found in artifacts!"
                        ls -la $(Pipeline.Workspace)/build-outputs/
                        exit 1
                      fi
                - task: Bash@3
                  displayName: "Load API container image from artifact"
                  inputs:
                    targetType: "inline"
                    script: |
                      echo "=== LOADING API CONTAINER IMAGE FROM ARTIFACT ==="
                      if [ -f "$(Pipeline.Workspace)/build-outputs/container-image-api.txt" ]; then
                        CONTAINER_IMAGE=$(cat $(Pipeline.Workspace)/build-outputs/container-image-api.txt)
                        echo "API container image from artifact: '${CONTAINER_IMAGE}'"
                        echo "##vso[task.setvariable variable=containerImageApi]${CONTAINER_IMAGE}"
                      else
                        echo "ERROR: container-image-api.txt not found in artifacts!"
                        ls -la $(Pipeline.Workspace)/build-outputs/
                        exit 1
                      fi
                - task: Bash@3
                  displayName: "Derive appVersion parameter (Dev)"
                  inputs:
                    targetType: "inline"
                    script: |
                      IMG="$(containerImage)"
                      TAG="${IMG##*:}"
                      if echo "$TAG" | grep -Eq '^[0-9]+\.[0-9]+\.[0-9]+'; then
                        echo "Semantic version detected in image tag: $TAG"
                        echo "##vso[task.setvariable variable=appVersion]$TAG"
                      else
                        echo "Image tag $TAG is not semantic version; leaving appVersion empty"
                      fi

                - task: AzureResourceManagerTemplateDeployment@3
                  displayName: "Deploy Bicep template"
                  inputs:
                    deploymentScope: "Resource Group"
                    azureResourceManagerConnection: "$(AZURE_SERVICE_CONNECTION)"
                    subscriptionId: "$(AZURE_SUBSCRIPTION_ID)"
                    action: "Create Or Update Resource Group"
                    resourceGroupName: "rg-aistock-dev-$(instanceNum)"
                    location: "Canada Central"
                    templateLocation: "Linked artifact"
                    csmFile: "./infrastructure/main.bicep"
                    csmParametersFile: "./infrastructure/parameters.dev.json"
                    overrideParameters: "-instanceNumber $(instanceNum) -containerImage $(containerImage) -containerImageApi $(containerImageApi) -alphaVantageApiKey $(ALPHA_VANTAGE_API_KEY) -twelveDataApiKey $(TWELVE_DATA_API_KEY) -appVersion $(appVersion) -enableAzureAdOnlyAuth true -enablePrivateSql true -enablePrivateKeyVault true -manageNetworking false -manageSql false -appServicePlanSku ${{ parameters.appServicePlanSku }}"
                    deploymentMode: "Incremental"

                - task: AzureCLI@2
                  displayName: "Ensure SQL AD admin matches API Managed Identity (Dev)"
                  inputs:
                    azureSubscription: "$(AZURE_SERVICE_CONNECTION)"
                    scriptType: bash
                    scriptLocation: inlineScript
                    inlineScript: |
                      set -e
                      RG_NAME="rg-aistock-dev-$(instanceNum)"
                      WEBAPP_NAME="api-aistock-dev-$(instanceNum)"
                      SQL_SERVER_NAME="sql-aistock-dev-$(instanceNum)"
                      echo "[DEV] Ensuring SQL AD admin is set to API Web App MI..."
                      MI_PRINCIPAL_ID=$(az webapp identity show --name "$WEBAPP_NAME" --resource-group "$RG_NAME" --query principalId -o tsv 2>/dev/null || echo "")
                      if [ -z "$MI_PRINCIPAL_ID" ] || [ "$MI_PRINCIPAL_ID" = "null" ]; then echo "[DEV][ERROR] Web app MI principalId not found"; exit 1; fi
                      # Detect AAD-only mode; deleting admin is blocked when true
                      AAD_ONLY=$(az sql server ad-only-auth show --name "$SQL_SERVER_NAME" --resource-group "$RG_NAME" --query "azureAdOnlyAuthentication" -o tsv 2>/dev/null || echo "")
                      CURR_LOGIN=$(az sql server ad-admin list --server "$SQL_SERVER_NAME" --resource-group "$RG_NAME" --query "[0].login" -o tsv 2>/dev/null || echo "")
                      CURR_SID=$(az sql server ad-admin list --server "$SQL_SERVER_NAME" --resource-group "$RG_NAME" --query "[0].sid" -o tsv 2>/dev/null || echo "")
                      echo "[DEV] API Web App MI: $MI_PRINCIPAL_ID"; echo "[DEV] Current admin login: $CURR_LOGIN"; echo "[DEV] Current admin sid: $CURR_SID"
                      if [ "$CURR_SID" != "$MI_PRINCIPAL_ID" ]; then
                        echo "[DEV] Mismatch detected; updating SQL AD admin to API MI... (AAD-only=$AAD_ONLY)"
                        if [ "$AAD_ONLY" != "true" ]; then
                          az sql server ad-admin delete --server "$SQL_SERVER_NAME" --resource-group "$RG_NAME" || true
                        else
                          echo "[DEV] Skipping delete because AAD-only is enabled; will upsert via create."
                        fi
                        az sql server ad-admin create --server "$SQL_SERVER_NAME" --resource-group "$RG_NAME" --display-name "$WEBAPP_NAME" --object-id "$MI_PRINCIPAL_ID"
                      else
                        echo "[DEV] Already correct; no change needed."
                      fi
                      # Re-verify
                      NEW_SID=$(az sql server ad-admin list --server "$SQL_SERVER_NAME" --resource-group "$RG_NAME" --query "[0].sid" -o tsv 2>/dev/null || echo "")
                      if [ "$NEW_SID" != "$MI_PRINCIPAL_ID" ]; then
                        echo "[DEV][ERROR] Re-verify failed: SQL AD admin still not API MI (expected=$MI_PRINCIPAL_ID, found=$NEW_SID)"; exit 1
                      fi
                      echo "[DEV]  SQL AD admin set to API Web App MI."

                - task: AzureCLI@2
                  displayName: "Update Web App Container"
                  inputs:
                    azureSubscription: "$(AZURE_SERVICE_CONNECTION)"
                    scriptType: "bash"
                    scriptLocation: "inlineScript"
                    inlineScript: |
                      WEBAPP_NAME="app-aistock-dev-$(instanceNum)"
                      RG_NAME="rg-aistock-dev-$(instanceNum)"

                      # Get registry information from the same resource group
                      REGISTRY_NAME=$(az acr list --resource-group "${RG_NAME}" --query '[0].name' --output tsv)
                      REGISTRY_USERNAME=$(az acr credential show --name "${REGISTRY_NAME}" --query 'username' --output tsv)
                      REGISTRY_PASSWORD=$(az acr credential show --name "${REGISTRY_NAME}" --query 'passwords[0].value' --output tsv)

                      echo "Container Image: $(containerImage)"
                      echo "Web App Name: ${WEBAPP_NAME}"
                      echo "Resource Group: ${RG_NAME}"
                      echo "Registry Name: ${REGISTRY_NAME}"

                      if [ -z "$(containerImage)" ]; then
                        echo "ERROR: Container image is empty!"
                        exit 1
                      fi

                      az webapp config container set \
                        --name "${WEBAPP_NAME}" \
                        --resource-group "${RG_NAME}" \
                        --container-image-name "$(containerImage)" \
                        --container-registry-url "https://${REGISTRY_NAME}.azurecr.io" \
                        --container-registry-user "${REGISTRY_USERNAME}" \
                        --container-registry-password "${REGISTRY_PASSWORD}"

                - task: AzureCLI@2
                  displayName: "Update API Web App Container"
                  inputs:
                    azureSubscription: "$(AZURE_SERVICE_CONNECTION)"
                    scriptType: "bash"
                    scriptLocation: "inlineScript"
                    inlineScript: |
                      WEBAPP_NAME="api-aistock-dev-$(instanceNum)"
                      RG_NAME="rg-aistock-dev-$(instanceNum)"

                      REGISTRY_NAME=$(az acr list --resource-group "${RG_NAME}" --query '[0].name' --output tsv)
                      REGISTRY_USERNAME=$(az acr credential show --name "${REGISTRY_NAME}" --query 'username' --output tsv)
                      REGISTRY_PASSWORD=$(az acr credential show --name "${REGISTRY_NAME}" --query 'passwords[0].value' --output tsv)

                      echo "API Container Image: $(containerImageApi)"
                      echo "API Web App Name: ${WEBAPP_NAME}"
                      echo "Resource Group: ${RG_NAME}"
                      echo "Registry Name: ${REGISTRY_NAME}"

                      if [ -z "$(containerImageApi)" ]; then echo "ERROR: API container image is empty!"; exit 1; fi

                      az webapp config container set \
                        --name "${WEBAPP_NAME}" \
                        --resource-group "${RG_NAME}" \
                        --container-image-name "$(containerImageApi)" \
                        --container-registry-url "https://${REGISTRY_NAME}.azurecr.io" \
                        --container-registry-user "${REGISTRY_USERNAME}" \
                        --container-registry-password "${REGISTRY_PASSWORD}"

                - task: AzureCLI@2
                  displayName: "Run Health Check"
                  inputs:
                    azureSubscription: "$(AZURE_SERVICE_CONNECTION)"
                    scriptType: "bash"
                    scriptLocation: "inlineScript"
                    inlineScript: |
                      WEBAPP_NAME="app-aistock-dev-$(instanceNum)"
                      RG_NAME="rg-aistock-dev-$(instanceNum)"
                      HEALTH_URL="https://${WEBAPP_NAME}.azurewebsites.net/health"
                      BASE_URL="https://${WEBAPP_NAME}.azurewebsites.net"
                      echo " Starting comprehensive health check (Dev UI)..."
                      echo "Base URL: ${BASE_URL}"
                      echo "Health URL: ${HEALTH_URL}"
                      echo "Waiting for deployment to be ready..."
                      sleep 60
                      echo "Testing basic site accessibility..."
                      for i in {1..5}; do
                        if curl -f -s "${BASE_URL}" >/dev/null 2>&1; then
                          echo " Site is accessible (attempt $i)"; break
                        else
                          echo " Site not ready yet (attempt $i/5)..."; sleep 20
                        fi
                      done
                      echo "Testing health endpoint..."
                      for i in {1..10}; do
                        echo "Health check attempt $i/10..."
                        HTTP_CODE=$(curl -s -o /tmp/health_ui_dev.txt -w "%{http_code}" "${HEALTH_URL}")
                        RESPONSE_BODY=$(cat /tmp/health_ui_dev.txt 2>/dev/null || echo "No response body")
                        echo "HTTP Status: ${HTTP_CODE}"; echo "Response: ${RESPONSE_BODY}"
                        if [ "${HTTP_CODE}" = "200" ]; then
                          echo " Health check passed!"; exit 0
                        fi
                        sleep 30
                      done
                      echo " UI Health check failed (Dev)"; exit 1

                - task: AzureCLI@2
                  displayName: "Run API Health Check"
                  inputs:
                    azureSubscription: "$(AZURE_SERVICE_CONNECTION)"
                    scriptType: "bash"
                    scriptLocation: "inlineScript"
                    inlineScript: |
                      WEBAPP_NAME="api-aistock-dev-$(instanceNum)"
                      RG_NAME="rg-aistock-dev-$(instanceNum)"
                      HEALTH_URL="https://${WEBAPP_NAME}.azurewebsites.net/health"
                      BASE_URL="https://${WEBAPP_NAME}.azurewebsites.net"
                      echo " Starting API health check (Dev API)..."
                      echo "Base URL: ${BASE_URL}"
                      echo "Health URL: ${HEALTH_URL}"
                      echo "Waiting for API deployment to be ready..."
                      sleep 60
                      for i in {1..10}; do
                        echo "API Health check attempt $i/10..."
                        HTTP_CODE=$(curl -s -o /tmp/health_api_dev.txt -w "%{http_code}" "${HEALTH_URL}")
                        RESPONSE_BODY=$(cat /tmp/health_api_dev.txt 2>/dev/null || echo "No response body")
                        echo "HTTP Status: ${HTTP_CODE}"; echo "Response: ${RESPONSE_BODY}"
                        if [ "${HTTP_CODE}" = "200" ]; then
                          echo " API Health check passed!"; exit 0
                        fi
                        sleep 30
                      done
                      echo " API Health check failed"; exit 1

  - stage: DeployProd
    displayName: "Deploy to Production"
    dependsOn:
      - Build
      - DeployDev
    condition: |
      and(
        succeeded(),
        in(dependencies.Build.result, 'Succeeded'),
        in(dependencies.DeployDev.result, 'Succeeded', 'Skipped'),
        or(
          eq(variables['Build.SourceBranch'], 'refs/heads/main'),
          and(
            eq(variables['Build.Reason'], 'Manual'),
            eq('${{ parameters.environment }}', 'prod')
          )
        )
      )
    jobs:
      - deployment: DeployProdJob
        displayName: "Deploy to Production"
        environment: ${{ format('production-{0}', parameters.instanceNumber) }}
        variables:
          - name: instanceNum
            value: ${{ format('{0}', parameters.instanceNumber) }}
        strategy:
          runOnce:
            deploy:
              steps:
                - checkout: self
                  displayName: "Checkout code"
                  fetchDepth: 0
                  persistCredentials: true
                  clean: true

                - task: DownloadPipelineArtifact@2
                  displayName: "Download build outputs"
                  inputs:
                    artifactName: "build-outputs"
                    downloadPath: "$(Pipeline.Workspace)/build-outputs"

                - task: Bash@3
                  displayName: "Load container image from artifact"
                  inputs:
                    targetType: "inline"
                    script: |
                      echo "=== LOADING CONTAINER IMAGE FROM ARTIFACT ==="
                      if [ -f "$(Pipeline.Workspace)/build-outputs/container-image.txt" ]; then
                        CONTAINER_IMAGE=$(cat $(Pipeline.Workspace)/build-outputs/container-image.txt)
                        echo "Container image from artifact: '${CONTAINER_IMAGE}'"
                        echo "##vso[task.setvariable variable=containerImage]${CONTAINER_IMAGE}"
                      else
                        echo "ERROR: container-image.txt not found in artifacts!"
                        ls -la $(Pipeline.Workspace)/build-outputs/
                        exit 1
                      fi
                - task: Bash@3
                  displayName: "Load API container image from artifact"
                  inputs:
                    targetType: "inline"
                    script: |
                      echo "=== LOADING API CONTAINER IMAGE FROM ARTIFACT ==="
                      if [ -f "$(Pipeline.Workspace)/build-outputs/container-image-api.txt" ]; then
                        CONTAINER_IMAGE=$(cat $(Pipeline.Workspace)/build-outputs/container-image-api.txt)
                        echo "API container image from artifact: '${CONTAINER_IMAGE}'"
                        echo "##vso[task.setvariable variable=containerImageApi]${CONTAINER_IMAGE}"
                      else
                        echo "ERROR: container-image-api.txt not found in artifacts!"
                        ls -la $(Pipeline.Workspace)/build-outputs/
                        exit 1
                      fi

                - task: Bash@3
                  displayName: "Debug Variables"
                  inputs:
                    targetType: "inline"
                    script: |
                      echo "=== DEPLOYMENT DEBUG INFO ==="
                      echo "Stage name: DeployProd"
                      echo "Build Source Branch: $(Build.SourceBranch)"
                      echo "Build Reason: $(Build.Reason)"
                      echo "Environment parameter: ${{ parameters.environment }}"
                      echo "Instance Number: $(instanceNum)"
                      echo "Resource Group: rg-aistock-prod-$(instanceNum)"
                      echo "Web App Name: app-aistock-prod-$(instanceNum)"
                      echo "Container image from artifact: $(containerImage)"

                - task: AzureCLI@2
                  displayName: "Get Azure AD information for SQL Admin"
                  inputs:
                    azureSubscription: "$(AZURE_SERVICE_CONNECTION)"
                    scriptType: "bash"
                    scriptLocation: "inlineScript"
                    inlineScript: |
                      echo "Getting Azure AD information for SQL Server administration..."

                      # Get the service principal information from the service connection
                      # The service connection provides authentication context
                      echo "Retrieving service principal information from connection context..."

                      # Get service principal details using Azure CLI context
                      SP_INFO=$(az account show)
                      TENANT_ID=$(echo "$SP_INFO" | jq -r '.tenantId')

                      # For Azure DevOps, we'll use a predefined service principal name or get it from variables
                      # This should be configured in your Azure DevOps variables
                      if [ -n "$(AZURE_CLIENT_ID)" ]; then
                        CLIENT_ID="$(AZURE_CLIENT_ID)"
                        echo "Using client ID from variable: $CLIENT_ID"
                        
                        SP_DETAILS=$(az ad sp show --id "$CLIENT_ID")
                        SP_OBJECT_ID=$(echo "$SP_DETAILS" | jq -r '.id')
                        SP_DISPLAY_NAME=$(echo "$SP_DETAILS" | jq -r '.displayName')
                      else
                        echo "AZURE_CLIENT_ID variable not set. Using account context..."
                        # Fallback: try to get service principal from current context
                        SUBSCRIPTION_INFO=$(az account show)
                        SP_OBJECT_ID=$(echo "$SUBSCRIPTION_INFO" | jq -r '.user.name')
                        SP_DISPLAY_NAME="Azure DevOps Service Principal"
                      fi

                      echo "Service principal object ID: $SP_OBJECT_ID"
                      echo "Service principal display name: $SP_DISPLAY_NAME"

                      echo "##vso[task.setvariable variable=azureAdAdminObjectId]$SP_OBJECT_ID"
                      echo "##vso[task.setvariable variable=azureAdAdminLogin]$SP_DISPLAY_NAME"

                - task: Bash@3
                  displayName: "Derive Azure AD auth enable flag"
                  inputs:
                    targetType: "inline"
                    script: |
                      echo "Evaluating whether to enable Azure AD only auth..."
                      # Use Azure DevOps variable syntax: $VARIABLE (already set earlier)
                      if [ -n "$azureAdAdminObjectId" ] && [ -n "$azureAdAdminLogin" ]; then
                        echo "Azure AD admin details present. Enabling AAD only auth."
                        echo "##vso[task.setvariable variable=enableAdOnlyAuthFlag]true"
                      else
                        echo "Azure AD admin details missing (objectId='$azureAdAdminObjectId', login='$azureAdAdminLogin'). Disabling AAD only auth for this deployment."
                        echo "##vso[task.setvariable variable=enableAdOnlyAuthFlag]false"
                      fi
                      echo "enableAdOnlyAuthFlag=$enableAdOnlyAuthFlag"

                - task: Bash@3
                  displayName: "Derive appVersion parameter (Prod)"
                  inputs:
                    targetType: "inline"
                    script: |
                      IMG="$(containerImage)"
                      TAG="${IMG##*:}"
                      if echo "$TAG" | grep -Eq '^[0-9]+\.[0-9]+\.[0-9]+'; then
                        echo "Semantic version detected in image tag: $TAG"
                        echo "##vso[task.setvariable variable=appVersion]$TAG"
                      else
                        echo "Image tag $TAG is not semantic version; leaving appVersion empty"
                      fi
                - task: Bash@3
                  displayName: "Compute manageSql/manageNetworking runtime params"
                  inputs:
                    targetType: "inline"
                    script: |
                      set -e
                      echo "Computing runtime flags for manageSql and manageNetworking (Prod)..."
                      RG_NAME="rg-aistock-prod-$(instanceNum)"
                      SQL_SERVER_NAME="sql-aistock-prod-$(instanceNum)"

                      # Safer, more accurate detection for Prod: search the subscription for SQL server
                      # and for any subnet named 'snet-appintegration'. If we find them anywhere, avoid
                      # letting ARM manage those pieces (safe default). Only let ARM create them if the
                      # resources are definitely absent across the subscription.
                      MANAGE_SQL_PARAM="-manageSql false"
                      FOUND_SQL=0
                      # First try the expected RG (fast)
                      echo "[PROD][DEBUG] Running: az sql server show --name '$SQL_SERVER_NAME' --resource-group '$RG_NAME' -o json"
                      SQL_SHOW_RAW=$(az sql server show --name "$SQL_SERVER_NAME" --resource-group "$RG_NAME" -o json 2>&1 || true)
                      echo "[PROD][DEBUG] az sql server show output (first 200 lines):";
                      echo "$SQL_SHOW_RAW" | sed -n '1,200p' || true
                      if echo "$SQL_SHOW_RAW" | grep -q '"name"'; then
                        FOUND_SQL=1
                        SQL_RG="$RG_NAME"
                        echo "[PROD] SQL server found in expected RG: $SQL_RG"
                      else
                        echo "[PROD][DEBUG] az sql server show did not find server in expected RG. Searching subscription..."
                        echo "[PROD][DEBUG] Running: az sql server list --query \"[?name=='${SQL_SERVER_NAME}'] | [0]\" -o json"
                        SQL_LIST_RAW=$(az sql server list --query "[?name=='${SQL_SERVER_NAME}'] | [0]" -o json 2>&1 || true)
                        echo "[PROD][DEBUG] az sql server list item (first 200 lines):";
                        echo "$SQL_LIST_RAW" | sed -n '1,200p' || true
                        SQL_RG=$(echo "$SQL_LIST_RAW" | jq -r '.resourceGroup // empty' 2>/dev/null || echo "")
                        if [ -n "$SQL_RG" ]; then
                          FOUND_SQL=1
                          echo "[PROD] SQL server found in subscription in resource group: $SQL_RG"
                        else
                          echo "[PROD] SQL server not found in subscription"
                        fi
                      fi

                      if [ $FOUND_SQL -eq 1 ]; then
                        # If server exists, check AAD-only flag from the actual resource group (if known)
                        echo "[PROD][DEBUG] Checking azureADOnlyAuthentication on server in RG: ${SQL_RG:-$RG_NAME}"
                        AADONLY_RAW=$(az sql server show --name "$SQL_SERVER_NAME" --resource-group "${SQL_RG:-$RG_NAME}" -o json 2>&1 || true)
                        echo "[PROD][DEBUG] az sql server show (for AAD check) output (first 200 lines):";
                        echo "$AADONLY_RAW" | sed -n '1,200p' || true
                        AADONLY=$(echo "$AADONLY_RAW" | jq -r '.properties.azureADOnlyAuthentication // empty' 2>/dev/null || echo "")
                        echo "[PROD] Azure AD-only authentication on server: ${AADONLY:-unknown}"
                        # If AAD-only is enabled or unknown, avoid managing SQL via ARM
                        if [ "$AADONLY" = "false" ] || [ "$AADONLY" = "False" ]; then
                          echo "[PROD] Azure AD-only authentication disabled; ARM could manage SQL, but defaulting to safe=false"
                          MANAGE_SQL_PARAM="-manageSql false"
                        else
                          echo "[PROD] Azure AD-only authentication enabled or unknown; skipping SQL management"
                          MANAGE_SQL_PARAM="-manageSql false"
                        fi
                      else
                        # Definitively not present anywhere in the subscription: allow ARM to create it
                        MANAGE_SQL_PARAM="-manageSql true"
                      fi

                      # Determine manageNetworking param by searching the subscription for any subnet named snet-appintegration
                      MANAGE_NETWORKING_PARAM="-manageNetworking false"
                      SUBNET_NAME="snet-appintegration"
                      echo "[PROD] Searching subscription for subnets named ${SUBNET_NAME} (this may take a moment)"
                      echo "[PROD][DEBUG] Running: az network vnet list -o json"
                      VNETS_RAW=$(az network vnet list -o json 2>&1 || true)
                      echo "[PROD][DEBUG] az network vnet list output (first 200 lines):";
                      echo "$VNETS_RAW" | sed -n '1,200p' || true
                      # Now filter for subnets named snet-appintegration
                      SUBNET_MATCHES=$(echo "$VNETS_RAW" | jq -r '.[] | {vnet:.name, rg:.resourceGroup, subnets:.subnets[]?} | select(.subnets.name=="'${SUBNET_NAME}'") | "vnet: \(.vnet) rg: \(.rg) subnet: \(.subnets.name)"' 2>/dev/null || true)
                      if [ -n "$SUBNET_MATCHES" ]; then
                        echo "[PROD] Found existing integration subnet(s):"
                        echo "$SUBNET_MATCHES" | head -20 || true
                        MANAGE_NETWORKING_PARAM="-manageNetworking false"
                      else
                        echo "[PROD] No subnet named ${SUBNET_NAME} found in any VNet in this subscription; ARM may manage networking"
                        MANAGE_NETWORKING_PARAM="-manageNetworking true"
                      fi

                      echo "Computed MANAGE_SQL_PARAM=$MANAGE_SQL_PARAM"
                      echo "Computed MANAGE_NETWORKING_PARAM=$MANAGE_NETWORKING_PARAM"
                      echo "##vso[task.setvariable variable=MANAGE_SQL_PARAM]$MANAGE_SQL_PARAM"
                      echo "##vso[task.setvariable variable=MANAGE_NETWORKING_PARAM]$MANAGE_NETWORKING_PARAM"

                - task: Bash@3
                  displayName: "Debug: effective ARM override parameters (Prod)"
                  inputs:
                    targetType: "inline"
                    script: |
                      set -euo pipefail
                      # Print the important variables the ARM task will use so we can correlate failures
                      echo "=== PROD ARM DEPLOY PARAMS ==="
                      echo "instanceNum=$(instanceNum)"
                      echo "containerImage=$(containerImage)"
                      echo "containerImageApi=$(containerImageApi)"
                      echo "MANAGE_NETWORKING_PARAM=${MANAGE_NETWORKING_PARAM:-}" 
                      echo "MANAGE_SQL_PARAM=${MANAGE_SQL_PARAM:-}" 
                      echo "enableAdOnlyAuthFlag=${enableAdOnlyAuthFlag:-}" 
                      echo "azureAdAdminObjectId=${azureAdAdminObjectId:-}" 
                      echo "azureAdAdminLogin=${azureAdAdminLogin:-}" 
                      # Build the override string we will pass to the ARM task. Intentionally omit azureAdAdminObjectId/login
                      # Use the computed enableAdOnlyAuthFlag so ARM won't attempt to change AAD-only settings when not desired
                      OVERRIDES="-instanceNumber $(instanceNum) -containerImage $(containerImage) -containerImageApi $(containerImageApi) -enableAzureAdOnlyAuth ${enableAdOnlyAuthFlag:-false} -enablePrivateSql true -enablePrivateKeyVault true ${MANAGE_NETWORKING_PARAM:-} ${MANAGE_SQL_PARAM:-} -appVersion $(appVersion) -appServicePlanSku ${{ parameters.appServicePlanSku }}"
                      echo "Computed overrideParameters: $OVERRIDES"
                      # expose to subsequent tasks
                      echo "##vso[task.setvariable variable=PROD_ARM_OVERRIDES]$OVERRIDES"

                - task: AzureCLI@2
                  displayName: "Pre-deploy MSI sanity check (ensure API webapp MI)"
                  inputs:
                    azureSubscription: "$(AZURE_SERVICE_CONNECTION)"
                    scriptType: bash
                    scriptLocation: inlineScript
                    inlineScript: |
                      set -e
                      API_WEBAPP="api-aistock-prod-$(instanceNum)"
                      APP_WEBAPP="app-aistock-prod-$(instanceNum)"
                      RG_NAME="rg-aistock-prod-$(instanceNum)"
                      echo "[PROD][MSI-GUARD] Checking managed identities for $API_WEBAPP and $APP_WEBAPP in $RG_NAME"
                      API_MI=$(az webapp identity show --name "$API_WEBAPP" --resource-group "$RG_NAME" --query principalId -o tsv 2>/dev/null || echo "")
                      APP_MI=$(az webapp identity show --name "$APP_WEBAPP" --resource-group "$RG_NAME" --query principalId -o tsv 2>/dev/null || echo "")
                      echo "[PROD][MSI-GUARD] API_MI=$API_MI"
                      echo "[PROD][MSI-GUARD] APP_MI=$APP_MI"
                      if [ -z "$API_MI" ]; then
                        echo "[PROD][MSI-GUARD][ERROR] API webapp ($API_WEBAPP) has no managed identity assigned. Aborting."
                        exit 1
                      fi
                      if [ "$API_MI" = "$APP_MI" ]; then
                        echo "[PROD][MSI-GUARD][ERROR] API and UI webapps share the same managed identity ($API_MI). Aborting to avoid assigning wrong admin."
                        exit 1
                      fi
                      echo "[PROD][MSI-GUARD][OK] API managed identity looks correct: $API_MI"
                      # Expose for downstream steps
                      echo "##vso[task.setvariable variable=MI_PRINCIPAL_ID]$API_MI"

                - task: AzureResourceManagerTemplateDeployment@3
                  displayName: "Deploy Bicep template (prod - no ARM SQL admin)"
                  inputs:
                    deploymentScope: "Resource Group"
                    azureResourceManagerConnection: "$(AZURE_SERVICE_CONNECTION)"
                    subscriptionId: "$(AZURE_SUBSCRIPTION_ID)"
                    action: "Create Or Update Resource Group"
                    resourceGroupName: "rg-aistock-prod-$(instanceNum)"
                    location: "Canada Central"
                    templateLocation: "Linked artifact"
                    csmFile: "./infrastructure/main.bicep"
                    csmParametersFile: "./infrastructure/parameters.prod.json"
                    # NOTE: Do NOT pass azureAdAdminObjectId/login from the DevOps service principal into the ARM deployment.
                    # Many service principals used by pipelines lack Microsoft Graph permissions required to upsert SQL AAD admins
                    # which causes ARM deployments to fail. Instead we set the SQL AAD admin post-deploy via a CLI step (see next).
                    overrideParameters: "$(PROD_ARM_OVERRIDES)"
                    deploymentMode: "Incremental"

                - task: AzureCLI@2
                  displayName: "Ensure SQL AD admin matches API Managed Identity (Prod)"
                  inputs:
                    azureSubscription: "$(AZURE_SERVICE_CONNECTION)"
                    scriptType: bash
                    scriptLocation: inlineScript
                    inlineScript: |
                      set -e
                      RG_NAME="rg-aistock-prod-$(instanceNum)"
                      WEBAPP_NAME="api-aistock-prod-$(instanceNum)"
                      SQL_SERVER_NAME="sql-aistock-prod-$(instanceNum)"
                      echo "[PROD] Ensuring SQL AD admin is set to API Web App MI..."
                      MI_PRINCIPAL_ID=$(az webapp identity show --name "$WEBAPP_NAME" --resource-group "$RG_NAME" --query principalId -o tsv 2>/dev/null || echo "")
                      if [ -z "$MI_PRINCIPAL_ID" ] || [ "$MI_PRINCIPAL_ID" = "null" ]; then echo "[PROD][ERROR] Web app MI principalId not found"; exit 1; fi
                      # Detect AAD-only mode; deleting admin is blocked when true
                      AAD_ONLY=$(az sql server ad-only-auth show --name "$SQL_SERVER_NAME" --resource-group "$RG_NAME" --query "azureAdOnlyAuthentication" -o tsv 2>/dev/null || echo "")
                      CURR_LOGIN=$(az sql server ad-admin list --server "$SQL_SERVER_NAME" --resource-group "$RG_NAME" --query "[0].login" -o tsv 2>/dev/null || echo "")
                      CURR_SID=$(az sql server ad-admin list --server "$SQL_SERVER_NAME" --resource-group "$RG_NAME" --query "[0].sid" -o tsv 2>/dev/null || echo "")
                      echo "[PROD] API Web App MI: $MI_PRINCIPAL_ID"; echo "[PROD] Current admin login: $CURR_LOGIN"; echo "[PROD] Current admin sid: $CURR_SID"
                      if [ "$CURR_SID" != "$MI_PRINCIPAL_ID" ]; then
                        echo "[PROD] Mismatch detected; updating SQL AD admin to API MI... (AAD-only=$AAD_ONLY)"
                        if [ "$AAD_ONLY" != "true" ]; then
                          az sql server ad-admin delete --server "$SQL_SERVER_NAME" --resource-group "$RG_NAME" || true
                        else
                          echo "[PROD] Skipping delete because AAD-only is enabled; will upsert via create."
                        fi
                        az sql server ad-admin create --server "$SQL_SERVER_NAME" --resource-group "$RG_NAME" --display-name "$WEBAPP_NAME" --object-id "$MI_PRINCIPAL_ID"
                      else
                        echo "[PROD] Already correct; no change needed."
                      fi
                      # Re-verify
                      NEW_SID=$(az sql server ad-admin list --server "$SQL_SERVER_NAME" --resource-group "$RG_NAME" --query "[0].sid" -o tsv 2>/dev/null || echo "")
                      if [ "$NEW_SID" != "$MI_PRINCIPAL_ID" ]; then
                        echo "[PROD][ERROR] Re-verify failed: SQL AD admin still not API MI (expected=$MI_PRINCIPAL_ID, found=$NEW_SID)"; exit 1
                      fi
                      echo "[PROD]  SQL AD admin set to API Web App MI."

                # Removed re-assignment of SQL admin here; infra pipeline owns that responsibility.

                - task: AzureCLI@2
                  displayName: "Setup Web App SQL Database Access (Azure AD)"
                  inputs:
                    azureSubscription: "$(AZURE_SERVICE_CONNECTION)"
                    scriptType: "bash"
                    scriptLocation: "inlineScript"
                    inlineScript: |
                      # Do NOT 'set -e' globally; we handle retries manually
                      INSTANCE_NUM="$(instanceNum)"
                      RG_NAME="rg-aistock-prod-$(instanceNum)"
                      WEBAPP_NAME="app-aistock-prod-$(instanceNum)"
                      SQL_SERVER_NAME="sql-aistock-prod-$(instanceNum)"
                      DATABASE_NAME="sqldb-aistock-prod-$(instanceNum)"
                      ENABLE_AAD_ONLY="$(enableAdOnlyAuthFlag)"
                      echo "[INFO] === Managed identity SQL database access setup ==="
                      echo "[INFO] ENABLE_AAD_ONLY=${ENABLE_AAD_ONLY}"
                      if [ "${ENABLE_AAD_ONLY}" != "true" ]; then echo "[INFO] AAD-only auth disabled; skipping."; exit 0; fi
                      echo "[INFO] Ensuring web app managed identity enabled..."
                      MANAGED_IDENTITY=$(az webapp identity show --name "${WEBAPP_NAME}" --resource-group "${RG_NAME}" --query principalId -o tsv 2>/dev/null || echo "")
                      if [ -z "$MANAGED_IDENTITY" ] || [ "$MANAGED_IDENTITY" = "null" ]; then
                        az webapp identity assign --name "$WEBAPP_NAME" --resource-group "$RG_NAME" >/dev/null
                        sleep 8
                        MANAGED_IDENTITY=$(az webapp identity show --name "$WEBAPP_NAME" --resource-group "$RG_NAME" --query principalId -o tsv)
                      fi
                      echo "[INFO] Managed identity principalId: $MANAGED_IDENTITY"
                      SQL_SERVER_FQDN="${SQL_SERVER_NAME}.database.windows.net"
                      echo "[INFO] Waiting for database '${DATABASE_NAME}' to be online..."
                      for i in $(seq 1 18); do
                        ACCESS_TOKEN_TMP=$(az account get-access-token --resource https://database.windows.net/ --query accessToken -o tsv 2>/dev/null || echo "")
                        if [ -n "$ACCESS_TOKEN_TMP" ]; then
                          export SQLCMDACCESSTOKEN="$ACCESS_TOKEN_TMP"
                          if /opt/mssql-tools/bin/sqlcmd -S "$SQL_SERVER_FQDN" -d master -C -l 15 -h -1 -Q "SET NOCOUNT ON; SELECT state_desc FROM sys.databases WHERE name='${DATABASE_NAME}';" | grep -qi 'ONLINE'; then
                            echo "[INFO] Database is ONLINE (attempt $i)"; break
                          fi
                        fi
                        echo "[INFO] Database not online yet (attempt $i/18); sleeping 10s..."; sleep 10
                      done
                      echo "[INFO] Checking configured Azure AD admin on SQL server..."
                      ADMIN_CHECK_ATTEMPTS=12
                      ADMIN_SEEN=0
                      for i in $(seq 1 $ADMIN_CHECK_ATTEMPTS); do
                        ADMIN_LOGIN=$(az sql server ad-admin list --server "$SQL_SERVER_NAME" --resource-group "$RG_NAME" --query "[0].login" -o tsv 2>/dev/null || echo "")
                        if [ -n "$ADMIN_LOGIN" ] && [ "$ADMIN_LOGIN" != "null" ]; then
                          echo "[INFO] Azure AD admin detected: $ADMIN_LOGIN (attempt $i)"; ADMIN_SEEN=1; break
                        fi
                        echo "[INFO] Azure AD admin not yet visible (attempt $i/$ADMIN_CHECK_ATTEMPTS); waiting 10s..."
                        sleep 10
                      done
                      if [ "$ADMIN_SEEN" != "1" ]; then
                        echo "[WARN] Azure AD admin not visible after waiting. User creation may fail; continuing anyway."
                      fi
                      echo "[INFO] Installing sqlcmd tooling..."
                      curl -s https://packages.microsoft.com/keys/microsoft.asc | sudo apt-key add - >/dev/null
                      curl -s https://packages.microsoft.com/config/ubuntu/20.04/prod.list | sudo tee /etc/apt/sources.list.d/msprod.list >/dev/null
                      sudo apt-get update -y >/dev/null
                      sudo apt-get install -y mssql-tools unixodbc-dev >/dev/null
                      if ! timeout 5 bash -c "</dev/tcp/${SQL_SERVER_NAME}.database.windows.net/1433" 2>/dev/null; then echo "[ERROR] Port 1433 unreachable"; exit 1; fi
                      SQL_SCRIPT=$'USE [${DATABASE_NAME}];\nIF NOT EXISTS (SELECT 1 FROM sys.database_principals WHERE name='"'${WEBAPP_NAME}'"') BEGIN PRINT 'Creating user ${WEBAPP_NAME}'; CREATE USER [${WEBAPP_NAME}] FROM EXTERNAL PROVIDER; END;\nDECLARE @roles TABLE(r sysname); INSERT INTO @roles VALUES(\'db_datareader\'),(\'db_datawriter\'),(\'db_ddladmin\');\nDECLARE c CURSOR LOCAL FAST_FORWARD FOR SELECT r FROM @roles; OPEN c; DECLARE @r sysname; FETCH NEXT FROM c INTO @r;\nWHILE @@FETCH_STATUS=0 BEGIN IF IS_ROLEMEMBER(@r,\'${WEBAPP_NAME}\')=1 PRINT @r+\' already assigned\'; ELSE EXEC(\'ALTER ROLE \"' +QUOTENAME(@r)+ '\" ADD MEMBER [${WEBAPP_NAME}]\'); FETCH NEXT FROM c INTO @r; END CLOSE c; DEALLOCATE c;\nSELECT dp.name AS principal, r.name AS role_name FROM sys.database_principals dp JOIN sys.database_role_members rm ON dp.principal_id=rm.member_principal_id JOIN sys.database_principals r ON rm.role_principal_id=r.principal_id WHERE dp.name=\'${WEBAPP_NAME}\';'
                      printf '%s\n' "$SQL_SCRIPT" > setup_managed_identity.sql

                      echo "[INFO] Waiting for successful token-based connectivity..."
                      LOGIN_OK=0
                      for i in $(seq 1 12); do
                        ACCESS_TOKEN=$(az account get-access-token --resource https://database.windows.net/ --query accessToken -o tsv 2>/dev/null || echo "")
                        if [ -z "$ACCESS_TOKEN" ]; then echo "[INFO] (attempt $i) token not acquired, retrying in 10s"; sleep 10; continue; fi
                        export SQLCMDACCESSTOKEN="$ACCESS_TOKEN"
                        if /opt/mssql-tools/bin/sqlcmd -S "$SQL_SERVER_FQDN" -d master -C -l 15 -Q "SELECT 1" >/dev/null 2>&1; then
                          echo "[INFO] Token login succeeded on attempt $i"; LOGIN_OK=1; break
                        else
                          echo "[INFO] Token login failed (attempt $i); waiting 10s..."; sleep 10
                        fi
                      done
                      if [ "$LOGIN_OK" != "1" ]; then
                        echo "[WARN] Could not establish token login after retries. Skipping user creation to avoid hard failure."
                        exit 0
                      fi

                      echo "[INFO] Executing user/role script with retries..."
                      CREATE_OK=0
                      for i in $(seq 1 5); do
                        # Refresh token before each attempt (tokens ~ 1h but safe)
                        ACCESS_TOKEN=$(az account get-access-token --resource https://database.windows.net/ --query accessToken -o tsv 2>/dev/null || echo "")
                        [ -n "$ACCESS_TOKEN" ] && export SQLCMDACCESSTOKEN="$ACCESS_TOKEN"
                        if /opt/mssql-tools/bin/sqlcmd -S "$SQL_SERVER_FQDN" -d "$DATABASE_NAME" -C -l 60 -i setup_managed_identity.sql; then
                          echo "[INFO] User/role script succeeded (attempt $i)"; CREATE_OK=1; break
                        else
                          echo "[WARN] User/role script failed (attempt $i); sleeping 15s before retry"; sleep 15
                        fi
                      done
                      if [ "$CREATE_OK" != "1" ]; then
                        echo "[WARN] Exhausted retries creating/verifying managed identity user. Manual intervention may be required."
                        exit 0
                      fi

                      echo "[INFO] Running identity test query..."
                      echo "SELECT SUSER_SNAME() AS suser, CURRENT_USER AS current_user, DB_NAME() AS dbname;" > test_connection.sql
                      /opt/mssql-tools/bin/sqlcmd -S "$SQL_SERVER_FQDN" -d "$DATABASE_NAME" -C -l 15 -i test_connection.sql || echo "[WARN] Identity test query failed"
                      echo "[INFO] Verifying presence of managed identity user principal..."
                      VERIFY_SQL=$'SET NOCOUNT ON; SELECT name,type_desc,create_date FROM sys.database_principals WHERE name='"'${WEBAPP_NAME}'"';'
                      VERIFY_OUTPUT=$(/opt/mssql-tools/bin/sqlcmd -S "$SQL_SERVER_FQDN" -d "$DATABASE_NAME" -C -l 30 -h -1 -Q "$VERIFY_SQL" 2>/dev/null || echo "")
                      if echo "$VERIFY_OUTPUT" | grep -qi "${WEBAPP_NAME}"; then
                        echo "[INFO] Managed identity user exists in database."
                      else
                        echo "[ERROR] Managed identity user ${WEBAPP_NAME} NOT FOUND after creation attempts."; exit 1
                      fi
                      echo "[INFO] Listing role memberships for managed identity (if any)..."
                      ROLE_SQL=$'SET NOCOUNT ON; SELECT r.name AS role_name FROM sys.database_principals dp JOIN sys.database_role_members rm ON dp.principal_id=rm.member_principal_id JOIN sys.database_principals r ON rm.role_principal_id=r.principal_id WHERE dp.name='"'${WEBAPP_NAME}'"';'
                      /opt/mssql-tools/bin/sqlcmd -S "$SQL_SERVER_FQDN" -d "$DATABASE_NAME" -C -l 30 -Q "$ROLE_SQL" || echo "[WARN] Role listing query failed"
                      echo "[INFO] Managed identity SQL setup complete"

                - task: DotNetCoreCLI@2
                  displayName: "Setup .NET for migrations"
                  inputs:
                    command: "custom"
                    custom: "tool"
                    arguments: "install --global dotnet-ef"

                - task: AzureCLI@2
                  displayName: "Run database migrations"
                  inputs:
                    azureSubscription: "$(AZURE_SERVICE_CONNECTION)"
                    scriptType: "bash"
                    scriptLocation: "inlineScript"
                    inlineScript: |
                      INSTANCE_NUM="$(instanceNum)"
                      RG_NAME="rg-aistock-prod-$(instanceNum)"

                      echo " Checking database migration options..."
                      echo "Resource Group: ${RG_NAME}"

                      # Try to get connection string from Key Vault, but don't fail if access is denied
                      KEY_VAULT_NAME="kv-aistock-prod-$(instanceNum)"
                      echo "Attempting to retrieve connection string from Key Vault: ${KEY_VAULT_NAME}"

                      CONNECTION_STRING=$(az keyvault secret show --vault-name "${KEY_VAULT_NAME}" --name "SqlConnectionString" --query "value" --output tsv 2>/dev/null || echo "")

                      if [ -z "${CONNECTION_STRING}" ]; then
                        echo " Could not retrieve connection string from Key Vault."
                        echo "This is expected for first-time deployments or when pipeline doesn't have Key Vault access."
                        echo ""
                        echo " Database migrations will run automatically on first app startup."
                        echo "The application is configured to:"
                        echo "  1. Use Azure AD managed identity authentication"
                        echo "  2. Run Entity Framework migrations automatically"
                        echo "  3. Create necessary database schema"
                        echo ""
                        echo " Skipping manual migration - letting app handle it during startup"
                      else
                        echo " Retrieved connection string from Key Vault"
                        echo "Connection string type: $(echo "${CONNECTION_STRING}" | grep -o 'Authentication=[^;]*' || echo 'SQL Authentication')"
                        
                        if echo "${CONNECTION_STRING}" | grep -q "Authentication=Active Directory Default"; then
                          echo " Using Azure AD authentication for migrations"
                        else
                          echo " Using SQL authentication for migrations"
                        fi
                        
                        echo "Running database migrations manually..."
                        cd AiStockTradeApp
                        export ConnectionStrings__DefaultConnection="${CONNECTION_STRING}"
                        
                        # Run with verbose output
                        echo "Starting Entity Framework migration..."
                        dotnet ef database update --verbose
                        
                        if [ $? -eq 0 ]; then
                          echo " Database migrations completed successfully"
                        else
                          echo " Migration failed, but this may be handled during app startup"
                        fi
                      fi

                - task: AzureCLI@2
                  displayName: "Update Web App Container"
                  inputs:
                    azureSubscription: "$(AZURE_SERVICE_CONNECTION)"
                    scriptType: "bash"
                    scriptLocation: "inlineScript"
                    inlineScript: |
                      WEBAPP_NAME="app-aistock-prod-$(instanceNum)"
                      RG_NAME="rg-aistock-prod-$(instanceNum)"

                      # Get registry information from DEV resource group (shared registry)
                      DEV_RG_NAME="rg-aistock-dev-$(instanceNum)"
                      REGISTRY_NAME=$(az acr list --resource-group "${DEV_RG_NAME}" --query '[0].name' --output tsv)
                      REGISTRY_USERNAME=$(az acr credential show --name "${REGISTRY_NAME}" --query 'username' --output tsv)
                      REGISTRY_PASSWORD=$(az acr credential show --name "${REGISTRY_NAME}" --query 'passwords[0].value' --output tsv)

                      echo "Container Image: $(containerImage)"
                      echo "Web App Name: ${WEBAPP_NAME}"
                      echo "Prod Resource Group: ${RG_NAME}"
                      echo "Dev Registry Resource Group: ${DEV_RG_NAME}"
                      echo "Shared Registry Name: ${REGISTRY_NAME}"

                      if [ -z "$(containerImage)" ]; then
                        echo "ERROR: Container image is empty!"
                        exit 1
                      fi

                      az webapp config container set \
                        --name "${WEBAPP_NAME}" \
                        --resource-group "${RG_NAME}" \
                        --container-image-name "$(containerImage)" \
                        --container-registry-url "https://${REGISTRY_NAME}.azurecr.io" \
                        --container-registry-user "${REGISTRY_USERNAME}" \
                        --container-registry-password "${REGISTRY_PASSWORD}"

                - task: AzureCLI@2
                  displayName: "Update API Web App Container"
                  inputs:
                    azureSubscription: "$(AZURE_SERVICE_CONNECTION)"
                    scriptType: "bash"
                    scriptLocation: "inlineScript"
                    inlineScript: |
                      WEBAPP_NAME="api-aistock-prod-$(instanceNum)"
                      RG_NAME="rg-aistock-prod-$(instanceNum)"

                      # Get registry information from DEV resource group (shared registry)
                      DEV_RG_NAME="rg-aistock-dev-$(instanceNum)"
                      REGISTRY_NAME=$(az acr list --resource-group "${DEV_RG_NAME}" --query '[0].name' --output tsv)
                      REGISTRY_USERNAME=$(az acr credential show --name "${REGISTRY_NAME}" --query 'username' --output tsv)
                      REGISTRY_PASSWORD=$(az acr credential show --name "${REGISTRY_NAME}" --query 'passwords[0].value' --output tsv)

                      echo "API Container Image: $(containerImageApi)"
                      echo "API Web App Name: ${WEBAPP_NAME}"
                      echo "Prod Resource Group: ${RG_NAME}"
                      echo "Dev Registry Resource Group: ${DEV_RG_NAME}"
                      echo "Shared Registry Name: ${REGISTRY_NAME}"

                      if [ -z "$(containerImageApi)" ]; then echo "ERROR: API container image is empty!"; exit 1; fi

                      az webapp config container set \
                        --name "${WEBAPP_NAME}" \
                        --resource-group "${RG_NAME}" \
                        --container-image-name "$(containerImageApi)" \
                        --container-registry-url "https://${REGISTRY_NAME}.azurecr.io" \
                        --container-registry-user "${REGISTRY_USERNAME}" \
                        --container-registry-password "${REGISTRY_PASSWORD}"

                - task: AzureCLI@2
                  displayName: "Run Health Check"
                  inputs:
                    azureSubscription: "$(AZURE_SERVICE_CONNECTION)"
                    scriptType: "bash"
                    scriptLocation: "inlineScript"
                    inlineScript: |
                      echo "[DIAG] Dumping resolved connection string authentication mode before health checks (shared script)..."
                      WEBAPP_NAME="app-aistock-prod-$(instanceNum)"
                      RG_NAME="rg-aistock-prod-$(instanceNum)"
                      bash ./scripts/sql-conn-auth-dump.sh "$RG_NAME" "$WEBAPP_NAME" || echo "[DIAG] Script execution failed (non-fatal)"
                      WEBAPP_NAME="app-aistock-prod-$(instanceNum)"
                      HEALTH_URL="https://${WEBAPP_NAME}.azurewebsites.net/health"
                      BASE_URL="https://${WEBAPP_NAME}.azurewebsites.net"

                      echo " Starting comprehensive health check..."
                      echo "Base URL: ${BASE_URL}"
                      echo "Health URL: ${HEALTH_URL}"

                      # Wait for initial deployment
                      echo "Waiting for deployment to be ready..."
                      sleep 60

                      # Check if the site is accessible at all
                      echo "Testing basic site accessibility..."
                      for i in {1..5}; do
                        if curl -f -s "${BASE_URL}" >/dev/null 2>&1; then
                          echo " Site is accessible (attempt $i)"
                          break
                        else
                          echo " Site not ready yet (attempt $i/5)..."
                          sleep 30
                        fi
                      done

                      # Check health endpoint specifically
                      echo "Testing health endpoint..."
                      for i in {1..10}; do
                        echo "Health check attempt $i/10..."
                        
                        # Get detailed response
                        HTTP_CODE=$(curl -s -o /tmp/health_response.txt -w "%{http_code}" "${HEALTH_URL}")
                        RESPONSE_BODY=$(cat /tmp/health_response.txt 2>/dev/null || echo "No response body")
                        
                        echo "HTTP Status: ${HTTP_CODE}"
                        echo "Response: ${RESPONSE_BODY}"
                        
                        if [ "${HTTP_CODE}" = "200" ]; then
                          echo " Health check passed!"
                          echo "Deployment successful and application is healthy."
                          exit 0
                        elif [ "${HTTP_CODE}" = "503" ] || [ "${HTTP_CODE}" = "500" ]; then
                          echo " Application error detected (HTTP ${HTTP_CODE})"
                          echo "This might be a database connectivity issue."
                          
                          # Try to get more detailed logs
                          echo "Attempting to get application logs..."
                          az webapp log tail --name "${WEBAPP_NAME}" --resource-group "rg-aistock-prod-$(instanceNum)" --timeout 30 || echo "Could not retrieve logs"
                          
                          if [ $i -eq 10 ]; then
                            echo " Health check failed after 10 attempts"
                            echo "Last response (HTTP ${HTTP_CODE}): ${RESPONSE_BODY}"
                            echo ""
                            echo " Troubleshooting steps:"
                            echo "1. Check Azure portal for app service logs"
                            echo "2. Verify managed identity SQL user was created"
                            echo "3. Check Key Vault access permissions"
                            echo "4. Verify SQL Server firewall allows Azure services"
                            exit 1
                          fi
                        else
                          echo " Unexpected response (HTTP ${HTTP_CODE}), retrying..."
                        fi
                        
                        sleep 30
                      done

                      echo " Health check failed - no successful response received"
                      exit 1

                - task: Bash@3
                  displayName: "Run API Health Check"
                  inputs:
                    targetType: "inline"
                    script: |
                      echo "[DIAG] Dumping resolved connection string authentication mode before API health checks (shared script)..."
                      WEBAPP_NAME="api-aistock-prod-$(instanceNum)"
                      RG_NAME="rg-aistock-prod-$(instanceNum)"
                      bash ./scripts/sql-conn-auth-dump.sh "$RG_NAME" "$WEBAPP_NAME" || echo "[DIAG] Script execution failed (non-fatal)"
                      HEALTH_URL="https://${WEBAPP_NAME}.azurewebsites.net/health"
                      BASE_URL="https://${WEBAPP_NAME}.azurewebsites.net"
                      echo " Starting API health check..."
                      echo "Base URL: ${BASE_URL}"
                      echo "Health URL: ${HEALTH_URL}"
                      sleep 60
                      for i in {1..10}; do
                        echo "API Health check attempt $i/10..."
                        HTTP_CODE=$(curl -s -o /tmp/health_api_response.txt -w "%{http_code}" "${HEALTH_URL}")
                        RESPONSE_BODY=$(cat /tmp/health_api_response.txt 2>/dev/null || echo "No response body")
                        echo "HTTP Status: ${HTTP_CODE}"; echo "Response: ${RESPONSE_BODY}"
                        if [ "${HTTP_CODE}" = "200" ]; then
                          echo " API Health check passed!"; exit 0
                        fi
                        sleep 30
                      done
                      echo " API Health check failed"; exit 1

  - stage: SecurityScan
    displayName: "Security Scan"
    dependsOn: Build
    condition: |
      and(
        succeeded(),
        eq(variables['Build.Reason'], 'PullRequest')
      )
    jobs:
      - job: SecurityScanJob
        displayName: "Security Scan"
        steps:
          - checkout: self
            displayName: "Checkout code"
            fetchDepth: 0
            persistCredentials: true
            clean: true

          - task: DownloadPipelineArtifact@2
            displayName: "Download build outputs"
            inputs:
              artifactName: "build-outputs"
              downloadPath: "$(Pipeline.Workspace)/build-outputs"

          - task: Bash@3
            displayName: "Load container image from artifact"
            inputs:
              targetType: "inline"
              script: |
                if [ -f "$(Pipeline.Workspace)/build-outputs/container-image.txt" ]; then
                  CONTAINER_IMAGE=$(cat $(Pipeline.Workspace)/build-outputs/container-image.txt)
                  echo "Container image from artifact: '${CONTAINER_IMAGE}'"
                  echo "##vso[task.setvariable variable=containerImage]${CONTAINER_IMAGE}"
                else
                  echo "ERROR: container-image.txt not found in artifacts!"
                  exit 1
                fi

          # Note: For Trivy scanning in Azure DevOps, you would need to install Trivy
          # or use a marketplace extension. This is a placeholder for the security scan.
          - task: Bash@3
            displayName: "Run Security Scan (Placeholder)"
            inputs:
              targetType: "inline"
              script: |
                echo "=== SECURITY SCAN ==="
                echo "Container image to scan: $(containerImage)"
                echo "In a real implementation, this would run Trivy or similar security scanner"
                echo "Results would be published to Azure DevOps security dashboard"
