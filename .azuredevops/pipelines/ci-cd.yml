# Azure DevOps CI/CD Pipeline
# Converted from GitHub Actions workflow

# trigger:
#   branches:
#     include:
#       - main
#       - develop
#   paths:
#     exclude:
#       - "**.md"
#       - "**/README.md"
#       - "docs/**"
#       - "*.txt"
#       - ".gitignore"
#       - ".vscode/**"
#       - ".vs/**"
#       #- '.azuredevops/**'
#       - ".github/**"
#       - "AGENTS.md"
#       - "LICENSE"

# pr:
#   branches:
#     include:
#       - main
#   paths:
#     exclude:
#       - "**.md"
#       - "**/README.md"
#       - "docs/**"
#       - "*.txt"
#       - ".gitignore"
#       - ".vscode/**"
#       - ".vs/**"
#       #- '.azuredevops/**'
#       - ".github/**"
#       - "AGENTS.md"
#       - "LICENSE"
trigger: none  # CI temporarily disabled

pr: none  # PR validation temporarily disabled

parameters:
  - name: environment
    displayName: "Environment to deploy to"
    type: string
    default: "dev"
    values:
      - dev
      - prod

  - name: instanceNumber
    displayName: "Instance number for resource differentiation"
    type: string
    default: "003"

variables:
  - group: "ai-stock-trade-app" # Variable group for shared variables
  - name: AZURE_SERVICE_CONNECTION
    value: "svc_CSA_sub" # Replace with your Azure service connection name
  - name: AZURE_SUBSCRIPTION_ID
    value: "64c3d212-40ed-4c6d-a825-6adfbdf25dad" # Replace with your Azure subscription ID
  - name: AZURE_WEBAPP_PACKAGE_PATH
    value: "."
  - name: DOTNET_VERSION
    value: "9.0.x"
  - name: vmImageName
    value: "ubuntu-latest"

pool:
  vmImage: $(vmImageName)

stages:
  - stage: Test
    displayName: "Test Application"
    jobs:
      - job: TestJob
        displayName: "Test Application"
        services:
          sqlserver: 
            image: mcr.microsoft.com/mssql/server:2022-latest
            env:
              SA_PASSWORD: "YourStrong@Passw0rd"
              ACCEPT_EULA: "Y"
            ports:
              - 1433:1433
        steps:
          - checkout: self
            displayName: "Checkout code"

          - task: UseDotNet@2
            displayName: "Setup .NET"
            inputs:
              packageType: "sdk"
              version: $(DOTNET_VERSION)

          - task: DotNetCoreCLI@2
            displayName: "Install Entity Framework tools"
            inputs:
              command: "custom"
              custom: "tool"
              arguments: "install --global dotnet-ef"

          - task: DotNetCoreCLI@2
            displayName: "Restore dependencies"
            inputs:
              command: "restore"
              projects: "**/*.csproj"

          - task: DotNetCoreCLI@2
            displayName: "Build application"
            inputs:
              command: "build"
              projects: "**/*.csproj"
              arguments: "--no-restore --configuration Release"

          - script: |
              # Wait for SQL Server to be ready
              echo "Waiting for SQL Server to start..."
              for i in {1..30}; do
                if sqlcmd -S localhost -U sa -P "YourStrong@Passw0rd" -Q "SELECT 1" >/dev/null 2>&1; then
                  echo "SQL Server is ready"
                  break
                fi
                echo "Waiting for SQL Server... ($i/30)"
                sleep 2
              done
            displayName: "Wait for SQL Server to start"

          - task: DotNetCoreCLI@2
            displayName: "Run database migrations for testing"
            inputs:
              command: "custom"
              custom: "ef"
              arguments: "database update --project ai-stock-trade-app/ai-stock-trade-app.csproj"
            env:
              ASPNETCORE_ENVIRONMENT: "Testing"
              ConnectionStrings__DefaultConnection: "Server=localhost;Database=StockTrackerTest;User Id=sa;Password=YourStrong@Passw0rd;TrustServerCertificate=true;Encrypt=false"

          - task: DotNetCoreCLI@2
            displayName: "Run tests"
            inputs:
              command: "test"
              projects: "**/*.csproj"
              arguments: '--no-build --configuration Release --verbosity normal --filter "FullyQualifiedName!~UITests"'
            env:
              ASPNETCORE_ENVIRONMENT: "Testing"
              ConnectionStrings__DefaultConnection: "Server=localhost;Database=StockTrackerTest;User Id=sa;Password=YourStrong@Passw0rd;TrustServerCertificate=true;Encrypt=false"

      - job: UITestJob
        displayName: "UI Tests with Playwright"
        dependsOn: TestJob
        condition: succeeded()
        services:
          sqlserver: 
            image: mcr.microsoft.com/mssql/server:2022-latest
            env:
              SA_PASSWORD: "YourStrong@Passw0rd"
              ACCEPT_EULA: "Y"
            ports:
              - 1433:1433
        steps:
          - checkout: self
            displayName: "Checkout code"

          - task: UseDotNet@2
            displayName: "Setup .NET"
            inputs:
              packageType: "sdk"
              version: $(DOTNET_VERSION)

          - task: DotNetCoreCLI@2
            displayName: "Restore dependencies"
            inputs:
              command: "restore"
              projects: "**/*.csproj"

          - task: DotNetCoreCLI@2
            displayName: "Build application"
            inputs:
              command: "build"
              projects: "**/*.csproj"
              arguments: "--no-restore --configuration Release"

          - task: DotNetCoreCLI@2
            displayName: "Install Entity Framework tools"
            inputs:
              command: "custom"
              custom: "tool"
              arguments: "install --global dotnet-ef"

          - script: |
              # Wait for SQL Server to be ready
              echo "Waiting for SQL Server to start..."
              for i in {1..30}; do
                if sqlcmd -S localhost -U sa -P "YourStrong@Passw0rd" -Q "SELECT 1" >/dev/null 2>&1; then
                  echo "SQL Server is ready"
                  break
                fi
                echo "Waiting for SQL Server... ($i/30)"
                sleep 2
              done
            displayName: "Wait for SQL Server to start"

          - task: DotNetCoreCLI@2
            displayName: "Run database migrations for UI testing"
            inputs:
              command: "custom"
              custom: "ef"
              arguments: "database update --project ai-stock-trade-app/ai-stock-trade-app.csproj"
            env:
              ASPNETCORE_ENVIRONMENT: "Development"
              ConnectionStrings__DefaultConnection: "Server=localhost;Database=StockTrackerTestUI;User Id=sa;Password=YourStrong@Passw0rd;TrustServerCertificate=true;Encrypt=false"

          - task: NodeTool@0
            displayName: "Setup Node.js"
            inputs:
              versionSpec: "18.x"

          - script: |
              echo "Installing Playwright via npm (JS driver used by .NET binding)..."
              cd ai-stock-trade-app.UITests
              npm ci || npm install
              npx playwright install --with-deps chromium
              npx playwright --version
              echo "Listing browser cache..."
              ls -R ~/.cache/ms-playwright || true
            displayName: "Install Playwright browsers"

          - script: |
              # Start application in background
              echo "Starting application in background..."
              cd ai-stock-trade-app
              nohup dotnet run --no-build --configuration Release --no-launch-profile > app.log 2>&1 &
              APP_PID=$!
              echo "Started application with PID: $APP_PID"
              echo $APP_PID > app.pid
              
              # Wait for application to be ready
              echo "Waiting for application to start..."
              timeout=120
              while [ $timeout -gt 0 ]; do
                if curl -f http://localhost:5000 >/dev/null 2>&1; then
                  echo "Application is ready!"
                  break
                fi
                echo "Waiting for application... ($timeout seconds remaining)"
                sleep 2
                timeout=$((timeout-2))
              done
              
              if [ $timeout -le 0 ]; then
                echo "Application failed to start within timeout"
                echo "Application logs:"
                cat app.log
                exit 1
              fi
            displayName: "Start application in background"
            env:
              ASPNETCORE_ENVIRONMENT: "Development"
              ASPNETCORE_URLS: "http://localhost:5000"
              ConnectionStrings__DefaultConnection: "Server=localhost;Database=StockTrackerTestUI;User Id=sa;Password=YourStrong@Passw0rd;TrustServerCertificate=true;Encrypt=false"

          - script: |
              echo "Waiting for application to start..."
              timeout=60
              while [ $timeout -gt 0 ]; do
                if curl -f http://localhost:5000 >/dev/null 2>&1; then
                  echo "Application is ready!"
                  break
                fi
                echo "Waiting for application... ($timeout seconds remaining)"
                sleep 2
                timeout=$((timeout-2))
              done
              
              if [ $timeout -le 0 ]; then
                echo "Application failed to start within timeout"
                exit 1
              fi
            displayName: "Wait for application to be ready"

          - script: |
              echo "=== Pre-test debugging ==="
              echo "Checking if UITests project built correctly..."
              ls -la ai-stock-trade-app.UITests/bin/Release/net9.0/ || echo "Build output directory not found"
              
              echo "Checking for required assemblies..."
              ls -la ai-stock-trade-app.UITests/bin/Release/net9.0/*Playwright* || echo "Playwright assemblies not found"
              ls -la ai-stock-trade-app.UITests/bin/Release/net9.0/*NUnit* || echo "NUnit assemblies not found"
              
              echo "Checking test.runsettings file..."
              cat test.runsettings || echo "test.runsettings not found"
              
              echo "Environment variables:"
              echo "PLAYWRIGHT_BASE_URL: $PLAYWRIGHT_BASE_URL"
              echo "ASPNETCORE_ENVIRONMENT: $ASPNETCORE_ENVIRONMENT"
              echo "DISPLAY: $DISPLAY"
              echo "CI: $CI"
              echo "AZURE_PIPELINES: $AZURE_PIPELINES"
              
              echo "Testing application accessibility..."
              curl -v http://localhost:5000 || echo "Application not responding"
              
              echo "Skipping X11 display probe (not required for headless Chromium)"
              
              echo "Checking Playwright installation (npx)..."
              (cd ai-stock-trade-app.UITests && npx playwright --version) || echo "Playwright CLI not available"
              
              echo "Checking if Playwright browsers are installed..."
              ls -la /ms/playwright/ || echo "Playwright browser cache not found"
              find ~/.cache/ms-playwright -name "chromium*" -type d | head -5 || echo "Chromium browser not found"
              
              echo "Testing simple browser launch..."
              echo "Testing simple browser launch via dotnet playwright (dry run using codegen list)..."
              (cd ai-stock-trade-app.UITests && npx playwright install chromium) || true
              # Quick launch validation using a minimal script
                echo "Installing dotnet-script for inline launch probe..."
                dotnet tool install --global dotnet-script || true
                export PATH="$PATH:$HOME/.dotnet/tools"
              cat > mini-browser-test.csx <<'CSX'
              #r "nuget: Microsoft.Playwright"
              using Microsoft.Playwright;
              var pw = await Playwright.CreateAsync();
              var browser = await pw.Chromium.LaunchAsync(new() { Headless = true, Args = new[]{"--no-sandbox","--disable-setuid-sandbox","--disable-dev-shm-usage"} });
              var ctx = await browser.NewContextAsync();
              var page = await ctx.NewPageAsync();
              await page.GotoAsync("https://example.com");
              Console.WriteLine("Browser navigation OK: " + await page.TitleAsync());
              await browser.CloseAsync();
              CSX
              dotnet script mini-browser-test.csx || echo "Mini browser test failed (will let tests attempt)."
            displayName: "Pre-test debugging"
            env:
              ASPNETCORE_ENVIRONMENT: "Development"
              PLAYWRIGHT_BASE_URL: "http://localhost:5000"
              DISPLAY: ":99.0"
              CI: "true"
              AZURE_PIPELINES: "true"

          - script: |
              echo "Listing all tests in UITests project..."
              dotnet test ai-stock-trade-app.UITests --list-tests --verbosity normal
            displayName: "List UI Tests to be executed"

          - task: DotNetCoreCLI@2
            displayName: "Run Playwright UI Tests"
            inputs:
              command: "test"
              projects: "ai-stock-trade-app.UITests/ai-stock-trade-app.UITests.csproj"
              arguments: '--no-build --configuration Release --verbosity diagnostic --logger "trx;LogFileName=ui-test-results.trx" --settings ./test.runsettings --logger "console;verbosity=diagnostic"'
            env:
              ASPNETCORE_ENVIRONMENT: "Development"
              PLAYWRIGHT_BASE_URL: "http://localhost:5000"
              ConnectionStrings__DefaultConnection: "Server=localhost;Database=StockTrackerTestUI;User Id=sa;Password=YourStrong@Passw0rd;TrustServerCertificate=true;Encrypt=false"
              DISPLAY: ":99.0"
              PLAYWRIGHT_LAUNCH_OPTIONS: '{"headless":true,"args":["--no-sandbox","--disable-setuid-sandbox","--disable-dev-shm-usage","--disable-gpu","--no-first-run","--no-default-browser-check","--disable-background-timer-throttling","--disable-backgrounding-occluded-windows","--disable-renderer-backgrounding"]}'
              PWDEBUG: "0"
              DEBUG: "pw:api"
              CI: "true"
              AZURE_PIPELINES: "true"
              NODE_PATH: "$(System.DefaultWorkingDirectory)/ai-stock-trade-app.UITests/node_modules"
            condition: succeededOrFailed()
            timeoutInMinutes: 25

          - task: PublishTestResults@2
            displayName: "Publish UI Test Results"
            inputs:
              testResultsFormat: "VSTest"
              testResultsFiles: "**/*ui-test-results.trx"
              testRunTitle: "Playwright UI Tests"
              mergeTestResults: true
            condition: succeededOrFailed()

          - script: |
              echo "Capturing application logs for debugging..."
              if [ -f "ai-stock-trade-app/app.log" ]; then
                echo "=== Application Logs ==="
                cat ai-stock-trade-app/app.log
                echo "=== End Application Logs ==="
              else
                echo "No application log file found"
              fi
            displayName: "Debug: Show application logs"
            condition: failed()

          - script: |
              echo "Stopping application..."
              if [ -f "ai-stock-trade-app/app.pid" ]; then
                APP_PID=$(cat ai-stock-trade-app/app.pid)
                echo "Stopping application with PID: $APP_PID"
                kill $APP_PID || true
                sleep 5
              fi
              # Cleanup any remaining dotnet processes
              pkill -f "dotnet.*ai-stock-trade-app" || true
            displayName: "Stop application"
            condition: always()

          - script: |
              echo "Cleaning up SQL Server container..."
              docker stop sqlserver-ui-test || true
              docker rm sqlserver-ui-test || true
            displayName: "Cleanup SQL Server"
            condition: always()

  - stage: Build
    displayName: "Build and Push Container"
    dependsOn: Test
    condition: succeeded()
    jobs:
      - job: BuildJob
        displayName: "Build and Push Container"
        variables:
          - name: containerImage
            value: ""
          - name: registryName
            value: ""
          - name: resourceGroup
            value: ""
          - name: instanceNum
            value: ""

        steps:
          - checkout: self
            displayName: "Checkout code"

          - task: AzureCLI@2
            displayName: "Get Container Registry Information"
            inputs:
              azureSubscription: "$(AZURE_SERVICE_CONNECTION)"
              scriptType: "bash"
              scriptLocation: "inlineScript"
              inlineScript: |
                # Always use dev environment container registry (shared across all environments)
                if [[ "$(Build.Reason)" == "Manual" ]]; then
                  INSTANCE_NUM="${{ parameters.instanceNumber }}"
                  echo "Manual trigger detected - Instance: ${INSTANCE_NUM}"
                else
                  INSTANCE_NUM="003"
                  echo "Branch push detected - Using default instance: ${INSTANCE_NUM}"
                fi

                # Always target dev resource group for container registry
                ENV="dev"
                RG_NAME="rg-aistock-${ENV}-${INSTANCE_NUM}"

                echo "=== BUILD ENVIRONMENT INFO ==="
                echo "Container Registry Environment: ${ENV} (shared registry)"
                echo "Instance Number: ${INSTANCE_NUM}"
                echo "Registry Resource Group: ${RG_NAME}"
                echo "Build Source Branch: $(Build.SourceBranch)"
                echo "Build Reason: $(Build.Reason)"

                # Get container registry name from dev resource group
                REGISTRY_NAME=$(az acr list --resource-group "${RG_NAME}" --query '[0].name' --output tsv)

                if [ -z "${REGISTRY_NAME}" ] || [ "${REGISTRY_NAME}" == "null" ]; then
                  echo "ERROR: No container registry found in resource group ${RG_NAME}"
                  echo "Available resource groups:"
                  az group list --query '[].name' --output table
                  echo "This might mean the dev infrastructure hasn't been deployed yet for instance ${INSTANCE_NUM}"
                  echo "Please deploy dev environment first to create the shared container registry."
                  exit 1
                fi

                echo "Found shared registry: ${REGISTRY_NAME}"
                echo "##vso[task.setvariable variable=registryName]${REGISTRY_NAME}"
                echo "##vso[task.setvariable variable=resourceGroup]${RG_NAME}"
                echo "##vso[task.setvariable variable=instanceNum]${INSTANCE_NUM}"

          - task: AzureCLI@2
            displayName: "Get Container Registry Credentials"
            inputs:
              azureSubscription: "$(AZURE_SERVICE_CONNECTION)"
              scriptType: "bash"
              scriptLocation: "inlineScript"
              inlineScript: |
                # Get admin credentials
                REGISTRY_USERNAME=$(az acr credential show --name "$(registryName)" --query 'username' --output tsv)
                REGISTRY_PASSWORD=$(az acr credential show --name "$(registryName)" --query 'passwords[0].value' --output tsv)

                echo "Registry Username: ${REGISTRY_USERNAME}"
                echo "Password length: ${#REGISTRY_PASSWORD}"

                echo "##vso[task.setvariable variable=registryUsername;issecret=true]${REGISTRY_USERNAME}"
                echo "##vso[task.setvariable variable=registryPassword;issecret=true]${REGISTRY_PASSWORD}"

          - task: Bash@3
            displayName: "Debug Registry Information"
            inputs:
              targetType: "inline"
              script: |
                echo "=== REGISTRY DEBUG INFO ==="
                echo "Instance Number: $(instanceNum)"
                echo "Registry name: $(registryName)"
                echo "Resource group: $(resourceGroup)"
                echo "Registry URL: $(registryName).azurecr.io"
                echo "=== TRIGGER INFO ==="
                echo "Build Source Branch: $(Build.SourceBranch)"
                echo "Build Reason: $(Build.Reason)"

          - task: AzureCLI@2
            displayName: "Login to Azure Container Registry"
            inputs:
              azureSubscription: "$(AZURE_SERVICE_CONNECTION)"
              scriptType: "bash"
              scriptLocation: "inlineScript"
              inlineScript: |
                echo "Logging in to Azure Container Registry: $(registryName).azurecr.io"
                az acr login --name "$(registryName)"

          - task: Bash@3
            displayName: "Generate Container Tags"
            inputs:
              targetType: "inline"
              script: |
                # Generate tags similar to docker/metadata-action
                REGISTRY_URL="$(registryName).azurecr.io"
                IMAGE_NAME="${REGISTRY_URL}/ai-stock-trade-app"

                # Branch-based tag
                BRANCH_NAME=$(echo "$(Build.SourceBranchName)" | sed 's/[^a-zA-Z0-9._-]/-/g')
                BRANCH_TAG="${IMAGE_NAME}:${BRANCH_NAME}"

                # SHA-based tag
                SHORT_SHA=$(echo "$(Build.SourceVersion)" | cut -c1-7)
                SHA_TAG="${IMAGE_NAME}:sha-${SHORT_SHA}"

                # Latest tag for main/master branch
                if [[ "$(Build.SourceBranchName)" == "main" || "$(Build.SourceBranchName)" == "master" ]]; then
                  LATEST_TAG="${IMAGE_NAME}:latest"
                  TAGS="${BRANCH_TAG},${SHA_TAG},${LATEST_TAG}"
                else
                  TAGS="${BRANCH_TAG},${SHA_TAG}"
                fi

                echo "Generated tags: ${TAGS}"
                echo "##vso[task.setvariable variable=containerTags]${TAGS}"
                echo "##vso[task.setvariable variable=deployTag]${SHA_TAG}"

          - task: AzureCLI@2
            displayName: "Build and push Docker image"
            inputs:
              azureSubscription: "$(AZURE_SERVICE_CONNECTION)"
              scriptType: "bash"
              scriptLocation: "inlineScript"
              inlineScript: |
                echo "=== BUILDING AND PUSHING CONTAINER IMAGE ==="

                # Parse container tags into individual tags
                IFS=',' read -ra TAG_ARRAY <<< "$(containerTags)"

                # Build the image first
                echo "Building Docker image..."
                docker build -t temp-build-image ./ai-stock-trade-app

                # Tag and push each tag
                for tag in "${TAG_ARRAY[@]}"; do
                  # Remove any leading/trailing whitespace
                  clean_tag=$(echo "$tag" | xargs)
                  echo "Tagging and pushing: $clean_tag"
                  
                  # Tag the image
                  docker tag temp-build-image "$clean_tag"
                  
                  # Push using az acr
                  az acr repository show --name "$(registryName)" --repository ai-stock-trade-app || echo "Repository doesn't exist yet, will be created on first push"
                  docker push "$clean_tag"
                done

                echo "All tags pushed successfully"
                echo "Deploy tag will be: $(deployTag)"

          - task: Bash@3
            displayName: "Extract and set container image for deployment"
            inputs:
              targetType: "inline"
              script: |
                set -e  # Exit on any error
                echo "=== SETTING DEPLOYMENT IMAGE ==="

                DEPLOY_IMAGE="$(deployTag)"
                echo "Final deployment image: '${DEPLOY_IMAGE}'"

                # Check if DEPLOY_IMAGE is empty
                if [ -z "${DEPLOY_IMAGE}" ]; then
                  echo "ERROR: DEPLOY_IMAGE is empty after processing!"
                  exit 1
                fi

                # Write to artifact file for reliable transfer
                echo "=== CREATING ARTIFACT ==="
                mkdir -p $(Pipeline.Workspace)/build-outputs
                echo "${DEPLOY_IMAGE}" > $(Pipeline.Workspace)/build-outputs/container-image.txt
                echo "hello-from-build-stage" > $(Pipeline.Workspace)/build-outputs/test-output.txt

                echo "Artifact files created:"
                ls -la $(Pipeline.Workspace)/build-outputs/
                echo "Container image file contents:"
                cat $(Pipeline.Workspace)/build-outputs/container-image.txt

                echo "##vso[task.setvariable variable=containerImage;isOutput=true]${DEPLOY_IMAGE}"

          - task: PublishPipelineArtifact@1
            displayName: "Upload build outputs as artifact"
            inputs:
              targetPath: "$(Pipeline.Workspace)/build-outputs"
              artifactName: "build-outputs"

  - stage: DeployDev
    displayName: "Deploy to Development"
    dependsOn: Build
    condition: |
      and(
        succeeded(),
        or(
          eq(variables['Build.SourceBranch'], 'refs/heads/develop'),
          and(
            eq(variables['Build.Reason'], 'Manual'),
            eq('${{ parameters.environment }}', 'dev')
          )
        )
      )
    jobs:
      - deployment: DeployDevJob
        displayName: "Deploy to Development"
        environment: ${{ format('development-{0}', parameters.instanceNumber) }}
        variables:
          - name: instanceNum
            value: ${{ format('{0}', parameters.instanceNumber) }}
        strategy:
          runOnce:
            deploy:
              steps:
                - checkout: self
                  displayName: "Checkout code"

                - task: DownloadPipelineArtifact@2
                  displayName: "Download build outputs"
                  inputs:
                    artifactName: "build-outputs"
                    downloadPath: "$(Pipeline.Workspace)/build-outputs"

                - task: Bash@3
                  displayName: "Load container image from artifact"
                  inputs:
                    targetType: "inline"
                    script: |
                      echo "=== LOADING CONTAINER IMAGE FROM ARTIFACT ==="
                      if [ -f "$(Pipeline.Workspace)/build-outputs/container-image.txt" ]; then
                        CONTAINER_IMAGE=$(cat $(Pipeline.Workspace)/build-outputs/container-image.txt)
                        echo "Container image from artifact: '${CONTAINER_IMAGE}'"
                        echo "##vso[task.setvariable variable=containerImage]${CONTAINER_IMAGE}"
                      else
                        echo "ERROR: container-image.txt not found in artifacts!"
                        ls -la $(Pipeline.Workspace)/build-outputs/
                        exit 1
                      fi

                - task: AzureResourceManagerTemplateDeployment@3
                  displayName: "Deploy Bicep template"
                  inputs:
                    deploymentScope: "Resource Group"
                    azureResourceManagerConnection: "$(AZURE_SERVICE_CONNECTION)"
                    subscriptionId: "$(AZURE_SUBSCRIPTION_ID)"
                    action: "Create Or Update Resource Group"
                    resourceGroupName: "rg-aistock-dev-$(instanceNum)"
                    location: "Canada Central"
                    templateLocation: "Linked artifact"
                    csmFile: "./ai-stock-trade-app/infrastructure/main.bicep"
                    csmParametersFile: "./ai-stock-trade-app/infrastructure/parameters.dev.json"
                    overrideParameters: "-instanceNumber $(instanceNum) -containerImage $(containerImage) -alphaVantageApiKey $(ALPHA_VANTAGE_API_KEY) -twelveDataApiKey $(TWELVE_DATA_API_KEY) -sqlAdminPassword $(SQL_ADMIN_PASSWORD)"
                    deploymentMode: "Incremental"

                - task: AzureCLI@2
                  displayName: "Update Web App Container"
                  inputs:
                    azureSubscription: "$(AZURE_SERVICE_CONNECTION)"
                    scriptType: "bash"
                    scriptLocation: "inlineScript"
                    inlineScript: |
                      WEBAPP_NAME="app-aistock-dev-$(instanceNum)"
                      RG_NAME="rg-aistock-dev-$(instanceNum)"

                      # Get registry information from the same resource group
                      REGISTRY_NAME=$(az acr list --resource-group "${RG_NAME}" --query '[0].name' --output tsv)
                      REGISTRY_USERNAME=$(az acr credential show --name "${REGISTRY_NAME}" --query 'username' --output tsv)
                      REGISTRY_PASSWORD=$(az acr credential show --name "${REGISTRY_NAME}" --query 'passwords[0].value' --output tsv)

                      echo "Container Image: $(containerImage)"
                      echo "Web App Name: ${WEBAPP_NAME}"
                      echo "Resource Group: ${RG_NAME}"
                      echo "Registry Name: ${REGISTRY_NAME}"

                      if [ -z "$(containerImage)" ]; then
                        echo "ERROR: Container image is empty!"
                        exit 1
                      fi

                      az webapp config container set \
                        --name "${WEBAPP_NAME}" \
                        --resource-group "${RG_NAME}" \
                        --container-image-name "$(containerImage)" \
                        --container-registry-url "https://${REGISTRY_NAME}.azurecr.io" \
                        --container-registry-user "${REGISTRY_USERNAME}" \
                        --container-registry-password "${REGISTRY_PASSWORD}"

                - task: Bash@3
                  displayName: "Run Health Check"
                  inputs:
                    targetType: "inline"
                    script: |
                      WEBAPP_NAME="app-aistock-dev-$(instanceNum)"
                      HEALTH_URL="https://${WEBAPP_NAME}.azurewebsites.net/health"
                      echo "Waiting for deployment to be ready..."
                      echo "Health check URL: ${HEALTH_URL}"
                      sleep 30
                      curl -f "${HEALTH_URL}" || exit 1
                      echo "Health check passed!"

  - stage: DeployProd
    displayName: "Deploy to Production"
    dependsOn:
      - Build
      - DeployDev
    condition: |
      and(
        succeeded(),
        in(dependencies.Build.result, 'Succeeded'),
        in(dependencies.DeployDev.result, 'Succeeded', 'Skipped'),
        or(
          eq(variables['Build.SourceBranch'], 'refs/heads/main'),
          and(
            eq(variables['Build.Reason'], 'Manual'),
            eq('${{ parameters.environment }}', 'prod')
          )
        )
      )
    jobs:
      - deployment: DeployProdJob
        displayName: "Deploy to Production"
        environment: ${{ format('production-{0}', parameters.instanceNumber) }}
        variables:
          - name: instanceNum
            value: ${{ format('{0}', parameters.instanceNumber) }}
        strategy:
          runOnce:
            deploy:
              steps:
                - checkout: self
                  displayName: "Checkout code"

                - task: DownloadPipelineArtifact@2
                  displayName: "Download build outputs"
                  inputs:
                    artifactName: "build-outputs"
                    downloadPath: "$(Pipeline.Workspace)/build-outputs"

                - task: Bash@3
                  displayName: "Load container image from artifact"
                  inputs:
                    targetType: "inline"
                    script: |
                      echo "=== LOADING CONTAINER IMAGE FROM ARTIFACT ==="
                      if [ -f "$(Pipeline.Workspace)/build-outputs/container-image.txt" ]; then
                        CONTAINER_IMAGE=$(cat $(Pipeline.Workspace)/build-outputs/container-image.txt)
                        echo "Container image from artifact: '${CONTAINER_IMAGE}'"
                        echo "##vso[task.setvariable variable=containerImage]${CONTAINER_IMAGE}"
                      else
                        echo "ERROR: container-image.txt not found in artifacts!"
                        ls -la $(Pipeline.Workspace)/build-outputs/
                        exit 1
                      fi

                - task: Bash@3
                  displayName: "Debug Variables"
                  inputs:
                    targetType: "inline"
                    script: |
                      echo "=== DEPLOYMENT DEBUG INFO ==="
                      echo "Stage name: DeployProd"
                      echo "Build Source Branch: $(Build.SourceBranch)"
                      echo "Build Reason: $(Build.Reason)"
                      echo "Environment parameter: ${{ parameters.environment }}"
                      echo "Instance Number: $(instanceNum)"
                      echo "Resource Group: rg-aistock-prod-$(instanceNum)"
                      echo "Web App Name: app-aistock-prod-$(instanceNum)"
                      echo "Container image from artifact: $(containerImage)"

                - task: AzureCLI@2
                  displayName: "Get Azure AD information for SQL Admin"
                  inputs:
                    azureSubscription: "$(AZURE_SERVICE_CONNECTION)"
                    scriptType: "bash"
                    scriptLocation: "inlineScript"
                    inlineScript: |
                      echo "Getting Azure AD information for SQL Server administration..."
                      
                      # Get the service principal information from the service connection
                      # The service connection provides authentication context
                      echo "Retrieving service principal information from connection context..."
                      
                      # Get service principal details using Azure CLI context
                      SP_INFO=$(az account show)
                      TENANT_ID=$(echo "$SP_INFO" | jq -r '.tenantId')
                      
                      # For Azure DevOps, we'll use a predefined service principal name or get it from variables
                      # This should be configured in your Azure DevOps variables
                      if [ -n "$(AZURE_CLIENT_ID)" ]; then
                        CLIENT_ID="$(AZURE_CLIENT_ID)"
                        echo "Using client ID from variable: $CLIENT_ID"
                        
                        SP_DETAILS=$(az ad sp show --id "$CLIENT_ID")
                        SP_OBJECT_ID=$(echo "$SP_DETAILS" | jq -r '.id')
                        SP_DISPLAY_NAME=$(echo "$SP_DETAILS" | jq -r '.displayName')
                      else
                        echo "AZURE_CLIENT_ID variable not set. Using account context..."
                        # Fallback: try to get service principal from current context
                        SUBSCRIPTION_INFO=$(az account show)
                        SP_OBJECT_ID=$(echo "$SUBSCRIPTION_INFO" | jq -r '.user.name')
                        SP_DISPLAY_NAME="Azure DevOps Service Principal"
                      fi
                      
                      echo "Service principal object ID: $SP_OBJECT_ID"
                      echo "Service principal display name: $SP_DISPLAY_NAME"
                      
                      echo "##vso[task.setvariable variable=azureAdAdminObjectId]$SP_OBJECT_ID"
                      echo "##vso[task.setvariable variable=azureAdAdminLogin]$SP_DISPLAY_NAME"

                - task: Bash@3
                  displayName: "Derive Azure AD auth enable flag"
                  inputs:
                    targetType: "inline"
                    script: |
                      echo "Evaluating whether to enable Azure AD only auth..."
                      if [ -n "$(azureAdAdminObjectId)" ] && [ -n "$(azureAdAdminLogin)" ]; then
                        echo "Azure AD admin details present. Enabling AAD only auth."
                        echo "##vso[task.setvariable variable=enableAdOnlyAuthFlag]true"
                      else
                        echo "Azure AD admin details missing (objectId='$(azureAdAdminObjectId)', login='$(azureAdAdminLogin)'). Disabling AAD only auth for this deployment."
                        echo "##vso[task.setvariable variable=enableAdOnlyAuthFlag]false"
                      fi
                      echo "enableAdOnlyAuthFlag=$(enableAdOnlyAuthFlag)"

                - task: AzureResourceManagerTemplateDeployment@3
                  displayName: "Deploy Bicep template"
                  inputs:
                    deploymentScope: "Resource Group"
                    azureResourceManagerConnection: "$(AZURE_SERVICE_CONNECTION)"
                    subscriptionId: "$(AZURE_SUBSCRIPTION_ID)"
                    action: "Create Or Update Resource Group"
                    resourceGroupName: "rg-aistock-prod-$(instanceNum)"
                    location: "Canada Central"
                    templateLocation: "Linked artifact"
                    csmFile: "./ai-stock-trade-app/infrastructure/main.bicep"
                    csmParametersFile: "./ai-stock-trade-app/infrastructure/parameters.prod.json"
                    # Only pass parameters that differ from parameter file defaults to prevent empty value issues
                    overrideParameters: "-instanceNumber $(instanceNum) -containerImage $(containerImage) -enableAzureAdOnlyAuth $(enableAdOnlyAuthFlag) -azureAdAdminObjectId $(azureAdAdminObjectId) -azureAdAdminLogin '$(azureAdAdminLogin)'"
                    deploymentMode: "Incremental"

                - task: AzureCLI@2
                  displayName: "Setup Web App SQL Database Access (Azure AD)"
                  inputs:
                    azureSubscription: "$(AZURE_SERVICE_CONNECTION)"
                    scriptType: "bash"
                    scriptLocation: "inlineScript"
                    inlineScript: |
                      INSTANCE_NUM="$(instanceNum)"
                      RG_NAME="rg-aistock-prod-$(instanceNum)"
                      WEBAPP_NAME="app-aistock-prod-$(instanceNum)"
                      SQL_SERVER_NAME="sql-aistock-prod-$(instanceNum)"
                      DATABASE_NAME="sqldb-aistock-prod-$(instanceNum)"
                      
                      echo "üîß Setting up SQL Database access for Web App managed identity..."
                      echo "Web App: ${WEBAPP_NAME}"
                      echo "SQL Server: ${SQL_SERVER_NAME}"
                      echo "Database: ${DATABASE_NAME}"
                      
                      # First, verify the web app managed identity is enabled
                      echo "üîç Verifying web app managed identity..."
                      MANAGED_IDENTITY=$(az webapp identity show --name "${WEBAPP_NAME}" --resource-group "${RG_NAME}" --query "principalId" --output tsv 2>/dev/null || echo "")
                      
                      if [ -z "${MANAGED_IDENTITY}" ] || [ "${MANAGED_IDENTITY}" == "null" ]; then
                        echo "‚ö†Ô∏è Web app managed identity not found. Enabling it..."
                        az webapp identity assign --name "${WEBAPP_NAME}" --resource-group "${RG_NAME}"
                        sleep 10  # Wait for identity propagation
                        MANAGED_IDENTITY=$(az webapp identity show --name "${WEBAPP_NAME}" --resource-group "${RG_NAME}" --query "principalId" --output tsv)
                      fi
                      
                      echo "‚úÖ Web app managed identity ID: ${MANAGED_IDENTITY}"
                      
                      # Get the SQL Server FQDN
                      SQL_SERVER_FQDN="${SQL_SERVER_NAME}.database.windows.net"
                      
                      echo "üîê Attempting to create SQL user for managed identity..."
                      
                      # Install sqlcmd tools
                      echo "Installing sqlcmd..."
                      curl https://packages.microsoft.com/keys/microsoft.asc | sudo apt-key add -
                      curl https://packages.microsoft.com/config/ubuntu/20.04/prod.list | sudo tee /etc/apt/sources.list.d/msprod.list
                      sudo apt-get update
                      sudo apt-get install -y mssql-tools unixodbc-dev
                      
                      echo "Testing basic connectivity to SQL Server..."
                      if ! timeout 10 bash -c "</dev/tcp/${SQL_SERVER_NAME}.database.windows.net/1433" 2>/dev/null; then
                        echo "‚ùå Cannot connect to SQL Server on port 1433. Check firewall rules."
                        exit 1
                      else
                        echo "‚úÖ SQL Server is reachable on port 1433"
                      fi
                      
                      echo "Attempting to create managed identity user in SQL database..."
                      
                      # Create SQL script with better error handling
                      cat > setup_managed_identity.sql << EOF
                      -- Switch to the target database
                      USE [${DATABASE_NAME}];
                      GO
                      
                      -- Check if user already exists
                      IF NOT EXISTS (SELECT * FROM sys.database_principals WHERE name = '${WEBAPP_NAME}')
                      BEGIN
                          PRINT 'Creating managed identity user: ${WEBAPP_NAME}';
                          CREATE USER [${WEBAPP_NAME}] FROM EXTERNAL PROVIDER;
                          PRINT 'User created successfully';
                          
                          -- Assign roles
                          ALTER ROLE db_datareader ADD MEMBER [${WEBAPP_NAME}];
                          PRINT 'Added to db_datareader role';
                          
                          ALTER ROLE db_datawriter ADD MEMBER [${WEBAPP_NAME}];
                          PRINT 'Added to db_datawriter role';
                          
                          ALTER ROLE db_ddladmin ADD MEMBER [${WEBAPP_NAME}];
                          PRINT 'Added to db_ddladmin role';
                          
                          PRINT 'Managed identity user created and roles assigned successfully';
                      END
                      ELSE
                      BEGIN
                          PRINT 'Managed identity user already exists: ${WEBAPP_NAME}';
                          
                          -- Verify roles are assigned
                          IF IS_ROLEMEMBER('db_datareader', '${WEBAPP_NAME}') = 1
                              PRINT '‚úì db_datareader role confirmed';
                          ELSE
                              PRINT '‚ö† Adding db_datareader role';
                              ALTER ROLE db_datareader ADD MEMBER [${WEBAPP_NAME}];
                          
                          IF IS_ROLEMEMBER('db_datawriter', '${WEBAPP_NAME}') = 1
                              PRINT '‚úì db_datawriter role confirmed';
                          ELSE
                              PRINT '‚ö† Adding db_datawriter role';
                              ALTER ROLE db_datawriter ADD MEMBER [${WEBAPP_NAME}];
                          
                          IF IS_ROLEMEMBER('db_ddladmin', '${WEBAPP_NAME}') = 1
                              PRINT '‚úì db_ddladmin role confirmed';
                          ELSE
                              PRINT '‚ö† Adding db_ddladmin role';
                              ALTER ROLE db_ddladmin ADD MEMBER [${WEBAPP_NAME}];
                      END
                      GO
                      
                      -- Show final user permissions
                      SELECT 
                          dp.name AS principal_name,
                          dp.type_desc AS principal_type,
                          r.name AS role_name
                      FROM sys.database_principals dp
                      JOIN sys.database_role_members rm ON dp.principal_id = rm.member_principal_id
                      JOIN sys.database_principals r ON rm.role_principal_id = r.principal_id
                      WHERE dp.name = '${WEBAPP_NAME}';
                      GO
                      EOF
                      
                      # Execute the SQL script with detailed logging
                      echo "Executing SQL script..."
                      if /opt/mssql-tools/bin/sqlcmd -S "${SQL_SERVER_FQDN}" -d "${DATABASE_NAME}" -G -l 30 -i setup_managed_identity.sql; then
                        echo "‚úÖ Successfully executed SQL script for managed identity setup"
                        
                        # Test the connection with a simple query
                        echo "Testing managed identity connection..."
                        cat > test_connection.sql << EOF
                        SELECT 
                            USER_NAME() as current_user,
                            SYSTEM_USER as system_user,
                            DB_NAME() as database_name,
                            GETDATE() as current_time;
                        EOF
                        
                        if /opt/mssql-tools/bin/sqlcmd -S "${SQL_SERVER_FQDN}" -d "${DATABASE_NAME}" -G -l 30 -i test_connection.sql; then
                          echo "‚úÖ Connection test successful"
                        else
                          echo "‚ö†Ô∏è Connection test failed, but user creation may have succeeded"
                        fi
                      else
                        echo "‚ùå Failed to execute SQL script. Error details above."
                        echo ""
                        echo "üîß Manual Steps Required:"
                        echo "Please connect to SQL Server as an Azure AD admin and run:"
                        echo "  Server: ${SQL_SERVER_FQDN}"
                        echo "  Database: ${DATABASE_NAME}"
                        echo "  Authentication: Azure Active Directory - Universal with MFA"
                        echo ""
                        echo "SQL Commands:"
                        echo "  USE [${DATABASE_NAME}];"
                        echo "  CREATE USER [${WEBAPP_NAME}] FROM EXTERNAL PROVIDER;"
                        echo "  ALTER ROLE db_datareader ADD MEMBER [${WEBAPP_NAME}];"
                        echo "  ALTER ROLE db_datawriter ADD MEMBER [${WEBAPP_NAME}];"
                        echo "  ALTER ROLE db_ddladmin ADD MEMBER [${WEBAPP_NAME}];"
                        echo ""
                        echo "The deployment will continue, but the application may fail until this is resolved."
                      fi

                - task: DotNetCoreCLI@2
                  displayName: "Setup .NET for migrations"
                  inputs:
                    command: "custom"
                    custom: "tool"
                    arguments: "install --global dotnet-ef"

                - task: AzureCLI@2
                  displayName: "Run database migrations"
                  inputs:
                    azureSubscription: "$(AZURE_SERVICE_CONNECTION)"
                    scriptType: "bash"
                    scriptLocation: "inlineScript"
                    inlineScript: |
                      INSTANCE_NUM="$(instanceNum)"
                      RG_NAME="rg-aistock-prod-$(instanceNum)"
                      
                      echo "üóÑÔ∏è Checking database migration options..."
                      echo "Resource Group: ${RG_NAME}"
                      
                      # Try to get connection string from Key Vault, but don't fail if access is denied
                      KEY_VAULT_NAME="kv-aistock-prod-$(instanceNum)"
                      echo "Attempting to retrieve connection string from Key Vault: ${KEY_VAULT_NAME}"
                      
                      CONNECTION_STRING=$(az keyvault secret show --vault-name "${KEY_VAULT_NAME}" --name "SqlConnectionString" --query "value" --output tsv 2>/dev/null || echo "")
                      
                      if [ -z "${CONNECTION_STRING}" ]; then
                        echo "‚ÑπÔ∏è Could not retrieve connection string from Key Vault."
                        echo "This is expected for first-time deployments or when pipeline doesn't have Key Vault access."
                        echo ""
                        echo "üöÄ Database migrations will run automatically on first app startup."
                        echo "The application is configured to:"
                        echo "  1. Use Azure AD managed identity authentication"
                        echo "  2. Run Entity Framework migrations automatically"
                        echo "  3. Create necessary database schema"
                        echo ""
                        echo "‚úÖ Skipping manual migration - letting app handle it during startup"
                      else
                        echo "‚úÖ Retrieved connection string from Key Vault"
                        echo "Connection string type: $(echo "${CONNECTION_STRING}" | grep -o 'Authentication=[^;]*' || echo 'SQL Authentication')"
                        
                        if echo "${CONNECTION_STRING}" | grep -q "Authentication=Active Directory Default"; then
                          echo "üîê Using Azure AD authentication for migrations"
                        else
                          echo "üîë Using SQL authentication for migrations"
                        fi
                        
                        echo "Running database migrations manually..."
                        cd ai-stock-trade-app
                        export ConnectionStrings__DefaultConnection="${CONNECTION_STRING}"
                        
                        # Run with verbose output
                        echo "Starting Entity Framework migration..."
                        dotnet ef database update --verbose
                        
                        if [ $? -eq 0 ]; then
                          echo "‚úÖ Database migrations completed successfully"
                        else
                          echo "‚ö†Ô∏è Migration failed, but this may be handled during app startup"
                        fi
                      fi

                - task: AzureCLI@2
                  displayName: "Update Web App Container"
                  inputs:
                    azureSubscription: "$(AZURE_SERVICE_CONNECTION)"
                    scriptType: "bash"
                    scriptLocation: "inlineScript"
                    inlineScript: |
                      WEBAPP_NAME="app-aistock-prod-$(instanceNum)"
                      RG_NAME="rg-aistock-prod-$(instanceNum)"

                      # Get registry information from DEV resource group (shared registry)
                      DEV_RG_NAME="rg-aistock-dev-$(instanceNum)"
                      REGISTRY_NAME=$(az acr list --resource-group "${DEV_RG_NAME}" --query '[0].name' --output tsv)
                      REGISTRY_USERNAME=$(az acr credential show --name "${REGISTRY_NAME}" --query 'username' --output tsv)
                      REGISTRY_PASSWORD=$(az acr credential show --name "${REGISTRY_NAME}" --query 'passwords[0].value' --output tsv)

                      echo "Container Image: $(containerImage)"
                      echo "Web App Name: ${WEBAPP_NAME}"
                      echo "Prod Resource Group: ${RG_NAME}"
                      echo "Dev Registry Resource Group: ${DEV_RG_NAME}"
                      echo "Shared Registry Name: ${REGISTRY_NAME}"

                      if [ -z "$(containerImage)" ]; then
                        echo "ERROR: Container image is empty!"
                        exit 1
                      fi

                      az webapp config container set \
                        --name "${WEBAPP_NAME}" \
                        --resource-group "${RG_NAME}" \
                        --container-image-name "$(containerImage)" \
                        --container-registry-url "https://${REGISTRY_NAME}.azurecr.io" \
                        --container-registry-user "${REGISTRY_USERNAME}" \
                        --container-registry-password "${REGISTRY_PASSWORD}"

                - task: AzureCLI@2
                  displayName: "Run Health Check"
                  inputs:
                    azureSubscription: "$(AZURE_SERVICE_CONNECTION)"
                    scriptType: "bash"
                    scriptLocation: "inlineScript"
                    inlineScript: |
                      WEBAPP_NAME="app-aistock-prod-$(instanceNum)"
                      HEALTH_URL="https://${WEBAPP_NAME}.azurewebsites.net/health"
                      BASE_URL="https://${WEBAPP_NAME}.azurewebsites.net"
                      
                      echo "üè• Starting comprehensive health check..."
                      echo "Base URL: ${BASE_URL}"
                      echo "Health URL: ${HEALTH_URL}"
                      
                      # Wait for initial deployment
                      echo "Waiting for deployment to be ready..."
                      sleep 60
                      
                      # Check if the site is accessible at all
                      echo "Testing basic site accessibility..."
                      for i in {1..5}; do
                        if curl -f -s "${BASE_URL}" >/dev/null 2>&1; then
                          echo "‚úÖ Site is accessible (attempt $i)"
                          break
                        else
                          echo "‚è≥ Site not ready yet (attempt $i/5)..."
                          sleep 30
                        fi
                      done
                      
                      # Check health endpoint specifically
                      echo "Testing health endpoint..."
                      for i in {1..10}; do
                        echo "Health check attempt $i/10..."
                        
                        # Get detailed response
                        HTTP_CODE=$(curl -s -o /tmp/health_response.txt -w "%{http_code}" "${HEALTH_URL}")
                        RESPONSE_BODY=$(cat /tmp/health_response.txt 2>/dev/null || echo "No response body")
                        
                        echo "HTTP Status: ${HTTP_CODE}"
                        echo "Response: ${RESPONSE_BODY}"
                        
                        if [ "${HTTP_CODE}" = "200" ]; then
                          echo "‚úÖ Health check passed!"
                          echo "Deployment successful and application is healthy."
                          exit 0
                        elif [ "${HTTP_CODE}" = "503" ] || [ "${HTTP_CODE}" = "500" ]; then
                          echo "‚ö†Ô∏è Application error detected (HTTP ${HTTP_CODE})"
                          echo "This might be a database connectivity issue."
                          
                          # Try to get more detailed logs
                          echo "Attempting to get application logs..."
                          az webapp log tail --name "${WEBAPP_NAME}" --resource-group "rg-aistock-prod-$(instanceNum)" --timeout 30 || echo "Could not retrieve logs"
                          
                          if [ $i -eq 10 ]; then
                            echo "‚ùå Health check failed after 10 attempts"
                            echo "Last response (HTTP ${HTTP_CODE}): ${RESPONSE_BODY}"
                            echo ""
                            echo "üîç Troubleshooting steps:"
                            echo "1. Check Azure portal for app service logs"
                            echo "2. Verify managed identity SQL user was created"
                            echo "3. Check Key Vault access permissions"
                            echo "4. Verify SQL Server firewall allows Azure services"
                            exit 1
                          fi
                        else
                          echo "‚è≥ Unexpected response (HTTP ${HTTP_CODE}), retrying..."
                        fi
                        
                        sleep 30
                      done
                      
                      echo "‚ùå Health check failed - no successful response received"
                      exit 1

  - stage: SecurityScan
    displayName: "Security Scan"
    dependsOn: Build
    condition: |
      and(
        succeeded(),
        eq(variables['Build.Reason'], 'PullRequest')
      )
    jobs:
      - job: SecurityScanJob
        displayName: "Security Scan"
        steps:
          - checkout: self
            displayName: "Checkout code"

          - task: DownloadPipelineArtifact@2
            displayName: "Download build outputs"
            inputs:
              artifactName: "build-outputs"
              downloadPath: "$(Pipeline.Workspace)/build-outputs"

          - task: Bash@3
            displayName: "Load container image from artifact"
            inputs:
              targetType: "inline"
              script: |
                if [ -f "$(Pipeline.Workspace)/build-outputs/container-image.txt" ]; then
                  CONTAINER_IMAGE=$(cat $(Pipeline.Workspace)/build-outputs/container-image.txt)
                  echo "Container image from artifact: '${CONTAINER_IMAGE}'"
                  echo "##vso[task.setvariable variable=containerImage]${CONTAINER_IMAGE}"
                else
                  echo "ERROR: container-image.txt not found in artifacts!"
                  exit 1
                fi

          # Note: For Trivy scanning in Azure DevOps, you would need to install Trivy
          # or use a marketplace extension. This is a placeholder for the security scan.
          - task: Bash@3
            displayName: "Run Security Scan (Placeholder)"
            inputs:
              targetType: "inline"
              script: |
                echo "=== SECURITY SCAN ==="
                echo "Container image to scan: $(containerImage)"
                echo "In a real implementation, this would run Trivy or similar security scanner"
                echo "Results would be published to Azure DevOps security dashboard"
