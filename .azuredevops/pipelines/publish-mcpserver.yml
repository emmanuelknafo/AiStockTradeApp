# Azure DevOps CI/CD Pipeline for MCP Server Publishing to Azure Artifacts
# Converted from GitHub Actions workflow: publish-mcpserver.yml

trigger:
  branches:
    include:
      - main
  paths:
    include:
      - 'AiStockTradeApp.McpServer/**'
      - '.azuredevops/pipelines/publish-mcpserver.yml'
    exclude:
      - 'AiStockTradeApp.McpServer/**/*.md'

# Allow manual trigger for testing
pr: none

parameters:
  - name: forcePublish
    displayName: "Force publish even if version exists"
    type: boolean
    default: false

variables:
  - group: "AiStockTradeApp-Packages" # Variable group for shared variables including Azure Artifacts feed
  - name: PROJECT_PATH
    value: 'AiStockTradeApp.McpServer/AiStockTradeApp.McpServer.csproj'
  - name: BUILD_CONFIGURATION
    value: 'Release'
  - name: DOTNET_VERSION
    value: '9.0.x'
  - name: vmImageName
    value: 'ubuntu-22.04'
  # Azure DevOps Artifacts configuration
  - name: AZURE_DEVOPS_FEED_NAME
    value: 'AiStockTradeApp' # Configure this feed name in your Azure DevOps project
  - name: AZURE_DEVOPS_ORGANIZATION
    value: 'MngEnvMCAP675646' # Your Azure DevOps organization name
  - name: AZURE_DEVOPS_PROJECT
    value: 'AiStockTradeApp' # Your Azure DevOps project name

pool:
  vmImage: $(vmImageName)

stages:
  - stage: PublishMcpServer
    displayName: "Build and Publish MCP Server Package"
    jobs:
      - job: PublishJob
        displayName: "Build and Publish MCP Server"
        steps:
          - checkout: self
            displayName: "Checkout repository"
            fetchDepth: 0 # Fetch full history for proper versioning
            persistCredentials: true
            clean: true

          - task: UseDotNet@2
            displayName: "Setup .NET"
            inputs:
              packageType: "sdk"
              version: $(DOTNET_VERSION)
              includePreviewVersions: true

          - task: DotNetCoreCLI@2
            displayName: "Restore dependencies"
            inputs:
              command: "restore"
              projects: "$(PROJECT_PATH)"

          - task: DotNetCoreCLI@2
            displayName: "Build project"
            inputs:
              command: "build"
              projects: "$(PROJECT_PATH)"
              arguments: "--configuration $(BUILD_CONFIGURATION) --no-restore -p:PublishTarget=AzureDevOps"

          # Change detection and auto-increment logic
          - task: PowerShell@2
            displayName: "Check for MCP Server changes since last release"
            inputs:
              targetType: "inline"
              script: |
                # Check if there are changes in the MCP Server project since last build tag
                try {
                    # Find the last tag for MCP Server releases
                    $lastTag = git describe --tags --abbrev=0 --match="mcpserver-v*" 2>$null
                    
                    if (-not $lastTag) {
                        Write-Host "No previous release found, treating as first release"
                        Write-Host "##vso[task.setvariable variable=HasChanges]true"
                        Write-Host "##vso[task.setvariable variable=ChangeType]initial"
                        Write-Host "##vso[task.setvariable variable=IncrementType]patch"
                    } else {
                        Write-Host "Last release tag: $lastTag"
                        
                        # Check for changes in MCP Server directory since last tag
                        $changes = git diff --name-only $lastTag HEAD -- AiStockTradeApp.McpServer/
                        
                        if ($changes) {
                            Write-Host "Changes detected in MCP Server since ${lastTag}:"
                            $changes | ForEach-Object { Write-Host "  $_" }
                            Write-Host "##vso[task.setvariable variable=HasChanges]true"
                            Write-Host "##vso[task.setvariable variable=ChangeType]update"
                            
                            # Determine change severity based on file types
                            $hasCodeChanges = $changes | Where-Object { $_ -match '\.cs$' }
                            $hasConfigChanges = $changes | Where-Object { $_ -match '\.(csproj|json)$' }
                            
                            if ($hasCodeChanges) {
                                Write-Host "Code changes detected - will increment minor version"
                                Write-Host "##vso[task.setvariable variable=IncrementType]minor"
                            } elseif ($hasConfigChanges) {
                                Write-Host "Configuration changes detected - will increment patch version"
                                Write-Host "##vso[task.setvariable variable=IncrementType]patch"
                            } else {
                                Write-Host "Documentation/other changes detected - will increment patch version"
                                Write-Host "##vso[task.setvariable variable=IncrementType]patch"
                            }
                        } else {
                            Write-Host "No changes detected in MCP Server since ${lastTag}"
                            Write-Host "##vso[task.setvariable variable=HasChanges]false"
                            Write-Host "##vso[task.setvariable variable=ChangeType]none"
                        }
                    }
                } catch {
                    Write-Host "Error checking for changes: $($_.Exception.Message)"
                    Write-Host "Treating as changed to be safe"
                    Write-Host "##vso[task.setvariable variable=HasChanges]true"
                    Write-Host "##vso[task.setvariable variable=ChangeType]update"
                    Write-Host "##vso[task.setvariable variable=IncrementType]patch"
                }

          - task: PowerShell@2
            displayName: "Check for version changes and auto-increment"
            inputs:
              targetType: "inline"
              script: |
                # Extract version from csproj file
                $csprojContent = Get-Content "$(PROJECT_PATH)" -Raw
                $versionMatch = [regex]::Match($csprojContent, '<PackageVersion>([^<]+)</PackageVersion>')
                
                if (-not $versionMatch.Success) {
                    Write-Host "##vso[task.logissue type=error]PackageVersion not found in $(PROJECT_PATH)"
                    exit 1
                }
                
                $currentVersion = $versionMatch.Groups[1].Value
                Write-Host "Current version: $currentVersion"
                
                # Extract PackageId
                $packageIdMatch = [regex]::Match($csprojContent, '<PackageId>([^<]+)</PackageId>')
                $packageId = if ($packageIdMatch.Success) { $packageIdMatch.Groups[1].Value } else { "AiStockTradeApp.McpServer" }
                Write-Host "Package ID: $packageId"
                
                Write-Host "##vso[task.setvariable variable=PackageId]$packageId"
                Write-Host "##vso[task.setvariable variable=CurrentVersion]$currentVersion"
                
                # Check if we should publish based on changes
                $hasChanges = $env:HasChanges -eq 'true'
                $changeType = $env:ChangeType
                $incrementType = $env:IncrementType
                
                Write-Host "Has changes: $hasChanges"
                Write-Host "Change type: $changeType"
                Write-Host "Increment type: $incrementType"
                
                $shouldPublish = $false
                $autoIncremented = $false
                $newVersion = $currentVersion
                
                # Skip publishing if no changes detected (unless forced)
                if (-not $hasChanges -and '${{ parameters.forcePublish }}' -ne 'True') {
                    Write-Host "No changes detected in MCP Server - skipping publish"
                    $shouldPublish = $false
                } else {
                    Write-Host "Changes detected or force publish enabled - proceeding"
                    
                    # Auto-increment version based on change type
                    if ($hasChanges -and $changeType -ne 'none') {
                        Write-Host "Auto-incrementing version from $currentVersion (increment type: $incrementType)"
                        
                        # Parse version parts (supports formats like 1.0.0-beta, 1.0.0-beta.1, etc.)
                        if ($currentVersion -match '^(\d+)\.(\d+)\.(\d+)(-[a-zA-Z]+)?(\.\d+)?$') {
                            $major = [int]$Matches[1]
                            $minor = [int]$Matches[2]
                            $patch = [int]$Matches[3]
                            $prerelease = $Matches[4]
                            $build = $Matches[5]
                            
                            # Increment based on change type and current version format
                            if ($build) {
                                # Has build number (e.g., 1.0.0-beta.1), increment build
                                $buildNum = [int]$build.Substring(1)
                                $newBuildNum = $buildNum + 1
                                $newVersion = "$major.$minor.$patch$prerelease.$newBuildNum"
                            } elseif ($prerelease) {
                                # Has prerelease but no build (e.g., 1.0.0-beta), add .1
                                $newVersion = "$major.$minor.$patch$prerelease.1"
                            } else {
                                # Release version - increment based on change type
                                if ($incrementType -eq 'minor') {
                                    $newMinor = $minor + 1
                                    $newVersion = "$major.$newMinor.0"
                                } else {
                                    # Default to patch increment
                                    $newPatch = $patch + 1
                                    $newVersion = "$major.$minor.$newPatch"
                                }
                            }
                            
                            Write-Host "New version: $newVersion"
                            
                            # Update csproj file
                            $updatedContent = $csprojContent -replace '<PackageVersion>[^<]+</PackageVersion>', "<PackageVersion>$newVersion</PackageVersion>"
                            Set-Content -Path "$(PROJECT_PATH)" -Value $updatedContent
                            
                            # Update .mcp/server-azuredevops.json (the source for Azure DevOps packages)
                            $mcpServerAzureJson = "AiStockTradeApp.McpServer/.mcp/server-azuredevops.json"
                            if (Test-Path $mcpServerAzureJson) {
                                $jsonContent = Get-Content $mcpServerAzureJson -Raw
                                $updatedJsonContent = $jsonContent -replace '"version": "[^"]*"', """version"": ""$newVersion"""
                                Set-Content -Path $mcpServerAzureJson -Value $updatedJsonContent
                                Write-Host "Updated $mcpServerAzureJson"
                            }
                            
                            # Also update the main server.json if it exists
                            $mcpServerJson = "AiStockTradeApp.McpServer/.mcp/server.json"
                        } else {
                            Write-Host "##vso[task.logissue type=error]Could not parse version format: $currentVersion"
                            exit 1
                        }
                    } else {
                        Write-Host "Using current version: $currentVersion"
                        $shouldPublish = $true
                    }
                }
                
                Write-Host "##vso[task.setvariable variable=ShouldPublish]$shouldPublish"
                Write-Host "##vso[task.setvariable variable=FinalVersion]$newVersion"
                Write-Host "##vso[task.setvariable variable=AutoIncremented]$autoIncremented"

          - task: DotNetCoreCLI@2
            displayName: "Pack project"
            condition: eq(variables['ShouldPublish'], 'True')
            inputs:
              command: "pack"
              packagesToPack: "$(PROJECT_PATH)"
              configuration: "$(BUILD_CONFIGURATION)"
              outputDir: "$(Build.ArtifactStagingDirectory)/packages"
              nobuild: true
              buildProperties: "PublishTarget=AzureDevOps"

          - task: PowerShell@2
            displayName: "Validate package contents"
            condition: eq(variables['ShouldPublish'], 'True')
            inputs:
              targetType: "inline"
              script: |
                Write-Host "Checking package contents..."
                $packageFile = Get-ChildItem -Path "$(Build.ArtifactStagingDirectory)/packages" -Filter "*.nupkg" | Select-Object -First 1
                
                if (-not $packageFile) {
                    Write-Host "##vso[task.logissue type=error]No package file found!"
                    exit 1
                }
                
                Write-Host "Package file: $($packageFile.FullName)"
                
                # Check if .mcp/server.json is included in the package
                $zipContent = [System.IO.Compression.ZipFile]::OpenRead($packageFile.FullName)
                $mcpServerJsonFound = $zipContent.Entries | Where-Object { $_.FullName -like "*/.mcp/server.json" -or $_.FullName -like "*.mcp/server.json" }
                $readmeFound = $zipContent.Entries | Where-Object { $_.FullName -like "*README.md" }
                $zipContent.Dispose()
                
                if ($mcpServerJsonFound) {
                    Write-Host "✅ .mcp/server.json found in package"
                } else {
                    Write-Host "##vso[task.logissue type=error]❌ .mcp/server.json not found in package"
                    exit 1
                }
                
                if ($readmeFound) {
                    Write-Host "✅ README.md found in package"
                } else {
                    Write-Host "##vso[task.logissue type=warning]❌ README.md not found in package"
                }
                
                Write-Host "Package validation completed successfully"

          # Verify Azure DevOps Artifacts feed exists before publishing
          - task: PowerShell@2
            displayName: "Verify Azure DevOps Artifacts feed"
            condition: eq(variables['ShouldPublish'], 'True')
            inputs:
              targetType: "inline"
              script: |
                Write-Host "Verifying Azure DevOps Artifacts feed configuration..."
                Write-Host "Organization: $(AZURE_DEVOPS_ORGANIZATION)"
                Write-Host "Project: $(AZURE_DEVOPS_PROJECT)"
                Write-Host "Feed: $(AZURE_DEVOPS_FEED_NAME)"
                
                $feedUrl = "https://pkgs.dev.azure.com/$(AZURE_DEVOPS_ORGANIZATION)/$(AZURE_DEVOPS_PROJECT)/_packaging/$(AZURE_DEVOPS_FEED_NAME)/nuget/v3/index.json"
                Write-Host "Feed URL: $feedUrl"
                
                # Note: The actual feed existence check would require authentication
                # This is mainly for logging the configuration for debugging
                Write-Host "Configuration verified. Proceeding with publish..."

          # Publish to Azure DevOps Artifacts using NuGet authenticate and push
          - task: NuGetAuthenticate@1
            displayName: "Authenticate with Azure DevOps Artifacts"
            condition: eq(variables['ShouldPublish'], 'True')

          - task: PowerShell@2
            displayName: "Push to Azure DevOps Artifacts with skip-duplicate"
            condition: eq(variables['ShouldPublish'], 'True')
            inputs:
              targetType: "inline"
              script: |
                $packageFile = Get-ChildItem -Path "$(Build.ArtifactStagingDirectory)/packages" -Filter "*.nupkg" | Select-Object -First 1
                if (-not $packageFile) {
                    Write-Host "##vso[task.logissue type=error]No package file found!"
                    exit 1
                }
                
                $feedUrl = "https://pkgs.dev.azure.com/$(AZURE_DEVOPS_ORGANIZATION)/$(AZURE_DEVOPS_PROJECT)/_packaging/$(AZURE_DEVOPS_FEED_NAME)/nuget/v3/index.json"
                Write-Host "Pushing package: $($packageFile.FullName)"
                Write-Host "To feed: $feedUrl"
                
                # Use dotnet nuget push with --skip-duplicate
                $pushCommand = "dotnet nuget push `"$($packageFile.FullName)`" --source `"$feedUrl`" --api-key `"VSTS`" --skip-duplicate"
                Write-Host "Command: $pushCommand"
                
                Invoke-Expression $pushCommand
                $exitCode = $LASTEXITCODE
                
                if ($exitCode -eq 0) {
                    Write-Host "✅ Package published successfully (or skipped as duplicate)"
                } else {
                    Write-Host "##vso[task.logissue type=error]❌ Package push failed with exit code: $exitCode"
                    exit $exitCode
                }

          # Backup approach - direct dotnet CLI command (fallback)
          - task: PowerShell@2
            displayName: "Push to Azure DevOps Artifacts (Alternative - Backup)"
            condition: and(eq(variables['ShouldPublish'], 'True'), failed())
            inputs:
              targetType: "inline"
              script: |
                Write-Host "Primary push failed, attempting backup method..."
                $packageFile = Get-ChildItem -Path "$(Build.ArtifactStagingDirectory)/packages" -Filter "*.nupkg" | Select-Object -First 1
                if (-not $packageFile) {
                    Write-Host "##vso[task.logissue type=error]No package file found!"
                    exit 1
                }
                
                # Try alternative feed URL format
                $feedUrl = "https://pkgs.dev.azure.com/$(AZURE_DEVOPS_ORGANIZATION)/$(AZURE_DEVOPS_PROJECT)/_packaging/$(AZURE_DEVOPS_FEED_NAME)/nuget/v3/index.json"
                Write-Host "Backup push - Package: $($packageFile.FullName)"
                Write-Host "Backup push - Feed: $feedUrl"
                
                $pushCommand = "dotnet nuget push `"$($packageFile.FullName)`" --source `"$feedUrl`" --api-key `"VSTS`" --skip-duplicate --no-service-endpoint"
                Write-Host "Backup command: $pushCommand"
                
                Invoke-Expression $pushCommand
                if ($LASTEXITCODE -eq 0) {
                    Write-Host "✅ Backup package push successful"
                } else {
                    Write-Host "##vso[task.logissue type=error]❌ Backup package push also failed"
                    exit $LASTEXITCODE
                }

          # Create a release in Azure DevOps (using Work Items or Git tags)
          - task: PowerShell@2
            displayName: "Create build tag and summary"
            condition: eq(variables['ShouldPublish'], 'True')
            inputs:
              targetType: "inline"
              script: |
                $version = "$(FinalVersion)"
                $packageId = "$(PackageId)"
                
                # Add build tag
                Write-Host "##vso[build.addbuildtag]mcpserver-v$version"
                Write-Host "##vso[build.addbuildtag]published"
                
                # Create Git tag
                git tag "mcpserver-v$version"
                git push origin "mcpserver-v$version"
                
                # Add to build summary
                $artifactsFeedUrl = "https://dev.azure.com/$(AZURE_DEVOPS_ORGANIZATION)/$(AZURE_DEVOPS_PROJECT)/_artifacts/feed/$(AZURE_DEVOPS_FEED_NAME)/NuGet/$packageId/overview/$version"
                
                $summary = @"
                ## 🎉 MCP Server Published Successfully!
                
                **Package:** ``$packageId``
                **Version:** ``$version``
                **Azure DevOps Artifacts URL:** [$artifactsFeedUrl]($artifactsFeedUrl)
                
                ### Installation from Azure DevOps Artifacts
                
                Add this package source to your NuGet configuration:
                ``````
                dotnet nuget add source "https://pkgs.dev.azure.com/$(AZURE_DEVOPS_ORGANIZATION)/$(AZURE_DEVOPS_PROJECT)/_packaging/$(AZURE_DEVOPS_FEED_NAME)/nuget/v3/index.json" --name "$(AZURE_DEVOPS_FEED_NAME)"
                ``````
                
                Then install the package:
                ``````
                dotnet add package $packageId --version $version --source "$(AZURE_DEVOPS_FEED_NAME)"
                ``````
                
                ### MCP Client Configuration
                
                Configure in your MCP client (VS Code or Visual Studio):
                
                ``````json
                {
                  "servers": {
                    "$packageId": {
                      "type": "stdio",
                      "command": "dotnet",
                      "args": [
                        "run",
                        "--project",
                        "path/to/AiStockTradeApp.McpServer.csproj"
                      ],
                      "env": {
                        "STOCK_API_BASE_URL": "https://your-api-url.com"
                      }
                    }
                  }
                }
                ``````
                
                ### What's Included
                - 🔌 MCP Server with stock trading tools
                - 📊 Real-time stock quotes
                - 📈 Historical data access
                - 🔍 Stock symbol search
                - 🏢 Company details lookup
                - ❤️ System health monitoring
                "@
                
                if ("$(AutoIncremented)" -eq "True") {
                    $summary += "`n`n**Auto-incremented:** Version was automatically bumped from existing version"
                }
                
                Write-Host "##vso[task.uploadsummary]$summary"

          - task: PowerShell@2
            displayName: "Skip publish summary"
            condition: eq(variables['ShouldPublish'], 'False')
            inputs:
              targetType: "inline"
              script: |
                $summary = @"
                ## ⏭️ Publish Skipped
                
                All versions were already published or auto-increment failed
                
                To publish a new version manually:
                1. Update the ``<PackageVersion>`` in the .csproj file
                2. Update the version in ``.mcp/server.json``
                3. Commit and push the changes
                4. Or run this pipeline with 'Force publish' enabled
                "@
                
                Write-Host "##vso[task.uploadsummary]$summary"

          # Upload package artifacts for retention
          - task: PublishPipelineArtifact@1
            displayName: "Upload NuGet packages as artifacts"
            condition: eq(variables['ShouldPublish'], 'True')
            inputs:
              targetPath: "$(Build.ArtifactStagingDirectory)/packages"
              artifactName: "nuget-packages"

  # Optional: Integration test stage to verify the published package
  - stage: VerifyPackage
    displayName: "Verify Published Package"
    dependsOn: PublishMcpServer
    condition: succeeded()
    jobs:
      - job: VerifyJob
        displayName: "Verify Package Installation"
        steps:
          - checkout: none

          - task: UseDotNet@2
            displayName: "Setup .NET"
            inputs:
              packageType: "sdk"
              version: $(DOTNET_VERSION)
              includePreviewVersions: true

          - task: NuGetAuthenticate@1
            displayName: "Authenticate with Azure DevOps Artifacts"

          - task: PowerShell@2
            displayName: "Create test project and verify package"
            inputs:
              targetType: "inline"
              script: |
                # Create a temporary test project
                $testDir = "$(Agent.TempDirectory)/mcp-test"
                New-Item -ItemType Directory -Path $testDir -Force
                Set-Location $testDir
                
                # Create a simple console app
                dotnet new console -n "McpServerTest"
                Set-Location "McpServerTest"
                
                # Add the Azure DevOps package source
                dotnet nuget add source "https://pkgs.dev.azure.com/$(AZURE_DEVOPS_ORGANIZATION)/$(AZURE_DEVOPS_PROJECT)/_packaging/$(AZURE_DEVOPS_FEED_NAME)/nuget/v3/index.json" --name "$(AZURE_DEVOPS_FEED_NAME)"
                
                # Try to add our published package
                $packageId = "$(PackageId)"
                $version = "$(FinalVersion)"
                
                Write-Host "Attempting to install package: $packageId version $version"
                dotnet add package $packageId --version $version --source "$(AZURE_DEVOPS_FEED_NAME)"
                
                # Verify the package was installed
                $csprojContent = Get-Content "McpServerTest.csproj" -Raw
                if ($csprojContent -like "*$packageId*") {
                    Write-Host "✅ Package successfully installed and referenced in project"
                } else {
                    Write-Host "##vso[task.logissue type=error]❌ Package was not properly installed"
                    exit 1
                }
                
                # Try to restore to ensure all dependencies are available
                dotnet restore
                Write-Host "✅ Package verification completed successfully"
